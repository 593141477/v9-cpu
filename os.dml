<stmt file=os.c line=1 start=0 end=0>
	<code>// os.c - based on xv6 with heavy modifications</code>
</stmt>
<stmt file=root/lib/u.h line=2 start=0 end=0>
	<code>#include <u.h></code>
</stmt>
<stmt file=root/lib/u.h line=1 start=0 end=0>
	<code>// u.h</code>
</stmt>
<stmt file=root/lib/u.h line=2 start=0 end=0>
	<code></code>
</stmt>
<stmt file=root/lib/u.h line=3 start=0 end=0>
	<code>// instruction set</code>
</stmt>
<stmt file=root/lib/u.h line=4 start=0 end=0>
	<code>enum {</code>
</stmt>
<stmt file=root/lib/u.h line=5 start=0 end=0>
	<code>  HALT,ENT ,LEV ,JMP ,JMPI,JSR ,JSRA,LEA ,LEAG,CYC ,MCPY,MCMP,MCHR,MSET, // system</code>
</stmt>
<stmt file=root/lib/u.h line=6 start=0 end=0>
	<code>  LL  ,LLS ,LLH ,LLC ,LLB ,LLD ,LLF ,LG  ,LGS ,LGH ,LGC ,LGB ,LGD ,LGF , // load a</code>
</stmt>
<stmt file=root/lib/u.h line=7 start=0 end=0>
	<code>  LX  ,LXS ,LXH ,LXC ,LXB ,LXD ,LXF ,LI  ,LHI ,LIF ,</code>
</stmt>
<stmt file=root/lib/u.h line=8 start=0 end=0>
	<code>  LBL ,LBLS,LBLH,LBLC,LBLB,LBLD,LBLF,LBG ,LBGS,LBGH,LBGC,LBGB,LBGD,LBGF, // load b</code>
</stmt>
<stmt file=root/lib/u.h line=9 start=0 end=0>
	<code>  LBX ,LBXS,LBXH,LBXC,LBXB,LBXD,LBXF,LBI ,LBHI,LBIF,LBA ,LBAD,</code>
</stmt>
<stmt file=root/lib/u.h line=10 start=0 end=0>
	<code>  SL  ,SLH ,SLB ,SLD ,SLF ,SG  ,SGH ,SGB ,SGD ,SGF ,                     // store</code>
</stmt>
<stmt file=root/lib/u.h line=11 start=0 end=0>
	<code>  SX  ,SXH ,SXB ,SXD ,SXF ,</code>
</stmt>
<stmt file=root/lib/u.h line=12 start=0 end=0>
	<code>  ADDF,SUBF,MULF,DIVF,                                                   // arithmetic</code>
</stmt>
<stmt file=root/lib/u.h line=13 start=0 end=0>
	<code>  ADD ,ADDI,ADDL,SUB ,SUBI,SUBL,MUL ,MULI,MULL,DIV ,DIVI,DIVL,</code>
</stmt>
<stmt file=root/lib/u.h line=14 start=0 end=0>
	<code>  DVU ,DVUI,DVUL,MOD ,MODI,MODL,MDU ,MDUI,MDUL,AND ,ANDI,ANDL,</code>
</stmt>
<stmt file=root/lib/u.h line=15 start=0 end=0>
	<code>  OR  ,ORI ,ORL ,XOR ,XORI,XORL,SHL ,SHLI,SHLL,SHR ,SHRI,SHRL,</code>
</stmt>
<stmt file=root/lib/u.h line=16 start=0 end=0>
	<code>  SRU ,SRUI,SRUL,EQ  ,EQF ,NE  ,NEF ,LT  ,LTU ,LTF ,GE  ,GEU ,GEF ,      // logical</code>
</stmt>
<stmt file=root/lib/u.h line=17 start=0 end=0>
	<code>  BZ  ,BZF ,BNZ ,BNZF,BE  ,BEF ,BNE ,BNEF,BLT ,BLTU,BLTF,BGE ,BGEU,BGEF, // conditional</code>
</stmt>
<stmt file=root/lib/u.h line=18 start=0 end=0>
	<code>  CID ,CUD ,CDI ,CDU ,                                                   // conversion</code>
</stmt>
<stmt file=root/lib/u.h line=19 start=0 end=0>
	<code>  CLI ,STI ,RTI ,BIN ,BOUT,NOP ,SSP ,PSHA,PSHI,PSHF,PSHB,POPB,POPF,POPA, // misc</code>
</stmt>
<stmt file=root/lib/u.h line=20 start=0 end=0>
	<code>  IVEC,PDIR,SPAG,TIME,LVAD,TRAP,LUSP,SUSP,LCL ,LCA ,PSHC,POPC,MSIZ,</code>
</stmt>
<stmt file=root/lib/u.h line=21 start=0 end=0>
	<code>  PSHG,POPG,NET1,NET2,NET3,NET4,NET5,NET6,NET7,NET8,NET9,</code>
</stmt>
<stmt file=root/lib/u.h line=22 start=0 end=0>
	<code>  POW ,ATN2,FABS,ATAN,LOG ,LOGT,EXP ,FLOR,CEIL,HYPO,SIN ,COS ,TAN ,ASIN, // math</code>
</stmt>
<stmt file=root/lib/u.h line=23 start=0 end=0>
	<code>  ACOS,SINH,COSH,TANH,SQRT,FMOD,</code>
</stmt>
<stmt file=root/lib/u.h line=24 start=0 end=0>
	<code>  IDLE</code>
</stmt>
<stmt file=root/lib/u.h line=25 start=0 end=0>
	<code>};</code>
</stmt>
<stmt file=root/lib/u.h line=26 start=0 end=0>
	<code></code>
</stmt>
<stmt file=root/lib/u.h line=27 start=0 end=0>
	<code>// system calls</code>
</stmt>
<stmt file=root/lib/u.h line=28 start=0 end=0>
	<code>enum {</code>
</stmt>
<stmt file=root/lib/u.h line=29 start=0 end=0>
	<code>  S_fork=1, S_exit,   S_wait,   S_pipe,   S_write,  S_read,   S_close,  S_kill,</code>
</stmt>
<stmt file=root/lib/u.h line=30 start=0 end=0>
	<code>  S_exec,   S_open,   S_mknod,  S_unlink, S_fstat,  S_link,   S_mkdir,  S_chdir,</code>
</stmt>
<stmt file=root/lib/u.h line=31 start=0 end=0>
	<code>  S_dup2,   S_getpid, S_sbrk,   S_sleep,  S_uptime, S_lseek,  S_mount,  S_umount,</code>
</stmt>
<stmt file=root/lib/u.h line=32 start=0 end=0>
	<code>  S_socket, S_bind,   S_listen, S_poll,   S_accept, S_connect, </code>
</stmt>
<stmt file=root/lib/u.h line=33 start=0 end=0>
	<code>};</code>
</stmt>
<stmt file=root/lib/u.h line=34 start=0 end=0>
	<code></code>
</stmt>
<stmt file=root/lib/u.h line=35 start=0 end=0>
	<code>typedef unsigned char uchar;</code>
</stmt>
<stmt file=root/lib/u.h line=36 start=0 end=0>
	<code>typedef unsigned short ushort;</code>
</stmt>
<stmt file=root/lib/u.h line=37 start=0 end=0>
	<code>typedef unsigned int uint;</code>
</stmt>
<stmt file=os.c line=38 start=0 end=0>
	<code></code>
</stmt>
<stmt file=os.c line=3 start=0 end=0>
	<code></code>
</stmt>
<stmt file=os.c line=4 start=0 end=0>
	<code>enum {</code>
</stmt>
<stmt file=os.c line=5 start=0 end=0>
	<code>  PAGE    = 4096,       // page size</code>
</stmt>
<stmt file=os.c line=6 start=0 end=0>
	<code>  NPROC   = 64,         // maximum number of processes</code>
</stmt>
<stmt file=os.c line=7 start=0 end=0>
	<code>  NOFILE  = 16,         // open files per process</code>
</stmt>
<stmt file=os.c line=8 start=0 end=0>
	<code>  NFILE   = 100,        // open files per system</code>
</stmt>
<stmt file=os.c line=9 start=0 end=0>
	<code>  NBUF    = 10,         // size of disk block cache</code>
</stmt>
<stmt file=os.c line=10 start=0 end=0>
	<code>  NINODE  = 50,         // maximum number of active i-nodes  XXX make this more dynamic ... </code>
</stmt>
<stmt file=os.c line=11 start=0 end=0>
	<code>  NDEV    = 10,         // maximum major device number</code>
</stmt>
<stmt file=os.c line=12 start=0 end=0>
	<code>  USERTOP = 0xc0000000, // end of user address space</code>
</stmt>
<stmt file=os.c line=13 start=0 end=0>
	<code>  P2V     = +USERTOP,   // turn a physical address into a virtual address</code>
</stmt>
<stmt file=os.c line=14 start=0 end=0>
	<code>  V2P     = -USERTOP,   // turn a virtual address into a physical address</code>
</stmt>
<stmt file=os.c line=15 start=0 end=0>
	<code>  FSSIZE  = PAGE*1024,  // XXX</code>
</stmt>
<stmt file=os.c line=16 start=0 end=0>
	<code>  MAXARG  = 256,        // max exec arguments</code>
</stmt>
<stmt file=os.c line=17 start=0 end=0>
	<code>  STACKSZ = 0x800000,   // user stack size (8MB)</code>
</stmt>
<stmt file=os.c line=18 start=0 end=0>
	<code>};</code>
</stmt>
<stmt file=os.c line=19 start=0 end=0>
	<code></code>
</stmt>
<stmt file=os.c line=20 start=0 end=0>
	<code>enum { // page table entry flags   XXX refactor vs. i386</code>
</stmt>
<stmt file=os.c line=21 start=0 end=0>
	<code>  PTE_P = 0x001, // present</code>
</stmt>
<stmt file=os.c line=22 start=0 end=0>
	<code>  PTE_W = 0x002, // writeable</code>
</stmt>
<stmt file=os.c line=23 start=0 end=0>
	<code>  PTE_U = 0x004, // user</code>
</stmt>
<stmt file=os.c line=24 start=0 end=0>
	<code>  PTE_A = 0x020, // accessed</code>
</stmt>
<stmt file=os.c line=25 start=0 end=0>
	<code>  PTE_D = 0x040, // dirty</code>
</stmt>
<stmt file=os.c line=26 start=0 end=0>
	<code>};</code>
</stmt>
<stmt file=os.c line=27 start=0 end=0>
	<code></code>
</stmt>
<stmt file=os.c line=28 start=0 end=0>
	<code>enum { // processor fault codes</code>
</stmt>
<stmt file=os.c line=29 start=0 end=0>
	<code>  FMEM,   // bad physical address</code>
</stmt>
<stmt file=os.c line=30 start=0 end=0>
	<code>  FTIMER, // timer interrupt</code>
</stmt>
<stmt file=os.c line=31 start=0 end=0>
	<code>  FKEYBD, // keyboard interrupt</code>
</stmt>
<stmt file=os.c line=32 start=0 end=0>
	<code>  FPRIV,  // privileged instruction</code>
</stmt>
<stmt file=os.c line=33 start=0 end=0>
	<code>  FINST,  // illegal instruction</code>
</stmt>
<stmt file=os.c line=34 start=0 end=0>
	<code>  FSYS,   // software trap</code>
</stmt>
<stmt file=os.c line=35 start=0 end=0>
	<code>  FARITH, // arithmetic trap</code>
</stmt>
<stmt file=os.c line=36 start=0 end=0>
	<code>  FIPAGE, // page fault on opcode fetch</code>
</stmt>
<stmt file=os.c line=37 start=0 end=0>
	<code>  FWPAGE, // page fault on write</code>
</stmt>
<stmt file=os.c line=38 start=0 end=0>
	<code>  FRPAGE, // page fault on read</code>
</stmt>
<stmt file=os.c line=39 start=0 end=0>
	<code>  USER=16 // user mode exception</code>
</stmt>
<stmt file=os.c line=40 start=0 end=0>
	<code>};</code>
</stmt>
<stmt file=os.c line=41 start=0 end=0>
	<code></code>
</stmt>
<stmt file=os.c line=42 start=0 end=0>
	<code>struct trapframe { // layout of the trap frame built on the stack by trap handler</code>
</stmt>
<stmt file=os.c line=43 start=0 end=0>
	<code>  int sp, pad1;</code>
</stmt>
<stmt file=os.c line=44 start=0 end=0>
	<code>  double g, f;</code>
</stmt>
<stmt file=os.c line=45 start=0 end=0>
	<code>  int c,  pad2;</code>
</stmt>
<stmt file=os.c line=46 start=0 end=0>
	<code>  int b,  pad3;</code>
</stmt>
<stmt file=os.c line=47 start=0 end=0>
	<code>  int a,  pad4;</code>
</stmt>
<stmt file=os.c line=48 start=0 end=0>
	<code>  int fc, pad5;</code>
</stmt>
<stmt file=os.c line=49 start=0 end=0>
	<code>  int pc, pad6;</code>
</stmt>
<stmt file=os.c line=50 start=0 end=0>
	<code>};</code>
</stmt>
<stmt file=os.c line=51 start=0 end=0>
	<code></code>
</stmt>
<stmt file=os.c line=52 start=0 end=0>
	<code>struct buf {</code>
</stmt>
<stmt file=os.c line=53 start=0 end=0>
	<code>  int flags;</code>
</stmt>
<stmt file=os.c line=54 start=0 end=0>
	<code>  uint sector;</code>
</stmt>
<stmt file=os.c line=55 start=0 end=0>
	<code>  struct buf *prev;      // LRU cache list</code>
</stmt>
<stmt file=os.c line=56 start=0 end=0>
	<code>  struct buf *next;</code>
</stmt>
<stmt file=os.c line=57 start=0 end=0>
	<code>//  struct buf *qnext;     // disk queue XXX</code>
</stmt>
<stmt file=os.c line=58 start=0 end=0>
	<code>  uchar *data;</code>
</stmt>
<stmt file=os.c line=59 start=0 end=0>
	<code>};</code>
</stmt>
<stmt file=os.c line=60 start=0 end=0>
	<code>enum { B_BUSY  = 1,      // buffer is locked by some process</code>
</stmt>
<stmt file=os.c line=61 start=0 end=0>
	<code>       B_VALID = 2,      // buffer has been read from disk</code>
</stmt>
<stmt file=os.c line=62 start=0 end=0>
	<code>       B_DIRTY = 4};     // buffer needs to be written to disk</code>
</stmt>
<stmt file=os.c line=63 start=0 end=0>
	<code>enum { S_IFIFO = 0x1000, // fifo</code>
</stmt>
<stmt file=os.c line=64 start=0 end=0>
	<code>       S_IFCHR = 0x2000, // character</code>
</stmt>
<stmt file=os.c line=65 start=0 end=0>
	<code>       S_IFBLK = 0x3000, // block</code>
</stmt>
<stmt file=os.c line=66 start=0 end=0>
	<code>       S_IFDIR = 0x4000, // directory</code>
</stmt>
<stmt file=os.c line=67 start=0 end=0>
	<code>       S_IFREG = 0x8000, // regular</code>
</stmt>
<stmt file=os.c line=68 start=0 end=0>
	<code>       S_IFMT  = 0xF000 }; // file type mask</code>
</stmt>
<stmt file=os.c line=69 start=0 end=0>
	<code>enum { O_RDONLY, O_WRONLY, O_RDWR, O_CREAT = 0x100, O_TRUNC = 0x200 };</code>
</stmt>
<stmt file=os.c line=70 start=0 end=0>
	<code>enum { SEEK_SET, SEEK_CUR, SEEK_END };</code>
</stmt>
<stmt file=os.c line=71 start=0 end=0>
	<code></code>
</stmt>
<stmt file=os.c line=72 start=0 end=0>
	<code>struct stat {</code>
</stmt>
<stmt file=os.c line=73 start=0 end=0>
	<code>  ushort st_dev;         // device number</code>
</stmt>
<stmt file=os.c line=74 start=0 end=0>
	<code>  ushort st_mode;        // type of file</code>
</stmt>
<stmt file=os.c line=75 start=0 end=0>
	<code>  uint   st_ino;         // inode number on device</code>
</stmt>
<stmt file=os.c line=76 start=0 end=0>
	<code>  uint   st_nlink;       // number of links to file</code>
</stmt>
<stmt file=os.c line=77 start=0 end=0>
	<code>  uint   st_size;        // size of file in bytes</code>
</stmt>
<stmt file=os.c line=78 start=0 end=0>
	<code>};</code>
</stmt>
<stmt file=os.c line=79 start=0 end=0>
	<code></code>
</stmt>
<stmt file=os.c line=80 start=0 end=0>
	<code>// disk file system format</code>
</stmt>
<stmt file=os.c line=81 start=0 end=0>
	<code>enum {</code>
</stmt>
<stmt file=os.c line=82 start=0 end=0>
	<code>  ROOTINO  = 16,         // root i-number</code>
</stmt>
<stmt file=os.c line=83 start=0 end=0>
	<code>  NDIR     = 480,</code>
</stmt>
<stmt file=os.c line=84 start=0 end=0>
	<code>  NIDIR    = 512,</code>
</stmt>
<stmt file=os.c line=85 start=0 end=0>
	<code>  NIIDIR   = 8,</code>
</stmt>
<stmt file=os.c line=86 start=0 end=0>
	<code>  NIIIDIR  = 4,</code>
</stmt>
<stmt file=os.c line=87 start=0 end=0>
	<code>  DIRSIZ   = 252,</code>
</stmt>
<stmt file=os.c line=88 start=0 end=0>
	<code>  PIPESIZE = 4000,       // XXX up to a page (since pipe is a page)</code>
</stmt>
<stmt file=os.c line=89 start=0 end=0>
	<code>};</code>
</stmt>
<stmt file=os.c line=90 start=0 end=0>
	<code></code>
</stmt>
<stmt file=os.c line=91 start=0 end=0>
	<code>struct dinode { // on-disk inode structure</code>
</stmt>
<stmt file=os.c line=92 start=0 end=0>
	<code>  ushort mode;           // file mode</code>
</stmt>
<stmt file=os.c line=93 start=0 end=0>
	<code>  uint nlink;            // number of links to inode in file system</code>
</stmt>
<stmt file=os.c line=94 start=0 end=0>
	<code>  uint size;             // size of file</code>
</stmt>
<stmt file=os.c line=95 start=0 end=0>
	<code>  uint pad[17];</code>
</stmt>
<stmt file=os.c line=96 start=0 end=0>
	<code>  uint dir[NDIR];        // data block addresses</code>
</stmt>
<stmt file=os.c line=97 start=0 end=0>
	<code>  uint idir[NIDIR];</code>
</stmt>
<stmt file=os.c line=98 start=0 end=0>
	<code>  uint iidir[NIIDIR];    // XXX not implemented</code>
</stmt>
<stmt file=os.c line=99 start=0 end=0>
	<code>  uint iiidir[NIIIDIR];  // XXX not implemented</code>
</stmt>
<stmt file=os.c line=100 start=0 end=0>
	<code>};</code>
</stmt>
<stmt file=os.c line=101 start=0 end=0>
	<code></code>
</stmt>
<stmt file=os.c line=102 start=0 end=0>
	<code>struct direct { // directory is a file containing a sequence of direct structures.</code>
</stmt>
<stmt file=os.c line=103 start=0 end=0>
	<code>  uint d_ino;</code>
</stmt>
<stmt file=os.c line=104 start=0 end=0>
	<code>  char d_name[DIRSIZ];</code>
</stmt>
<stmt file=os.c line=105 start=0 end=0>
	<code>};</code>
</stmt>
<stmt file=os.c line=106 start=0 end=0>
	<code></code>
</stmt>
<stmt file=os.c line=107 start=0 end=0>
	<code>struct pipe {</code>
</stmt>
<stmt file=os.c line=108 start=0 end=0>
	<code>  char data[PIPESIZE];</code>
</stmt>
<stmt file=os.c line=109 start=0 end=0>
	<code>  uint nread;            // number of bytes read</code>
</stmt>
<stmt file=os.c line=110 start=0 end=0>
	<code>  uint nwrite;           // number of bytes written</code>
</stmt>
<stmt file=os.c line=111 start=0 end=0>
	<code>  int readopen;          // read fd is still open</code>
</stmt>
<stmt file=os.c line=112 start=0 end=0>
	<code>  int writeopen;         // write fd is still open</code>
</stmt>
<stmt file=os.c line=113 start=0 end=0>
	<code>};</code>
</stmt>
<stmt file=os.c line=114 start=0 end=0>
	<code></code>
</stmt>
<stmt file=os.c line=115 start=0 end=0>
	<code>struct inode { // in-memory copy of an inode</code>
</stmt>
<stmt file=os.c line=116 start=0 end=0>
	<code>  uint inum;             // inode number</code>
</stmt>
<stmt file=os.c line=117 start=0 end=0>
	<code>  int ref;               // reference count</code>
</stmt>
<stmt file=os.c line=118 start=0 end=0>
	<code>  int flags;             // I_BUSY, I_VALID</code>
</stmt>
<stmt file=os.c line=119 start=0 end=0>
	<code>  ushort mode;           // copy of disk inode</code>
</stmt>
<stmt file=os.c line=120 start=0 end=0>
	<code>  uint nlink;</code>
</stmt>
<stmt file=os.c line=121 start=0 end=0>
	<code>  uint size;</code>
</stmt>
<stmt file=os.c line=122 start=0 end=0>
	<code>  uint dir[NDIR];</code>
</stmt>
<stmt file=os.c line=123 start=0 end=0>
	<code>  uint idir[NIDIR];</code>
</stmt>
<stmt file=os.c line=124 start=0 end=0>
	<code>};</code>
</stmt>
<stmt file=os.c line=125 start=0 end=0>
	<code></code>
</stmt>
<stmt file=os.c line=126 start=0 end=0>
	<code>enum { FD_NONE, FD_PIPE, FD_INODE, FD_SOCKET, FD_RFS };</code>
</stmt>
<stmt file=os.c line=127 start=0 end=0>
	<code>struct file {</code>
</stmt>
<stmt file=os.c line=128 start=0 end=0>
	<code>  int type;</code>
</stmt>
<stmt file=os.c line=129 start=0 end=0>
	<code>  int ref;</code>
</stmt>
<stmt file=os.c line=130 start=0 end=0>
	<code>  char readable;</code>
</stmt>
<stmt file=os.c line=131 start=0 end=0>
	<code>  char writable;</code>
</stmt>
<stmt file=os.c line=132 start=0 end=0>
	<code>  struct pipe *pipe;     // XXX make vnode</code>
</stmt>
<stmt file=os.c line=133 start=0 end=0>
	<code>  struct inode *ip;</code>
</stmt>
<stmt file=os.c line=134 start=0 end=0>
	<code>  uint off;</code>
</stmt>
<stmt file=os.c line=135 start=0 end=0>
	<code>};</code>
</stmt>
<stmt file=os.c line=136 start=0 end=0>
	<code></code>
</stmt>
<stmt file=os.c line=137 start=0 end=0>
	<code>enum { I_BUSY = 1, I_VALID = 2 };</code>
</stmt>
<stmt file=os.c line=138 start=0 end=0>
	<code>enum { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };</code>
</stmt>
<stmt file=os.c line=139 start=0 end=0>
	<code></code>
</stmt>
<stmt file=os.c line=140 start=0 end=0>
	<code>struct proc { // per-process state</code>
</stmt>
<stmt file=os.c line=141 start=0 end=0>
	<code>  struct proc *next;</code>
</stmt>
<stmt file=os.c line=142 start=0 end=0>
	<code>  struct proc *prev;</code>
</stmt>
<stmt file=os.c line=143 start=0 end=0>
	<code>  uint sz;               // size of process memory (bytes)</code>
</stmt>
<stmt file=os.c line=144 start=0 end=0>
	<code>  uint *pdir;            // page directory</code>
</stmt>
<stmt file=os.c line=145 start=0 end=0>
	<code>  char *kstack;          // bottom of kernel stack for this process</code>
</stmt>
<stmt file=os.c line=146 start=0 end=0>
	<code>  int state;             // process state</code>
</stmt>
<stmt file=os.c line=147 start=0 end=0>
	<code>  int pid;               // process ID</code>
</stmt>
<stmt file=os.c line=148 start=0 end=0>
	<code>  struct proc *parent;   // parent process</code>
</stmt>
<stmt file=os.c line=149 start=0 end=0>
	<code>  struct trapframe *tf;  // trap frame for current syscall</code>
</stmt>
<stmt file=os.c line=150 start=0 end=0>
	<code>  int context;           // swtch() here to run process</code>
</stmt>
<stmt file=os.c line=151 start=0 end=0>
	<code>  void *chan;            // if non-zero, sleeping on chan</code>
</stmt>
<stmt file=os.c line=152 start=0 end=0>
	<code>  int killed;            // if non-zero, have been killed</code>
</stmt>
<stmt file=os.c line=153 start=0 end=0>
	<code>  struct file *ofile[NOFILE]; // open files</code>
</stmt>
<stmt file=os.c line=154 start=0 end=0>
	<code>  struct inode *cwd;     // current directory</code>
</stmt>
<stmt file=os.c line=155 start=0 end=0>
	<code>  char name[16];         // process name (debugging)</code>
</stmt>
<stmt file=os.c line=156 start=0 end=0>
	<code>};</code>
</stmt>
<stmt file=os.c line=157 start=0 end=0>
	<code></code>
</stmt>
<stmt file=os.c line=158 start=0 end=0>
	<code>struct devsw { // device implementations XXX redesign</code>
</stmt>
<stmt file=os.c line=159 start=0 end=0>
	<code>  int (*read)();</code>
</stmt>
<stmt file=os.c line=160 start=0 end=0>
	<code>  int (*write)();</code>
</stmt>
<stmt file=os.c line=161 start=0 end=0>
	<code>};</code>
</stmt>
<stmt file=os.c line=162 start=0 end=0>
	<code></code>
</stmt>
<stmt file=os.c line=163 start=0 end=0>
	<code>enum { CONSOLE = 1 }; // XXX ditch..</code>
</stmt>
<stmt file=os.c line=164 start=0 end=0>
	<code></code>
</stmt>
<stmt file=os.c line=165 start=0 end=0>
	<code>enum { INPUT_BUF = 128 };</code>
</stmt>
<stmt file=os.c line=166 start=0 end=0>
	<code>struct input_s {</code>
</stmt>
<stmt file=os.c line=167 start=0 end=0>
	<code>  char buf[INPUT_BUF];</code>
</stmt>
<stmt file=os.c line=168 start=0 end=0>
	<code>  uint r;  // read index</code>
</stmt>
<stmt file=os.c line=169 start=0 end=0>
	<code>  uint w;  // write index</code>
</stmt>
<stmt file=os.c line=170 start=0 end=0>
	<code>};</code>
</stmt>
<stmt file=os.c line=171 start=0 end=0>
	<code></code>
</stmt>
<stmt file=os.c line=172 start=0 end=0>
	<code>enum { PF_INET = 2, AF_INET = 2, SOCK_STREAM = 1, INADDR_ANY = 0 }; // XXX keep or chuck these?</code>
</stmt>
<stmt file=os.c line=173 start=0 end=0>
	<code></code>
</stmt>
<stmt file=os.c line=174 start=0 end=0>
	<code>// *** Globals ***</code>
</stmt>
<stmt file=os.c line=175 start=0 end=0>
	<code></code>
</stmt>
<stmt file=os.c line=176 start=0 end=0>
	<code>struct proc proc[NPROC];</code>
</stmt>
<stmt file=os.c line=177 start=0 end=0>
	<code>struct proc *u;          // current process</code>
</stmt>
<stmt file=os.c line=178 start=0 end=0>
	<code>struct proc *init;</code>
</stmt>
<stmt file=os.c line=179 start=0 end=0>
	<code>char *mem_free;          // memory free list</code>
</stmt>
<stmt file=os.c line=180 start=0 end=0>
	<code>char *mem_top;           // current top of unused memory</code>
</stmt>
<stmt file=os.c line=181 start=0 end=0>
	<code>uint mem_sz;             // size of physical memory</code>
</stmt>
<stmt file=os.c line=182 start=0 end=0>
	<code>uint kreserved;          // start of kernel reserved memory heap</code>
</stmt>
<stmt file=os.c line=183 start=0 end=0>
	<code>struct devsw devsw[NDEV];</code>
</stmt>
<stmt file=os.c line=184 start=0 end=0>
	<code>uint *kpdir;             // kernel page directory</code>
</stmt>
<stmt file=os.c line=185 start=0 end=0>
	<code>uint ticks;</code>
</stmt>
<stmt file=os.c line=186 start=0 end=0>
	<code>char *memdisk;</code>
</stmt>
<stmt file=os.c line=187 start=0 end=0>
	<code>struct input_s input;    // XXX do this some other way?</code>
</stmt>
<stmt file=os.c line=188 start=0 end=0>
	<code>struct buf bcache[NBUF];</code>
</stmt>
<stmt file=os.c line=189 start=0 end=0>
	<code>struct buf bfreelist;    // linked list of all buffers, through prev/next.   bfreelist.next is most recently used</code>
</stmt>
<stmt file=os.c line=190 start=0 end=0>
	<code>struct inode inode[NINODE]; // inode cache XXX make dynamic and eventually power of 2, look into iget()</code>
</stmt>
<stmt file=os.c line=191 start=0 end=0>
	<code>struct file file[NFILE];</code>
</stmt>
<stmt file=os.c line=192 start=0 end=0>
	<code>int nextpid;</code>
</stmt>
<stmt file=os.c line=193 start=0 end=0>
	<code></code>
</stmt>
<stmt file=os.c line=194 start=0 end=0>
	<code>rfsd = -1; // XXX will be set on mount, XXX total redesign?</code>
</stmt>
<stmt file=os.c line=195 start=0 end=0>
	<code></code>
</stmt>
<stmt file=os.c line=196 start=0 end=0>
	<code>// *** Code ***</code>
</stmt>
<stmt file=os.c line=197 start=0 end=0>
	<code></code>
</stmt>
<stmt file=os.c line=198 start=0 end=5>
	<code>void *memcpy(void *d, void *s, uint n) { asm(LL,8); asm(LBL, 16); asm(LCL,24); asm(MCPY); asm(LL,8); }</code>
	<emi>
		00000000  0000080e  LL    0x8 (D 8)
		00000004  00001026  LBL   0x10 (D 16)
		00000008  000018ac  LCL   0x18 (D 24)
		0000000c  0000000a  MCPY
		00000010  0000080e  LL    0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=199 start=5 end=11>
	<code>void *memset(void *d, uint c,  uint n) { asm(LL,8); asm(LBLB,16); asm(LCL,24); asm(MSET); asm(LL,8); }</code>
	<emi>
		00000014  00000002  LEV   0x0 (D 0)
		00000018  0000080e  LL    0x8 (D 8)
		0000001c  0000102a  LBLB  0x10 (D 16)
		00000020  000018ac  LCL   0x18 (D 24)
		00000024  0000000d  MSET
		00000028  0000080e  LL    0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=200 start=11 end=16>
	<code>void *memchr(void *s, uint c,  uint n) { asm(LL,8); asm(LBLB,16); asm(LCL,24); asm(MCHR); }</code>
	<emi>
		0000002c  00000002  LEV   0x0 (D 0)
		00000030  0000080e  LL    0x8 (D 8)
		00000034  0000102a  LBLB  0x10 (D 16)
		00000038  000018ac  LCL   0x18 (D 24)
		0000003c  0000000c  MCHR
	</emi>
</stmt>
<stmt file=os.c line=201 start=16 end=16>
	<code></code>
</stmt>
<stmt file=os.c line=202 start=16 end=19>
	<code>int in(port)    { asm(LL,8); asm(BIN); }</code>
	<emi>
		00000040  00000002  LEV   0x0 (D 0)
		00000044  0000080e  LL    0x8 (D 8)
		00000048  00000099  BIN 
	</emi>
</stmt>
<stmt file=os.c line=203 start=19 end=23>
	<code>out(port, val)  { asm(LL,8); asm(LBL,16); asm(BOUT); }</code>
	<emi>
		0000004c  00000002  LEV   0x0 (D 0)
		00000050  0000080e  LL    0x8 (D 8)
		00000054  00001026  LBL   0x10 (D 16)
		00000058  0000009a  BOUT
	</emi>
</stmt>
<stmt file=os.c line=204 start=23 end=26>
	<code>ivec(void *isr) { asm(LL,8); asm(IVEC); }</code>
	<emi>
		0000005c  00000002  LEV   0x0 (D 0)
		00000060  0000080e  LL    0x8 (D 8)
		00000064  000000a4  IVEC
	</emi>
</stmt>
<stmt file=os.c line=205 start=26 end=28>
	<code>lvadr()         { asm(LVAD); }</code>
	<emi>
		00000068  00000002  LEV   0x0 (D 0)
		0000006c  000000a8  LVAD
	</emi>
</stmt>
<stmt file=os.c line=206 start=28 end=30>
	<code>uint msiz()     { asm(MSIZ); }</code>
	<emi>
		00000070  00000002  LEV   0x0 (D 0)
		00000074  000000b0  MSIZ
	</emi>
</stmt>
<stmt file=os.c line=207 start=30 end=33>
	<code>stmr(val)       { asm(LL,8); asm(TIME); }</code>
	<emi>
		00000078  00000002  LEV   0x0 (D 0)
		0000007c  0000080e  LL    0x8 (D 8)
		00000080  000000a7  TIME
	</emi>
</stmt>
<stmt file=os.c line=208 start=33 end=36>
	<code>pdir(val)       { asm(LL,8); asm(PDIR); }</code>
	<emi>
		00000084  00000002  LEV   0x0 (D 0)
		00000088  0000080e  LL    0x8 (D 8)
		0000008c  000000a5  PDIR
	</emi>
</stmt>
<stmt file=os.c line=209 start=36 end=39>
	<code>spage(val)      { asm(LL,8); asm(SPAG); }</code>
	<emi>
		00000090  00000002  LEV   0x0 (D 0)
		00000094  0000080e  LL    0x8 (D 8)
		00000098  000000a6  SPAG
	</emi>
</stmt>
<stmt file=os.c line=210 start=39 end=41>
	<code>splhi()         { asm(CLI); }</code>
	<emi>
		0000009c  00000002  LEV   0x0 (D 0)
		000000a0  00000096  CLI 
	</emi>
</stmt>
<stmt file=os.c line=211 start=41 end=45>
	<code>splx(int e)     { if (e) asm(STI); }</code>
	<emi>
		000000a4  00000002  LEV   0x0 (D 0)
		000000a8  0000080e  LL    0x8 (D 8)
		000000ac  00000084  BZ    <fwd>
		000000b0  00000097  STI 
	</emi>
</stmt>
<stmt file=os.c line=212 start=45 end=45>
	<code></code>
</stmt>
<stmt file=os.c line=213 start=45 end=55>
	<code>int strlen(void *s) { return memchr(s, 0, -1) - s; }</code>
	<emi>
		000000b4  00000002  LEV   0x0 (D 0)
		000000b8  ffffff9e  PSHI  0xffffffff (D -1)
		000000bc  0000009e  PSHI  0x0 (D 0)
		000000c0  0000180e  LL    0x18 (D 24)
		000000c4  0000009d  PSHA
		000000c8  ffff6405  JSR   0xffffff64 (TO 0x30)
		000000cc  00001801  ENT   0x18 (D 24)
		000000d0  00000858  SUBL  0x8 (D 8)
		000000d4  0000015d  DIVI  0x1 (D 1)
		000000d8  00000002  LEV   0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=214 start=55 end=55>
	<code></code>
</stmt>
<stmt file=os.c line=215 start=55 end=56>
	<code>xstrncpy(char *s, char *t, int n) // no return value unlike strncpy XXX remove me only called once</code>
	<emi>
		000000dc  00000002  LEV   0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=216 start=56 end=56>
	<code>{</code>
</stmt>
<stmt file=os.c line=217 start=56 end=57>
	<code>  while (n-- > 0 && (*s++ = *t++));</code>
	<emi>
		000000e0  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=218 start=57 end=86>
	<code>  while (n-- > 0) *s++ = 0;</code>
	<emi>
		000000e4  0000180e  LL    0x18 (D 24)
		000000e8  00000157  SUBI  0x1 (D 1)
		000000ec  00001840  SL    0x18 (D 24)
		000000f0  00000154  ADDI  0x1 (D 1)
		000000f4  0000003e  LBA 
		000000f8  00000023  LI    0x0 (D 0)
		000000fc  0000008f  BGE   <fwd>
		00000100  0000080e  LL    0x8 (D 8)
		00000104  ffffff57  SUBI  0xffffffff (D -1)
		00000108  00000840  SL    0x8 (D 8)
		0000010c  ffffff54  ADDI  0xffffffff (D -1)
		00000110  0000009d  PSHA
		00000114  0000180e  LL    0x18 (D 24)
		00000118  ffffff57  SUBI  0xffffffff (D -1)
		0000011c  00001840  SL    0x18 (D 24)
		00000120  ffffff1f  LXC   0xffffffff (D -1)
		00000124  000000a1  POPB
		00000128  0000004c  SXB 
		0000012c  00001872  SHLI  0x18 (D 24)
		00000130  00001875  SHRI  0x18 (D 24)
		00000134  00000086  BNZ   <fwd>
		00000138  00000003  JMP   <fwd>
		0000013c  0000080e  LL    0x8 (D 8)
		00000140  ffffff57  SUBI  0xffffffff (D -1)
		00000144  00000840  SL    0x8 (D 8)
		00000148  ffffff54  ADDI  0xffffffff (D -1)
		0000014c  0000003e  LBA 
		00000150  00000023  LI    0x0 (D 0)
		00000154  0000004c  SXB 
	</emi>
</stmt>
<stmt file=os.c line=219 start=86 end=93>
	<code>}</code>
	<emi>
		00000158  0000180e  LL    0x18 (D 24)
		0000015c  00000157  SUBI  0x1 (D 1)
		00000160  00001840  SL    0x18 (D 24)
		00000164  00000154  ADDI  0x1 (D 1)
		00000168  0000003e  LBA 
		0000016c  00000023  LI    0x0 (D 0)
		00000170  0000008c  BLT   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=220 start=93 end=93>
	<code></code>
</stmt>
<stmt file=os.c line=221 start=93 end=94>
	<code>safestrcpy(char *s, char *t, int n) // like strncpy but guaranteed to null-terminate.</code>
	<emi>
		00000174  00000002  LEV   0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=222 start=94 end=94>
	<code>{</code>
</stmt>
<stmt file=os.c line=223 start=94 end=98>
	<code>  if (n <= 0) return;</code>
	<emi>
		00000178  00000023  LI    0x0 (D 0)
		0000017c  00001826  LBL   0x18 (D 24)
		00000180  0000008c  BLT   <fwd>
		00000184  00000002  LEV   0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=224 start=98 end=99>
	<code>  while (--n > 0 && (*s++ = *t++));</code>
	<emi>
		00000188  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=225 start=99 end=122>
	<code>  *s = 0;</code>
	<emi>
		0000018c  0000180e  LL    0x18 (D 24)
		00000190  00000157  SUBI  0x1 (D 1)
		00000194  00001840  SL    0x18 (D 24)
		00000198  0000003e  LBA 
		0000019c  00000023  LI    0x0 (D 0)
		000001a0  0000008f  BGE   <fwd>
		000001a4  0000080e  LL    0x8 (D 8)
		000001a8  ffffff57  SUBI  0xffffffff (D -1)
		000001ac  00000840  SL    0x8 (D 8)
		000001b0  ffffff54  ADDI  0xffffffff (D -1)
		000001b4  0000009d  PSHA
		000001b8  0000180e  LL    0x18 (D 24)
		000001bc  ffffff57  SUBI  0xffffffff (D -1)
		000001c0  00001840  SL    0x18 (D 24)
		000001c4  ffffff1f  LXC   0xffffffff (D -1)
		000001c8  000000a1  POPB
		000001cc  0000004c  SXB 
		000001d0  00001872  SHLI  0x18 (D 24)
		000001d4  00001875  SHRI  0x18 (D 24)
		000001d8  00000086  BNZ   <fwd>
		000001dc  00000023  LI    0x0 (D 0)
		000001e0  00000826  LBL   0x8 (D 8)
		000001e4  0000004c  SXB 
	</emi>
</stmt>
<stmt file=os.c line=226 start=122 end=122>
	<code>}</code>
</stmt>
<stmt file=os.c line=227 start=122 end=122>
	<code></code>
</stmt>
<stmt file=os.c line=228 start=122 end=122>
	<code>// page allocator</code>
</stmt>
<stmt file=os.c line=229 start=122 end=123>
	<code>char *kalloc()</code>
	<emi>
		000001e8  00000002  LEV   0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=230 start=123 end=123>
	<code>{</code>
</stmt>
<stmt file=os.c line=231 start=123 end=123>
	<code>  char *r; int e = splhi();</code>
</stmt>
<stmt file=os.c line=232 start=123 end=132>
	<code>  if (r = mem_free) mem_free = *(char **)r;</code>
	<emi>
		000001ec  fffff801  ENT   0xfffffff8 (D -8)
		000001f0  fffeac05  JSR   0xfffffeac (TO 0xa0)
		000001f4  00000040  SL    0x0 (D 0)
		000001f8  00210815  LG    0x2108 (D 8456)
		000001fc  00000440  SL    0x4 (D 4)
		00000200  00000084  BZ    <fwd>
		00000204  0000040e  LL    0x4 (D 4)
		00000208  0000001c  LX  
		0000020c  00210845  SG    0x2108 (D 8456)
	</emi>
</stmt>
<stmt file=os.c line=233 start=132 end=146>
	<code>  else if ((uint)(r = mem_top) < P2V+(mem_sz - FSSIZE)) mem_top += PAGE; //XXX uint issue is going to be a problem with other pointer compares!</code>
	<emi>
		00000210  00000003  JMP   <fwd>
		00000214  00211015  LG    0x2110 (D 8464)
		00000218  c0000054  ADDI  0xffc00000 (D -4194304)
		0000021c  ffffc03b  LBI   0xffffffc0 (D -64)
		00000220  0000003c  LBHI  0x0 (D 0)
		00000224  00000053  ADD 
		00000228  0000009d  PSHA
		0000022c  00210c15  LG    0x210c (D 8460)
		00000230  00000c40  SL    0xc (D 12)
		00000234  000000a1  POPB
		00000238  00000090  BGEU  <fwd>
		0000023c  00210c15  LG    0x210c (D 8460)
		00000240  00100054  ADDI  0x1000 (D 4096)
		00000244  00210c45  SG    0x210c (D 8460)
	</emi>
</stmt>
<stmt file=os.c line=234 start=146 end=151>
	<code>  else panic("kalloc failure!");  //XXX need to sleep here!</code>
	<emi>
		00000248  00000003  JMP   <fwd>
		0000024c  00000408  LEAG  0x4 (D 4)
		00000250  0000009d  PSHA
		00000254  00000005  JSR   <fwd>
		00000258  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=235 start=151 end=155>
	<code>  splx(e);</code>
	<emi>
		0000025c  0000000e  LL    0x0 (D 0)
		00000260  0000009d  PSHA
		00000264  fffe4005  JSR   0xfffffe40 (TO 0xa8)
		00000268  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=236 start=155 end=157>
	<code>  return r;</code>
	<emi>
		0000026c  0000040e  LL    0x4 (D 4)
		00000270  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=237 start=157 end=157>
	<code>}</code>
</stmt>
<stmt file=os.c line=238 start=157 end=157>
	<code></code>
</stmt>
<stmt file=os.c line=239 start=157 end=158>
	<code>kfree(char *v)</code>
	<emi>
		00000274  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=240 start=158 end=158>
	<code>{</code>
</stmt>
<stmt file=os.c line=241 start=158 end=158>
	<code>  int e = splhi();</code>
</stmt>
<stmt file=os.c line=242 start=158 end=183>
	<code>  if ((uint)v % PAGE || v < (char *)(P2V+kreserved) || (uint)v >= P2V+(mem_sz - FSSIZE)) panic("kfree");</code>
	<emi>
		00000278  fffff801  ENT   0xfffffff8 (D -8)
		0000027c  fffe2005  JSR   0xfffffe20 (TO 0xa0)
		00000280  00000440  SL    0x4 (D 4)
		00000284  0000100e  LL    0x10 (D 16)
		00000288  00100066  MDUI  0x1000 (D 4096)
		0000028c  00000086  BNZ   <fwd>
		00000290  00211415  LG    0x2114 (D 8468)
		00000294  ffffc03b  LBI   0xffffffc0 (D -64)
		00000298  0000003c  LBHI  0x0 (D 0)
		0000029c  00000053  ADD 
		000002a0  0000003e  LBA 
		000002a4  0000100e  LL    0x10 (D 16)
		000002a8  00028c8d  BLTU  <fwd>
		000002ac  00211015  LG    0x2110 (D 8464)
		000002b0  c0000054  ADDI  0xffc00000 (D -4194304)
		000002b4  ffffc03b  LBI   0xffffffc0 (D -64)
		000002b8  0000003c  LBHI  0x0 (D 0)
		000002bc  00000053  ADD 
		000002c0  0000003e  LBA 
		000002c4  0000100e  LL    0x10 (D 16)
		000002c8  0000008d  BLTU  <fwd>
		000002cc  00001408  LEAG  0x14 (D 20)
		000002d0  0000009d  PSHA
		000002d4  00025405  JSR   <fwd>
		000002d8  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=243 start=183 end=186>
	<code>  *(char **)v = mem_free;</code>
	<emi>
		000002dc  00210815  LG    0x2108 (D 8456)
		000002e0  00001026  LBL   0x10 (D 16)
		000002e4  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=244 start=186 end=188>
	<code>  mem_free = v;</code>
	<emi>
		000002e8  0000100e  LL    0x10 (D 16)
		000002ec  00210845  SG    0x2108 (D 8456)
	</emi>
</stmt>
<stmt file=os.c line=245 start=188 end=192>
	<code>  splx(e);</code>
	<emi>
		000002f0  0000040e  LL    0x4 (D 4)
		000002f4  0000009d  PSHA
		000002f8  fffdac05  JSR   0xfffffdac (TO 0xa8)
		000002fc  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=246 start=192 end=192>
	<code>}</code>
</stmt>
<stmt file=os.c line=247 start=192 end=192>
	<code></code>
</stmt>
<stmt file=os.c line=248 start=192 end=192>
	<code>// console device</code>
</stmt>
<stmt file=os.c line=249 start=192 end=193>
	<code>cout(char c)</code>
	<emi>
		00000300  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=250 start=193 end=193>
	<code>{</code>
</stmt>
<stmt file=os.c line=251 start=193 end=198>
	<code>  out(1, c);</code>
	<emi>
		00000304  00000811  LLC   0x8 (D 8)
		00000308  0000009d  PSHA
		0000030c  0000019e  PSHI  0x1 (D 1)
		00000310  fffd3c05  JSR   0xfffffd3c (TO 0x50)
		00000314  00001001  ENT   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=252 start=198 end=198>
	<code>}</code>
</stmt>
<stmt file=os.c line=253 start=198 end=199>
	<code>printn(int n)</code>
	<emi>
		00000318  00000002  LEV   0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=254 start=199 end=199>
	<code>{</code>
</stmt>
<stmt file=os.c line=255 start=199 end=210>
	<code>  if (n > 9) { printn(n / 10); n %= 10; }</code>
	<emi>
		0000031c  00000923  LI    0x9 (D 9)
		00000320  00000826  LBL   0x8 (D 8)
		00000324  0000008f  BGE   <fwd>
		00000328  0000080e  LL    0x8 (D 8)
		0000032c  00000a5d  DIVI  0xa (D 10)
		00000330  0000009d  PSHA
		00000334  ffffe405  JSR   0xffffffe4 (TO 0x31c)
		00000338  00000801  ENT   0x8 (D 8)
		0000033c  0000080e  LL    0x8 (D 8)
		00000340  00000a63  MODI  0xa (D 10)
		00000344  00000840  SL    0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=256 start=210 end=215>
	<code>  cout(n + '0');</code>
	<emi>
		00000348  0000080e  LL    0x8 (D 8)
		0000034c  00003054  ADDI  0x30 (D 48)
		00000350  0000009d  PSHA
		00000354  ffffac05  JSR   0xffffffac (TO 0x304)
		00000358  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=257 start=215 end=215>
	<code>}</code>
</stmt>
<stmt file=os.c line=258 start=215 end=216>
	<code>printx(uint n)</code>
	<emi>
		0000035c  00000002  LEV   0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=259 start=216 end=216>
	<code>{</code>
</stmt>
<stmt file=os.c line=260 start=216 end=227>
	<code>  if (n > 15) { printx(n >> 4); n &= 15; }</code>
	<emi>
		00000360  00000f23  LI    0xf (D 15)
		00000364  00000826  LBL   0x8 (D 8)
		00000368  00000090  BGEU  <fwd>
		0000036c  0000080e  LL    0x8 (D 8)
		00000370  00000478  SRUI  0x4 (D 4)
		00000374  0000009d  PSHA
		00000378  ffffe405  JSR   0xffffffe4 (TO 0x360)
		0000037c  00000801  ENT   0x8 (D 8)
		00000380  0000080e  LL    0x8 (D 8)
		00000384  00000f69  ANDI  0xf (D 15)
		00000388  00000840  SL    0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=261 start=227 end=237>
	<code>  cout(n + (n > 9 ? 'a' - 10 : '0'));</code>
	<emi>
		0000038c  00000923  LI    0x9 (D 9)
		00000390  00000826  LBL   0x8 (D 8)
		00000394  00000090  BGEU  <fwd>
		00000398  00005723  LI    0x57 (D 87)
		0000039c  00000003  JMP   <fwd>
		000003a0  00003023  LI    0x30 (D 48)
		000003a4  00000855  ADDL  0x8 (D 8)
		000003a8  0000009d  PSHA
		000003ac  ffff5405  JSR   0xffffff54 (TO 0x304)
		000003b0  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=262 start=237 end=237>
	<code>}</code>
</stmt>
<stmt file=os.c line=263 start=237 end=238>
	<code>printf(char *f, ...) // XXX simplify or chuck</code>
	<emi>
		000003b4  00000002  LEV   0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=264 start=238 end=238>
	<code>{</code>
</stmt>
<stmt file=os.c line=265 start=238 end=238>
	<code>  int n, e = splhi(); char *s; va_list v;</code>
</stmt>
<stmt file=os.c line=266 start=238 end=243>
	<code>  va_start(v, f);</code>
	<emi>
		000003b8  fffff001  ENT   0xfffffff0 (D -16)
		000003bc  fffce005  JSR   0xfffffce0 (TO 0xa0)
		000003c0  00000840  SL    0x8 (D 8)
		000003c4  00001807  LEA   0x18 (D 24)
		000003c8  00000040  SL    0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=267 start=243 end=244>
	<code>  while (*f) {</code>
	<emi>
		000003cc  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=268 start=244 end=256>
	<code>    if (*f != '%') { cout(*f++); continue; }</code>
	<emi>
		000003d0  0000180e  LL    0x18 (D 24)
		000003d4  0000001f  LXC 
		000003d8  0000253b  LBI   0x25 (D 37)
		000003dc  00000088  BE    <fwd>
		000003e0  0000180e  LL    0x18 (D 24)
		000003e4  ffffff57  SUBI  0xffffffff (D -1)
		000003e8  00001840  SL    0x18 (D 24)
		000003ec  ffffff1f  LXC   0xffffffff (D -1)
		000003f0  0000009d  PSHA
		000003f4  ffff0c05  JSR   0xffffff0c (TO 0x304)
		000003f8  00000801  ENT   0x8 (D 8)
		000003fc  0003cc03  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=269 start=256 end=261>
	<code>    switch (*++f) {</code>
	<emi>
		00000400  0000180e  LL    0x18 (D 24)
		00000404  00000154  ADDI  0x1 (D 1)
		00000408  00001840  SL    0x18 (D 24)
		0000040c  0000001f  LXC 
		00000410  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=270 start=261 end=285>
	<code>    case 'd': f++; if ((n = va_arg(v,int)) < 0) { cout('-'); printn(-n); } else printn(n); continue;</code>
	<emi>
		00000414  0000180e  LL    0x18 (D 24)
		00000418  ffffff57  SUBI  0xffffffff (D -1)
		0000041c  00001840  SL    0x18 (D 24)
		00000420  0000000e  LL    0x0 (D 0)
		00000424  00000854  ADDI  0x8 (D 8)
		00000428  00000040  SL    0x0 (D 0)
		0000042c  0000001c  LX  
		00000430  00000c40  SL    0xc (D 12)
		00000434  0000003b  LBI   0x0 (D 0)
		00000438  0000008f  BGE   <fwd>
		0000043c  00002d9e  PSHI  0x2d (D 45)
		00000440  fffec005  JSR   0xfffffec0 (TO 0x304)
		00000444  00000801  ENT   0x8 (D 8)
		00000448  00000c0e  LL    0xc (D 12)
		0000044c  ffffff5a  MULI  0xffffffff (D -1)
		00000450  0000009d  PSHA
		00000454  fffec405  JSR   0xfffffec4 (TO 0x31c)
		00000458  00000801  ENT   0x8 (D 8)
		0000045c  00000003  JMP   <fwd>
		00000460  00000c0e  LL    0xc (D 12)
		00000464  0000009d  PSHA
		00000468  fffeb005  JSR   0xfffffeb0 (TO 0x31c)
		0000046c  00000801  ENT   0x8 (D 8)
		00000470  0003fc03  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=271 start=285 end=296>
	<code>    case 'x': f++; printx(va_arg(v,int)); continue;</code>
	<emi>
		00000474  0000180e  LL    0x18 (D 24)
		00000478  ffffff57  SUBI  0xffffffff (D -1)
		0000047c  00001840  SL    0x18 (D 24)
		00000480  0000000e  LL    0x0 (D 0)
		00000484  00000854  ADDI  0x8 (D 8)
		00000488  00000040  SL    0x0 (D 0)
		0000048c  0000001c  LX  
		00000490  0000009d  PSHA
		00000494  fffec805  JSR   0xfffffec8 (TO 0x360)
		00000498  00000801  ENT   0x8 (D 8)
		0000049c  00047003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=272 start=296 end=317>
	<code>    case 's': f++; for (s = va_arg(v, char *); *s; s++) cout(*s); continue;</code>
	<emi>
		000004a0  0000180e  LL    0x18 (D 24)
		000004a4  ffffff57  SUBI  0xffffffff (D -1)
		000004a8  00001840  SL    0x18 (D 24)
		000004ac  0000000e  LL    0x0 (D 0)
		000004b0  00000854  ADDI  0x8 (D 8)
		000004b4  00000040  SL    0x0 (D 0)
		000004b8  0000001c  LX  
		000004bc  00000440  SL    0x4 (D 4)
		000004c0  00000003  JMP   <fwd>
		000004c4  0000040e  LL    0x4 (D 4)
		000004c8  0000001f  LXC 
		000004cc  0000009d  PSHA
		000004d0  fffe3005  JSR   0xfffffe30 (TO 0x304)
		000004d4  00000801  ENT   0x8 (D 8)
		000004d8  0000040e  LL    0x4 (D 4)
		000004dc  ffffff57  SUBI  0xffffffff (D -1)
		000004e0  00000440  SL    0x4 (D 4)
		000004e4  0000040e  LL    0x4 (D 4)
		000004e8  0000001f  LXC 
		000004ec  00000086  BNZ   <fwd>
		000004f0  00049c03  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=273 start=317 end=317>
	<code>    }</code>
</stmt>
<stmt file=os.c line=274 start=317 end=325>
	<code>    cout('%');</code>
	<emi>
		000004f4  00000003  JMP   <fwd>
		000004f8  00006457  SUBI  0x64 (D 100)
		000004fc  0000153b  LBI   0x15 (D 21)
		00000500  0004f490  BGEU  <fwd>
		00000504  00001c04  JMPI  0x1c (D 28)
		00000508  0000259e  PSHI  0x25 (D 37)
		0000050c  fffdf405  JSR   0xfffffdf4 (TO 0x304)
		00000510  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=275 start=325 end=325>
	<code>  }</code>
</stmt>
<stmt file=os.c line=276 start=325 end=332>
	<code>  splx(e);</code>
	<emi>
		00000514  0000180e  LL    0x18 (D 24)
		00000518  0000001f  LXC 
		0000051c  00000086  BNZ   <fwd>
		00000520  0000080e  LL    0x8 (D 8)
		00000524  0000009d  PSHA
		00000528  fffb7c05  JSR   0xfffffb7c (TO 0xa8)
		0000052c  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=277 start=332 end=332>
	<code>}</code>
</stmt>
<stmt file=os.c line=278 start=332 end=332>
	<code></code>
</stmt>
<stmt file=os.c line=279 start=332 end=333>
	<code>panic(char *s)</code>
	<emi>
		00000530  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=280 start=333 end=333>
	<code>{</code>
</stmt>
<stmt file=os.c line=281 start=333 end=334>
	<code>  asm(CLI);</code>
	<emi>
		00000534  00000096  CLI 
	</emi>
</stmt>
<stmt file=os.c line=282 start=334 end=362>
	<code>  out(1,'p'); out(1,'a'); out(1,'n'); out(1,'i'); out(1,'c'); out(1,':'); out(1,' '); </code>
	<emi>
		00000538  0000709e  PSHI  0x70 (D 112)
		0000053c  0000019e  PSHI  0x1 (D 1)
		00000540  fffb0c05  JSR   0xfffffb0c (TO 0x50)
		00000544  00001001  ENT   0x10 (D 16)
		00000548  0000619e  PSHI  0x61 (D 97)
		0000054c  0000019e  PSHI  0x1 (D 1)
		00000550  fffafc05  JSR   0xfffffafc (TO 0x50)
		00000554  00001001  ENT   0x10 (D 16)
		00000558  00006e9e  PSHI  0x6e (D 110)
		0000055c  0000019e  PSHI  0x1 (D 1)
		00000560  fffaec05  JSR   0xfffffaec (TO 0x50)
		00000564  00001001  ENT   0x10 (D 16)
		00000568  0000699e  PSHI  0x69 (D 105)
		0000056c  0000019e  PSHI  0x1 (D 1)
		00000570  fffadc05  JSR   0xfffffadc (TO 0x50)
		00000574  00001001  ENT   0x10 (D 16)
		00000578  0000639e  PSHI  0x63 (D 99)
		0000057c  0000019e  PSHI  0x1 (D 1)
		00000580  fffacc05  JSR   0xfffffacc (TO 0x50)
		00000584  00001001  ENT   0x10 (D 16)
		00000588  00003a9e  PSHI  0x3a (D 58)
		0000058c  0000019e  PSHI  0x1 (D 1)
		00000590  fffabc05  JSR   0xfffffabc (TO 0x50)
		00000594  00001001  ENT   0x10 (D 16)
		00000598  0000209e  PSHI  0x20 (D 32)
		0000059c  0000019e  PSHI  0x1 (D 1)
		000005a0  fffaac05  JSR   0xfffffaac (TO 0x50)
		000005a4  00001001  ENT   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=283 start=362 end=371>
	<code>  while (*s) out(1,*s++);</code>
	<emi>
		000005a8  00000003  JMP   <fwd>
		000005ac  0000080e  LL    0x8 (D 8)
		000005b0  ffffff57  SUBI  0xffffffff (D -1)
		000005b4  00000840  SL    0x8 (D 8)
		000005b8  ffffff1f  LXC   0xffffffff (D -1)
		000005bc  0000009d  PSHA
		000005c0  0000019e  PSHI  0x1 (D 1)
		000005c4  fffa8805  JSR   0xfffffa88 (TO 0x50)
		000005c8  00001001  ENT   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=284 start=371 end=378>
	<code>  out(1,'\n');</code>
	<emi>
		000005cc  0000080e  LL    0x8 (D 8)
		000005d0  0000001f  LXC 
		000005d4  00000086  BNZ   <fwd>
		000005d8  00000a9e  PSHI  0xa (D 10)
		000005dc  0000019e  PSHI  0x1 (D 1)
		000005e0  fffa6c05  JSR   0xfffffa6c (TO 0x50)
		000005e4  00001001  ENT   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=285 start=378 end=379>
	<code>  asm(HALT);</code>
	<emi>
		000005e8  00000000  HALT
	</emi>
</stmt>
<stmt file=os.c line=286 start=379 end=379>
	<code>}</code>
</stmt>
<stmt file=os.c line=287 start=379 end=379>
	<code></code>
</stmt>
<stmt file=os.c line=288 start=379 end=380>
	<code>consoleintr()</code>
	<emi>
		000005ec  00000002  LEV   0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=289 start=380 end=380>
	<code>{</code>
</stmt>
<stmt file=os.c line=290 start=380 end=380>
	<code>  int c;</code>
</stmt>
<stmt file=os.c line=291 start=380 end=382>
	<code>  while ((c = in(0)) != -1) {</code>
	<emi>
		000005f0  fffff801  ENT   0xfffffff8 (D -8)
		000005f4  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=292 start=382 end=382>
	<code>//    printf("<%d>",c); //   XXX</code>
</stmt>
<stmt file=os.c line=293 start=382 end=387>
	<code>    if (input.w - input.r < INPUT_BUF) {</code>
	<emi>
		000005f8  0021f815  LG    0x21f8 (D 8696)
		000005fc  0021f42d  LBG   0x21f4 (D 8692)
		00000600  00000056  SUB 
		00000604  0000803b  LBI   0x80 (D 128)
		00000608  00000090  BGEU  <fwd>
	</emi>
</stmt>
<stmt file=os.c line=294 start=387 end=399>
	<code>      input.buf[input.w++ % INPUT_BUF] = c;</code>
	<emi>
		0000060c  00217408  LEAG  0x2174 (D 8564)
		00000610  0000009d  PSHA
		00000614  0021f815  LG    0x21f8 (D 8696)
		00000618  ffffff57  SUBI  0xffffffff (D -1)
		0000061c  0021f845  SG    0x21f8 (D 8696)
		00000620  ffffff54  ADDI  0xffffffff (D -1)
		00000624  00008066  MDUI  0x80 (D 128)
		00000628  000000a1  POPB
		0000062c  00000053  ADD 
		00000630  0000003e  LBA 
		00000634  0000040e  LL    0x4 (D 4)
		00000638  0000004c  SXB 
	</emi>
</stmt>
<stmt file=os.c line=295 start=399 end=403>
	<code>      wakeup(&input.r);</code>
	<emi>
		0000063c  0021f408  LEAG  0x21f4 (D 8692)
		00000640  0000009d  PSHA
		00000644  00000005  JSR   <fwd>
		00000648  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=296 start=403 end=403>
	<code>    }</code>
</stmt>
<stmt file=os.c line=297 start=403 end=403>
	<code>  }</code>
</stmt>
<stmt file=os.c line=298 start=403 end=409>
	<code>}</code>
	<emi>
		0000064c  0000009e  PSHI  0x0 (D 0)
		00000650  fff9f005  JSR   0xfffff9f0 (TO 0x44)
		00000654  00000801  ENT   0x8 (D 8)
		00000658  00000440  SL    0x4 (D 4)
		0000065c  ffffff3b  LBI   0xffffffff (D -1)
		00000660  0000008a  BNE   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=299 start=409 end=409>
	<code></code>
</stmt>
<stmt file=os.c line=300 start=409 end=410>
	<code>int consoleread(struct inode *ip, char *dst, int n)</code>
	<emi>
		00000664  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=301 start=410 end=410>
	<code>{</code>
</stmt>
<stmt file=os.c line=302 start=410 end=410>
	<code>  int target, c, e;</code>
</stmt>
<stmt file=os.c line=303 start=410 end=410>
	<code></code>
</stmt>
<stmt file=os.c line=304 start=410 end=415>
	<code>  iunlock(ip);</code>
	<emi>
		00000668  fffff001  ENT   0xfffffff0 (D -16)
		0000066c  0000180e  LL    0x18 (D 24)
		00000670  0000009d  PSHA
		00000674  00000005  JSR   <fwd>
		00000678  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=305 start=415 end=417>
	<code>  target = n;</code>
	<emi>
		0000067c  0000280e  LL    0x28 (D 40)
		00000680  00000c40  SL    0xc (D 12)
	</emi>
</stmt>
<stmt file=os.c line=306 start=417 end=419>
	<code>  e = splhi();</code>
	<emi>
		00000684  fffa1805  JSR   0xfffffa18 (TO 0xa0)
		00000688  00000440  SL    0x4 (D 4)
	</emi>
</stmt>
<stmt file=os.c line=307 start=419 end=420>
	<code>  while (n > 0) {</code>
	<emi>
		0000068c  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=308 start=420 end=427>
	<code>    if (input.r == input.w && n < target) break; // block until at least one byte transfered</code>
	<emi>
		00000690  0021f415  LG    0x21f4 (D 8692)
		00000694  0021f82d  LBG   0x21f8 (D 8696)
		00000698  0000008a  BNE   <fwd>
		0000069c  0000280e  LL    0x28 (D 40)
		000006a0  00000c26  LBL   0xc (D 12)
		000006a4  0006988f  BGE   <fwd>
		000006a8  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=309 start=427 end=428>
	<code>    while (input.r == input.w) {</code>
	<emi>
		000006ac  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=310 start=428 end=431>
	<code>      if (u->killed) {</code>
	<emi>
		000006b0  00210015  LG    0x2100 (D 8448)
		000006b4  00002c1c  LX    0x2c (D 44)
		000006b8  00000084  BZ    <fwd>
	</emi>
</stmt>
<stmt file=os.c line=311 start=431 end=435>
	<code>        splx(e);</code>
	<emi>
		000006bc  0000040e  LL    0x4 (D 4)
		000006c0  0000009d  PSHA
		000006c4  fff9e005  JSR   0xfffff9e0 (TO 0xa8)
		000006c8  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=312 start=435 end=439>
	<code>        ilock(ip);</code>
	<emi>
		000006cc  0000180e  LL    0x18 (D 24)
		000006d0  0000009d  PSHA
		000006d4  00000005  JSR   <fwd>
		000006d8  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=313 start=439 end=441>
	<code>        return -1;</code>
	<emi>
		000006dc  ffffff23  LI    0xffffffff (D -1)
		000006e0  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=314 start=441 end=441>
	<code>      }</code>
</stmt>
<stmt file=os.c line=315 start=441 end=445>
	<code>      sleep(&input.r);</code>
	<emi>
		000006e4  0021f408  LEAG  0x21f4 (D 8692)
		000006e8  0000009d  PSHA
		000006ec  00000005  JSR   <fwd>
		000006f0  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=316 start=445 end=445>
	<code>    }</code>
</stmt>
<stmt file=os.c line=317 start=445 end=459>
	<code>    c = input.buf[input.r++ % INPUT_BUF];</code>
	<emi>
		000006f4  0021f415  LG    0x21f4 (D 8692)
		000006f8  0021f82d  LBG   0x21f8 (D 8696)
		000006fc  00000088  BE    <fwd>
		00000700  00217408  LEAG  0x2174 (D 8564)
		00000704  0000009d  PSHA
		00000708  0021f415  LG    0x21f4 (D 8692)
		0000070c  ffffff57  SUBI  0xffffffff (D -1)
		00000710  0021f445  SG    0x21f4 (D 8692)
		00000714  ffffff54  ADDI  0xffffffff (D -1)
		00000718  00008066  MDUI  0x80 (D 128)
		0000071c  000000a1  POPB
		00000720  00000053  ADD 
		00000724  0000001f  LXC 
		00000728  00000840  SL    0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=318 start=459 end=466>
	<code>    *dst++ = c;  // XXX pagefault possible in cli (perhaps use inode locks to achieve desired effect)</code>
	<emi>
		0000072c  0000200e  LL    0x20 (D 32)
		00000730  ffffff57  SUBI  0xffffffff (D -1)
		00000734  00002040  SL    0x20 (D 32)
		00000738  ffffff54  ADDI  0xffffffff (D -1)
		0000073c  0000003e  LBA 
		00000740  0000080e  LL    0x8 (D 8)
		00000744  0000004c  SXB 
	</emi>
</stmt>
<stmt file=os.c line=319 start=466 end=469>
	<code>    n--;</code>
	<emi>
		00000748  0000280e  LL    0x28 (D 40)
		0000074c  00000157  SUBI  0x1 (D 1)
		00000750  00002840  SL    0x28 (D 40)
	</emi>
</stmt>
<stmt file=os.c line=320 start=469 end=469>
	<code>  }</code>
</stmt>
<stmt file=os.c line=321 start=469 end=476>
	<code>  splx(e);</code>
	<emi>
		00000754  00000023  LI    0x0 (D 0)
		00000758  00002826  LBL   0x28 (D 40)
		0000075c  0000008c  BLT   <fwd>
		00000760  0000040e  LL    0x4 (D 4)
		00000764  0000009d  PSHA
		00000768  fff93c05  JSR   0xfffff93c (TO 0xa8)
		0000076c  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=322 start=476 end=480>
	<code>  ilock(ip);</code>
	<emi>
		00000770  0000180e  LL    0x18 (D 24)
		00000774  0000009d  PSHA
		00000778  0006d405  JSR   <fwd>
		0000077c  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=323 start=480 end=480>
	<code></code>
</stmt>
<stmt file=os.c line=324 start=480 end=483>
	<code>  return target - n;</code>
	<emi>
		00000780  00000c0e  LL    0xc (D 12)
		00000784  00002858  SUBL  0x28 (D 40)
		00000788  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=325 start=483 end=483>
	<code>}</code>
</stmt>
<stmt file=os.c line=326 start=483 end=483>
	<code></code>
</stmt>
<stmt file=os.c line=327 start=483 end=484>
	<code>int consolewrite(struct inode *ip, char *buf, int n)</code>
	<emi>
		0000078c  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=328 start=484 end=484>
	<code>{</code>
</stmt>
<stmt file=os.c line=329 start=484 end=484>
	<code>  int i, e;</code>
</stmt>
<stmt file=os.c line=330 start=484 end=484>
	<code></code>
</stmt>
<stmt file=os.c line=331 start=484 end=489>
	<code>  iunlock(ip);</code>
	<emi>
		00000790  fffff801  ENT   0xfffffff8 (D -8)
		00000794  0000100e  LL    0x10 (D 16)
		00000798  0000009d  PSHA
		0000079c  00067405  JSR   <fwd>
		000007a0  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=332 start=489 end=491>
	<code>  e = splhi(); // XXX pagefault possible in cli</code>
	<emi>
		000007a4  fff8f805  JSR   0xfffff8f8 (TO 0xa0)
		000007a8  00000040  SL    0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=333 start=491 end=500>
	<code>  for (i = 0; i < n; i++) cout(buf[i]);</code>
	<emi>
		000007ac  00000023  LI    0x0 (D 0)
		000007b0  00000440  SL    0x4 (D 4)
		000007b4  00000003  JMP   <fwd>
		000007b8  0000180e  LL    0x18 (D 24)
		000007bc  00000455  ADDL  0x4 (D 4)
		000007c0  0000001f  LXC 
		000007c4  0000009d  PSHA
		000007c8  fffb3805  JSR   0xfffffb38 (TO 0x304)
		000007cc  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=334 start=500 end=510>
	<code>  splx(e);</code>
	<emi>
		000007d0  0000040e  LL    0x4 (D 4)
		000007d4  ffffff57  SUBI  0xffffffff (D -1)
		000007d8  00000440  SL    0x4 (D 4)
		000007dc  0000040e  LL    0x4 (D 4)
		000007e0  00002026  LBL   0x20 (D 32)
		000007e4  0000008c  BLT   <fwd>
		000007e8  0000000e  LL    0x0 (D 0)
		000007ec  0000009d  PSHA
		000007f0  fff8b405  JSR   0xfffff8b4 (TO 0xa8)
		000007f4  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=335 start=510 end=514>
	<code>  ilock(ip);</code>
	<emi>
		000007f8  0000100e  LL    0x10 (D 16)
		000007fc  0000009d  PSHA
		00000800  00077805  JSR   <fwd>
		00000804  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=336 start=514 end=516>
	<code>  return n;</code>
	<emi>
		00000808  0000200e  LL    0x20 (D 32)
		0000080c  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=337 start=516 end=516>
	<code>}</code>
</stmt>
<stmt file=os.c line=338 start=516 end=516>
	<code></code>
</stmt>
<stmt file=os.c line=339 start=516 end=517>
	<code>consoleinit()</code>
	<emi>
		00000810  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=340 start=517 end=517>
	<code>{</code>
</stmt>
<stmt file=os.c line=341 start=517 end=519>
	<code>  devsw[CONSOLE].write = consolewrite;</code>
	<emi>
		00000814  ffff7808  LEAG  0xffffff78 (D -136)
		00000818  00212445  SG    0x2124 (D 8484)
	</emi>
</stmt>
<stmt file=os.c line=342 start=519 end=521>
	<code>  devsw[CONSOLE].read  = consoleread;</code>
	<emi>
		0000081c  fffe4808  LEAG  0xfffffe48 (D -440)
		00000820  00212045  SG    0x2120 (D 8480)
	</emi>
</stmt>
<stmt file=os.c line=343 start=521 end=521>
	<code>}</code>
</stmt>
<stmt file=os.c line=344 start=521 end=521>
	<code></code>
</stmt>
<stmt file=os.c line=345 start=521 end=521>
	<code>// fake IDE disk; stores blocks in memory.  useful for running kernel without scratch disk.  XXX but no good for stressing demand pageing logic!</code>
</stmt>
<stmt file=os.c line=346 start=521 end=522>
	<code>ideinit()</code>
	<emi>
		00000824  00000002  LEV   0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=347 start=522 end=522>
	<code>{</code>
</stmt>
<stmt file=os.c line=348 start=522 end=528>
	<code>  memdisk = P2V+(mem_sz - FSSIZE);</code>
	<emi>
		00000828  00211015  LG    0x2110 (D 8464)
		0000082c  c0000054  ADDI  0xffc00000 (D -4194304)
		00000830  ffffc03b  LBI   0xffffffc0 (D -64)
		00000834  0000003c  LBHI  0x0 (D 0)
		00000838  00000053  ADD 
		0000083c  00217045  SG    0x2170 (D 8560)
	</emi>
</stmt>
<stmt file=os.c line=349 start=528 end=528>
	<code>}</code>
</stmt>
<stmt file=os.c line=350 start=528 end=528>
	<code></code>
</stmt>
<stmt file=os.c line=351 start=528 end=528>
	<code>// sync buf with disk.  if B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.</code>
</stmt>
<stmt file=os.c line=352 start=528 end=528>
	<code>// else if B_VALID is not set, read buf from disk, set B_VALID.</code>
</stmt>
<stmt file=os.c line=353 start=528 end=529>
	<code>iderw(struct buf *b) // XXX rename?!</code>
	<emi>
		00000840  00000002  LEV   0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=354 start=529 end=529>
	<code>{</code>
</stmt>
<stmt file=os.c line=355 start=529 end=537>
	<code>  if (!(b->flags & B_BUSY)) panic("iderw: buf not busy");</code>
	<emi>
		00000844  0000080e  LL    0x8 (D 8)
		00000848  0000001c  LX  
		0000084c  00000169  ANDI  0x1 (D 1)
		00000850  00000086  BNZ   <fwd>
		00000854  00007008  LEAG  0x70 (D 112)
		00000858  0000009d  PSHA
		0000085c  fffcd405  JSR   0xfffffcd4 (TO 0x534)
		00000860  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=356 start=537 end=546>
	<code>  if ((b->flags & (B_VALID|B_DIRTY)) == B_VALID) panic("iderw: nothing to do");</code>
	<emi>
		00000864  0000080e  LL    0x8 (D 8)
		00000868  0000001c  LX  
		0000086c  00000669  ANDI  0x6 (D 6)
		00000870  0000023b  LBI   0x2 (D 2)
		00000874  0000008a  BNE   <fwd>
		00000878  00008408  LEAG  0x84 (D 132)
		0000087c  0000009d  PSHA
		00000880  fffcb005  JSR   0xfffffcb0 (TO 0x534)
		00000884  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=357 start=546 end=554>
	<code>  if (b->sector >= (FSSIZE / PAGE)) panic("iderw: sector out of range");</code>
	<emi>
		00000888  0000080e  LL    0x8 (D 8)
		0000088c  0000041c  LX    0x4 (D 4)
		00000890  0004003b  LBI   0x400 (D 1024)
		00000894  0000008d  BLTU  <fwd>
		00000898  00009908  LEAG  0x99 (D 153)
		0000089c  0000009d  PSHA
		000008a0  fffc9005  JSR   0xfffffc90 (TO 0x534)
		000008a4  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=358 start=554 end=554>
	<code></code>
</stmt>
<stmt file=os.c line=359 start=554 end=558>
	<code>  if (b->flags & B_DIRTY) {</code>
	<emi>
		000008a8  0000080e  LL    0x8 (D 8)
		000008ac  0000001c  LX  
		000008b0  00000469  ANDI  0x4 (D 4)
		000008b4  00000084  BZ    <fwd>
	</emi>
</stmt>
<stmt file=os.c line=360 start=558 end=563>
	<code>    b->flags &= ~B_DIRTY;</code>
	<emi>
		000008b8  0000080e  LL    0x8 (D 8)
		000008bc  0000003e  LBA 
		000008c0  0000001c  LX  
		000008c4  fffffb69  ANDI  0xfffffffb (D -5)
		000008c8  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=361 start=563 end=575>
	<code>    memcpy(memdisk + b->sector*PAGE, b->data, PAGE);</code>
	<emi>
		000008cc  0010009e  PSHI  0x1000 (D 4096)
		000008d0  0000100e  LL    0x10 (D 16)
		000008d4  0000101c  LX    0x10 (D 16)
		000008d8  0000009d  PSHA
		000008dc  0000180e  LL    0x18 (D 24)
		000008e0  0000041c  LX    0x4 (D 4)
		000008e4  0010005a  MULI  0x1000 (D 4096)
		000008e8  0021702d  LBG   0x2170 (D 8560)
		000008ec  00000053  ADD 
		000008f0  0000009d  PSHA
		000008f4  fff70805  JSR   0xfffff708 (TO 0x0)
		000008f8  00001801  ENT   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=362 start=575 end=575>
	<code>  } else</code>
</stmt>
<stmt file=os.c line=363 start=575 end=588>
	<code>    memcpy(b->data, memdisk + b->sector*PAGE, PAGE);</code>
	<emi>
		000008fc  00000003  JMP   <fwd>
		00000900  0010009e  PSHI  0x1000 (D 4096)
		00000904  0000100e  LL    0x10 (D 16)
		00000908  0000041c  LX    0x4 (D 4)
		0000090c  0010005a  MULI  0x1000 (D 4096)
		00000910  0021702d  LBG   0x2170 (D 8560)
		00000914  00000053  ADD 
		00000918  0000009d  PSHA
		0000091c  0000180e  LL    0x18 (D 24)
		00000920  0000101c  LX    0x10 (D 16)
		00000924  0000009d  PSHA
		00000928  fff6d405  JSR   0xfffff6d4 (TO 0x0)
		0000092c  00001801  ENT   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=364 start=588 end=593>
	<code>  b->flags |= B_VALID;</code>
	<emi>
		00000930  0000080e  LL    0x8 (D 8)
		00000934  0000003e  LBA 
		00000938  0000001c  LX  
		0000093c  0000026c  ORI   0x2 (D 2)
		00000940  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=365 start=593 end=593>
	<code>}</code>
</stmt>
<stmt file=os.c line=366 start=593 end=593>
	<code></code>
</stmt>
<stmt file=os.c line=367 start=593 end=593>
	<code>// buffer cache:</code>
</stmt>
<stmt file=os.c line=368 start=593 end=593>
	<code>// The buffer cache is a linked list of buf structures holding cached copies of disk block contents.  Caching disk blocks.</code>
</stmt>
<stmt file=os.c line=369 start=593 end=593>
	<code>// in memory reduces the number of disk reads and also provides a synchronization point for disk blocks used by multiple processes.</code>
</stmt>
<stmt file=os.c line=370 start=593 end=593>
	<code>// </code>
</stmt>
<stmt file=os.c line=371 start=593 end=593>
	<code>// Interface:</code>
</stmt>
<stmt file=os.c line=372 start=593 end=593>
	<code>// * To get a buffer for a particular disk block, call bread.</code>
</stmt>
<stmt file=os.c line=373 start=593 end=593>
	<code>// * After changing buffer data, call bwrite to write it to disk.</code>
</stmt>
<stmt file=os.c line=374 start=593 end=593>
	<code>// * When done with the buffer, call brelse.</code>
</stmt>
<stmt file=os.c line=375 start=593 end=593>
	<code>// * Do not use the buffer after calling brelse.</code>
</stmt>
<stmt file=os.c line=376 start=593 end=593>
	<code>// * Only one process at a time can use a buffer, so do not keep them longer than necessary.</code>
</stmt>
<stmt file=os.c line=377 start=593 end=593>
	<code>// </code>
</stmt>
<stmt file=os.c line=378 start=593 end=593>
	<code>// The implementation uses three state flags internally:</code>
</stmt>
<stmt file=os.c line=379 start=593 end=593>
	<code>// * B_BUSY: the block has been returned from bread and has not been passed back to brelse.  </code>
</stmt>
<stmt file=os.c line=380 start=593 end=593>
	<code>// * B_VALID: the buffer data has been read from the disk.</code>
</stmt>
<stmt file=os.c line=381 start=593 end=593>
	<code>// * B_DIRTY: the buffer data has been modified and needs to be written to disk.</code>
</stmt>
<stmt file=os.c line=382 start=593 end=594>
	<code>binit()</code>
	<emi>
		00000944  00000002  LEV   0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=383 start=594 end=594>
	<code>{</code>
</stmt>
<stmt file=os.c line=384 start=594 end=594>
	<code>  struct buf *b;</code>
</stmt>
<stmt file=os.c line=385 start=594 end=594>
	<code></code>
</stmt>
<stmt file=os.c line=386 start=594 end=594>
	<code>  // create linked list of buffers</code>
</stmt>
<stmt file=os.c line=387 start=594 end=598>
	<code>  bfreelist.prev = bfreelist.next = &bfreelist;</code>
	<emi>
		00000948  fffff801  ENT   0xfffffff8 (D -8)
		0000094c  0022c408  LEAG  0x22c4 (D 8900)
		00000950  0022d045  SG    0x22d0 (D 8912)
		00000954  0022cc45  SG    0x22cc (D 8908)
	</emi>
</stmt>
<stmt file=os.c line=388 start=598 end=601>
	<code>  for (b = bcache; b < bcache+NBUF; b++) {</code>
	<emi>
		00000958  0021fc08  LEAG  0x21fc (D 8700)
		0000095c  00000440  SL    0x4 (D 4)
		00000960  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=389 start=601 end=606>
	<code>    b->next = bfreelist.next;</code>
	<emi>
		00000964  0000040e  LL    0x4 (D 4)
		00000968  00000c54  ADDI  0xc (D 12)
		0000096c  0000003e  LBA 
		00000970  0022d015  LG    0x22d0 (D 8912)
		00000974  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=390 start=606 end=612>
	<code>    b->prev = &bfreelist;</code>
	<emi>
		00000978  0000040e  LL    0x4 (D 4)
		0000097c  00000854  ADDI  0x8 (D 8)
		00000980  0000009d  PSHA
		00000984  0022c408  LEAG  0x22c4 (D 8900)
		00000988  000000a1  POPB
		0000098c  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=391 start=612 end=618>
	<code>    b->data = kalloc();</code>
	<emi>
		00000990  0000040e  LL    0x4 (D 4)
		00000994  00001054  ADDI  0x10 (D 16)
		00000998  0000009d  PSHA
		0000099c  fff84c05  JSR   0xfffff84c (TO 0x1ec)
		000009a0  000000a1  POPB
		000009a4  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=392 start=618 end=623>
	<code>    bfreelist.next->prev = b;</code>
	<emi>
		000009a8  0022d015  LG    0x22d0 (D 8912)
		000009ac  00000854  ADDI  0x8 (D 8)
		000009b0  0000003e  LBA 
		000009b4  0000040e  LL    0x4 (D 4)
		000009b8  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=393 start=623 end=625>
	<code>    bfreelist.next = b;</code>
	<emi>
		000009bc  0000040e  LL    0x4 (D 4)
		000009c0  0022d045  SG    0x22d0 (D 8912)
	</emi>
</stmt>
<stmt file=os.c line=394 start=625 end=625>
	<code>  }</code>
</stmt>
<stmt file=os.c line=395 start=625 end=632>
	<code>}</code>
	<emi>
		000009c4  0000040e  LL    0x4 (D 4)
		000009c8  ffffec57  SUBI  0xffffffec (D -20)
		000009cc  00000440  SL    0x4 (D 4)
		000009d0  0022c408  LEAG  0x22c4 (D 8900)
		000009d4  0000003e  LBA 
		000009d8  0000040e  LL    0x4 (D 4)
		000009dc  0000008d  BLTU  <fwd>
	</emi>
</stmt>
<stmt file=os.c line=396 start=632 end=632>
	<code></code>
</stmt>
<stmt file=os.c line=397 start=632 end=632>
	<code>// look through buffer cache for sector.</code>
</stmt>
<stmt file=os.c line=398 start=632 end=632>
	<code>// if not found, allocate fresh block.  in either case, return B_BUSY buffer</code>
</stmt>
<stmt file=os.c line=399 start=632 end=633>
	<code>struct buf *bget(uint sector)</code>
	<emi>
		000009e0  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=400 start=633 end=633>
	<code>{</code>
</stmt>
<stmt file=os.c line=401 start=633 end=633>
	<code>  struct buf *b; int e = splhi();</code>
</stmt>
<stmt file=os.c line=402 start=633 end=633>
	<code>  </code>
</stmt>
<stmt file=os.c line=403 start=633 end=636>
	<code>loop:  // try for cached block</code>
	<emi>
		000009e4  fffff801  ENT   0xfffffff8 (D -8)
		000009e8  fff6b405  JSR   0xfffff6b4 (TO 0xa0)
		000009ec  00000040  SL    0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=404 start=636 end=639>
	<code>  for (b = bfreelist.next; b != &bfreelist; b = b->next) {</code>
	<emi>
		000009f0  0022d015  LG    0x22d0 (D 8912)
		000009f4  00000440  SL    0x4 (D 4)
		000009f8  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=405 start=639 end=643>
	<code>    if (b->sector == sector) {</code>
	<emi>
		000009fc  0000040e  LL    0x4 (D 4)
		00000a00  0000041c  LX    0x4 (D 4)
		00000a04  00001026  LBL   0x10 (D 16)
		00000a08  0000008a  BNE   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=406 start=643 end=647>
	<code>      if (!(b->flags & B_BUSY)) {</code>
	<emi>
		00000a0c  0000040e  LL    0x4 (D 4)
		00000a10  0000001c  LX  
		00000a14  00000169  ANDI  0x1 (D 1)
		00000a18  00000086  BNZ   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=407 start=647 end=652>
	<code>        b->flags |= B_BUSY;</code>
	<emi>
		00000a1c  0000040e  LL    0x4 (D 4)
		00000a20  0000003e  LBA 
		00000a24  0000001c  LX  
		00000a28  0000016c  ORI   0x1 (D 1)
		00000a2c  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=408 start=652 end=656>
	<code>        splx(e);</code>
	<emi>
		00000a30  0000000e  LL    0x0 (D 0)
		00000a34  0000009d  PSHA
		00000a38  fff66c05  JSR   0xfffff66c (TO 0xa8)
		00000a3c  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=409 start=656 end=658>
	<code>        return b;</code>
	<emi>
		00000a40  0000040e  LL    0x4 (D 4)
		00000a44  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=410 start=658 end=658>
	<code>      }</code>
</stmt>
<stmt file=os.c line=411 start=658 end=662>
	<code>      sleep(b);</code>
	<emi>
		00000a48  0000040e  LL    0x4 (D 4)
		00000a4c  0000009d  PSHA
		00000a50  0006ec05  JSR   <fwd>
		00000a54  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=412 start=662 end=663>
	<code>      goto loop;</code>
	<emi>
		00000a58  ffff9403  JMP   0xffffff94 (TO 0x9f0)
	</emi>
</stmt>
<stmt file=os.c line=413 start=663 end=663>
	<code>    }</code>
</stmt>
<stmt file=os.c line=414 start=663 end=663>
	<code>  }</code>
</stmt>
<stmt file=os.c line=415 start=663 end=663>
	<code></code>
</stmt>
<stmt file=os.c line=416 start=663 end=663>
	<code>  // allocate fresh block</code>
</stmt>
<stmt file=os.c line=417 start=663 end=672>
	<code>  for (b = bfreelist.prev; b != &bfreelist; b = b->prev) {</code>
	<emi>
		00000a5c  0000040e  LL    0x4 (D 4)
		00000a60  00000c1c  LX    0xc (D 12)
		00000a64  00000440  SL    0x4 (D 4)
		00000a68  0022c408  LEAG  0x22c4 (D 8900)
		00000a6c  00000426  LBL   0x4 (D 4)
		00000a70  0000008a  BNE   <fwd>
		00000a74  0022cc15  LG    0x22cc (D 8908)
		00000a78  00000440  SL    0x4 (D 4)
		00000a7c  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=418 start=672 end=676>
	<code>    if (!(b->flags & (B_BUSY | B_DIRTY))) {</code>
	<emi>
		00000a80  0000040e  LL    0x4 (D 4)
		00000a84  0000001c  LX  
		00000a88  00000569  ANDI  0x5 (D 5)
		00000a8c  00000086  BNZ   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=419 start=676 end=681>
	<code>      b->sector = sector;</code>
	<emi>
		00000a90  0000040e  LL    0x4 (D 4)
		00000a94  00000454  ADDI  0x4 (D 4)
		00000a98  0000003e  LBA 
		00000a9c  0000100e  LL    0x10 (D 16)
		00000aa0  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=420 start=681 end=684>
	<code>      b->flags = B_BUSY;</code>
	<emi>
		00000aa4  00000123  LI    0x1 (D 1)
		00000aa8  00000426  LBL   0x4 (D 4)
		00000aac  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=421 start=684 end=688>
	<code>      splx(e);</code>
	<emi>
		00000ab0  0000000e  LL    0x0 (D 0)
		00000ab4  0000009d  PSHA
		00000ab8  fff5ec05  JSR   0xfffff5ec (TO 0xa8)
		00000abc  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=422 start=688 end=690>
	<code>      return b;</code>
	<emi>
		00000ac0  0000040e  LL    0x4 (D 4)
		00000ac4  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=423 start=690 end=690>
	<code>    }</code>
</stmt>
<stmt file=os.c line=424 start=690 end=690>
	<code>  }</code>
</stmt>
<stmt file=os.c line=425 start=690 end=700>
	<code>  panic("bget: no buffers");</code>
	<emi>
		00000ac8  0000040e  LL    0x4 (D 4)
		00000acc  0000081c  LX    0x8 (D 8)
		00000ad0  00000440  SL    0x4 (D 4)
		00000ad4  0022c408  LEAG  0x22c4 (D 8900)
		00000ad8  00000426  LBL   0x4 (D 4)
		00000adc  0000008a  BNE   <fwd>
		00000ae0  0000b408  LEAG  0xb4 (D 180)
		00000ae4  0000009d  PSHA
		00000ae8  fffa4805  JSR   0xfffffa48 (TO 0x534)
		00000aec  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=426 start=700 end=700>
	<code>}</code>
</stmt>
<stmt file=os.c line=427 start=700 end=700>
	<code></code>
</stmt>
<stmt file=os.c line=428 start=700 end=700>
	<code>// return a B_BUSY buf with the contents of the indicated disk sector</code>
</stmt>
<stmt file=os.c line=429 start=700 end=701>
	<code>struct buf *bread(uint sector)</code>
	<emi>
		00000af0  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=430 start=701 end=701>
	<code>{</code>
</stmt>
<stmt file=os.c line=431 start=701 end=701>
	<code>  struct buf *b;</code>
</stmt>
<stmt file=os.c line=432 start=701 end=701>
	<code></code>
</stmt>
<stmt file=os.c line=433 start=701 end=707>
	<code>  b = bget(sector);</code>
	<emi>
		00000af4  fffff801  ENT   0xfffffff8 (D -8)
		00000af8  0000100e  LL    0x10 (D 16)
		00000afc  0000009d  PSHA
		00000b00  fffee005  JSR   0xfffffee0 (TO 0x9e4)
		00000b04  00000801  ENT   0x8 (D 8)
		00000b08  00000440  SL    0x4 (D 4)
	</emi>
</stmt>
<stmt file=os.c line=434 start=707 end=715>
	<code>  if (!(b->flags & B_VALID)) iderw(b);</code>
	<emi>
		00000b0c  0000040e  LL    0x4 (D 4)
		00000b10  0000001c  LX  
		00000b14  00000269  ANDI  0x2 (D 2)
		00000b18  00000086  BNZ   <fwd>
		00000b1c  0000040e  LL    0x4 (D 4)
		00000b20  0000009d  PSHA
		00000b24  fffd1c05  JSR   0xfffffd1c (TO 0x844)
		00000b28  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=435 start=715 end=717>
	<code>  return b;</code>
	<emi>
		00000b2c  0000040e  LL    0x4 (D 4)
		00000b30  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=436 start=717 end=717>
	<code>}</code>
</stmt>
<stmt file=os.c line=437 start=717 end=717>
	<code></code>
</stmt>
<stmt file=os.c line=438 start=717 end=717>
	<code>// write b's contents to disk.  must be B_BUSY</code>
</stmt>
<stmt file=os.c line=439 start=717 end=718>
	<code>bwrite(struct buf *b)</code>
	<emi>
		00000b34  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=440 start=718 end=718>
	<code>{</code>
</stmt>
<stmt file=os.c line=441 start=718 end=726>
	<code>  if (!(b->flags & B_BUSY)) panic("bwrite");</code>
	<emi>
		00000b38  0000080e  LL    0x8 (D 8)
		00000b3c  0000001c  LX  
		00000b40  00000169  ANDI  0x1 (D 1)
		00000b44  00000086  BNZ   <fwd>
		00000b48  0000c508  LEAG  0xc5 (D 197)
		00000b4c  0000009d  PSHA
		00000b50  fff9e005  JSR   0xfffff9e0 (TO 0x534)
		00000b54  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=442 start=726 end=731>
	<code>  b->flags |= B_DIRTY;</code>
	<emi>
		00000b58  0000080e  LL    0x8 (D 8)
		00000b5c  0000003e  LBA 
		00000b60  0000001c  LX  
		00000b64  0000046c  ORI   0x4 (D 4)
		00000b68  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=443 start=731 end=735>
	<code>  iderw(b);</code>
	<emi>
		00000b6c  0000080e  LL    0x8 (D 8)
		00000b70  0000009d  PSHA
		00000b74  fffccc05  JSR   0xfffffccc (TO 0x844)
		00000b78  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=444 start=735 end=735>
	<code>}</code>
</stmt>
<stmt file=os.c line=445 start=735 end=735>
	<code></code>
</stmt>
<stmt file=os.c line=446 start=735 end=735>
	<code>// release a B_BUSY buffer.  move to the head of the MRU list</code>
</stmt>
<stmt file=os.c line=447 start=735 end=736>
	<code>brelse(struct buf *b)</code>
	<emi>
		00000b7c  00000002  LEV   0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=448 start=736 end=736>
	<code>{</code>
</stmt>
<stmt file=os.c line=449 start=736 end=736>
	<code>  int e = splhi();</code>
</stmt>
<stmt file=os.c line=450 start=736 end=747>
	<code>  if (!(b->flags & B_BUSY)) panic("brelse");</code>
	<emi>
		00000b80  fffff801  ENT   0xfffffff8 (D -8)
		00000b84  fff51805  JSR   0xfffff518 (TO 0xa0)
		00000b88  00000440  SL    0x4 (D 4)
		00000b8c  0000100e  LL    0x10 (D 16)
		00000b90  0000001c  LX  
		00000b94  00000169  ANDI  0x1 (D 1)
		00000b98  00000086  BNZ   <fwd>
		00000b9c  0000cc08  LEAG  0xcc (D 204)
		00000ba0  0000009d  PSHA
		00000ba4  fff98c05  JSR   0xfffff98c (TO 0x534)
		00000ba8  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=451 start=747 end=747>
	<code></code>
</stmt>
<stmt file=os.c line=452 start=747 end=755>
	<code>  b->next->prev = b->prev;</code>
	<emi>
		00000bac  0000100e  LL    0x10 (D 16)
		00000bb0  00000c1c  LX    0xc (D 12)
		00000bb4  00000854  ADDI  0x8 (D 8)
		00000bb8  0000009d  PSHA
		00000bbc  0000180e  LL    0x18 (D 24)
		00000bc0  0000081c  LX    0x8 (D 8)
		00000bc4  000000a1  POPB
		00000bc8  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=453 start=755 end=763>
	<code>  b->prev->next = b->next;</code>
	<emi>
		00000bcc  0000100e  LL    0x10 (D 16)
		00000bd0  0000081c  LX    0x8 (D 8)
		00000bd4  00000c54  ADDI  0xc (D 12)
		00000bd8  0000009d  PSHA
		00000bdc  0000180e  LL    0x18 (D 24)
		00000be0  00000c1c  LX    0xc (D 12)
		00000be4  000000a1  POPB
		00000be8  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=454 start=763 end=768>
	<code>  b->next = bfreelist.next;</code>
	<emi>
		00000bec  0000100e  LL    0x10 (D 16)
		00000bf0  00000c54  ADDI  0xc (D 12)
		00000bf4  0000003e  LBA 
		00000bf8  0022d015  LG    0x22d0 (D 8912)
		00000bfc  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=455 start=768 end=774>
	<code>  b->prev = &bfreelist;</code>
	<emi>
		00000c00  0000100e  LL    0x10 (D 16)
		00000c04  00000854  ADDI  0x8 (D 8)
		00000c08  0000009d  PSHA
		00000c0c  0022c408  LEAG  0x22c4 (D 8900)
		00000c10  000000a1  POPB
		00000c14  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=456 start=774 end=779>
	<code>  bfreelist.next->prev = b;</code>
	<emi>
		00000c18  0022d015  LG    0x22d0 (D 8912)
		00000c1c  00000854  ADDI  0x8 (D 8)
		00000c20  0000003e  LBA 
		00000c24  0000100e  LL    0x10 (D 16)
		00000c28  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=457 start=779 end=781>
	<code>  bfreelist.next = b;</code>
	<emi>
		00000c2c  0000100e  LL    0x10 (D 16)
		00000c30  0022d045  SG    0x22d0 (D 8912)
	</emi>
</stmt>
<stmt file=os.c line=458 start=781 end=786>
	<code>  b->flags &= ~B_BUSY;</code>
	<emi>
		00000c34  0000100e  LL    0x10 (D 16)
		00000c38  0000003e  LBA 
		00000c3c  0000001c  LX  
		00000c40  fffffe69  ANDI  0xfffffffe (D -2)
		00000c44  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=459 start=786 end=790>
	<code>  wakeup(b);</code>
	<emi>
		00000c48  0000100e  LL    0x10 (D 16)
		00000c4c  0000009d  PSHA
		00000c50  00064405  JSR   <fwd>
		00000c54  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=460 start=790 end=794>
	<code>  splx(e);</code>
	<emi>
		00000c58  0000040e  LL    0x4 (D 4)
		00000c5c  0000009d  PSHA
		00000c60  fff44405  JSR   0xfffff444 (TO 0xa8)
		00000c64  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=461 start=794 end=794>
	<code>}</code>
</stmt>
<stmt file=os.c line=462 start=794 end=794>
	<code></code>
</stmt>
<stmt file=os.c line=463 start=794 end=794>
	<code>// file system implementation.  four layers:</code>
</stmt>
<stmt file=os.c line=464 start=794 end=794>
	<code>//   Blocks      - allocator for disk blocks.</code>
</stmt>
<stmt file=os.c line=465 start=794 end=794>
	<code>//   Files       - inode allocator, reading, writing, metadata.</code>
</stmt>
<stmt file=os.c line=466 start=794 end=794>
	<code>//   Directories - inode with special contents (list of other inodes!)</code>
</stmt>
<stmt file=os.c line=467 start=794 end=794>
	<code>//   Names</code>
</stmt>
<stmt file=os.c line=468 start=794 end=794>
	<code></code>
</stmt>
<stmt file=os.c line=469 start=794 end=794>
	<code>// zero a block</code>
</stmt>
<stmt file=os.c line=470 start=794 end=795>
	<code>bzero(uint b)  // XXX only called in bfree</code>
	<emi>
		00000c68  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=471 start=795 end=795>
	<code>{</code>
</stmt>
<stmt file=os.c line=472 start=795 end=795>
	<code>  struct buf *bp;</code>
</stmt>
<stmt file=os.c line=473 start=795 end=801>
	<code>  bp = bread(b);</code>
	<emi>
		00000c6c  fffff801  ENT   0xfffffff8 (D -8)
		00000c70  0000100e  LL    0x10 (D 16)
		00000c74  0000009d  PSHA
		00000c78  fffe7805  JSR   0xfffffe78 (TO 0xaf4)
		00000c7c  00000801  ENT   0x8 (D 8)
		00000c80  00000440  SL    0x4 (D 4)
	</emi>
</stmt>
<stmt file=os.c line=474 start=801 end=808>
	<code>  memset(bp->data, 0, PAGE);</code>
	<emi>
		00000c84  0010009e  PSHI  0x1000 (D 4096)
		00000c88  0000009e  PSHI  0x0 (D 0)
		00000c8c  0000140e  LL    0x14 (D 20)
		00000c90  0000101c  LX    0x10 (D 16)
		00000c94  0000009d  PSHA
		00000c98  fff37c05  JSR   0xfffff37c (TO 0x18)
		00000c9c  00001801  ENT   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=475 start=808 end=812>
	<code>  bwrite(bp);</code>
	<emi>
		00000ca0  0000040e  LL    0x4 (D 4)
		00000ca4  0000009d  PSHA
		00000ca8  fffe8c05  JSR   0xfffffe8c (TO 0xb38)
		00000cac  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=476 start=812 end=816>
	<code>  brelse(bp);</code>
	<emi>
		00000cb0  0000040e  LL    0x4 (D 4)
		00000cb4  0000009d  PSHA
		00000cb8  fffec405  JSR   0xfffffec4 (TO 0xb80)
		00000cbc  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=477 start=816 end=816>
	<code>}</code>
</stmt>
<stmt file=os.c line=478 start=816 end=816>
	<code></code>
</stmt>
<stmt file=os.c line=479 start=816 end=816>
	<code>// allocate a disk block</code>
</stmt>
<stmt file=os.c line=480 start=816 end=817>
	<code>uint balloc()</code>
	<emi>
		00000cc0  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=481 start=817 end=817>
	<code>{</code>
</stmt>
<stmt file=os.c line=482 start=817 end=817>
	<code>  int b, bi, bb;</code>
</stmt>
<stmt file=os.c line=483 start=817 end=817>
	<code>  struct buf *bp;</code>
</stmt>
<stmt file=os.c line=484 start=817 end=817>
	<code></code>
</stmt>
<stmt file=os.c line=485 start=817 end=821>
	<code>  for (b = 0; b < 16; b++) {</code>
	<emi>
		00000cc4  fffff001  ENT   0xfffffff0 (D -16)
		00000cc8  00000023  LI    0x0 (D 0)
		00000ccc  00000c40  SL    0xc (D 12)
		00000cd0  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=486 start=821 end=826>
	<code>    bp = bread(b);</code>
	<emi>
		00000cd4  00000c0e  LL    0xc (D 12)
		00000cd8  0000009d  PSHA
		00000cdc  fffe1405  JSR   0xfffffe14 (TO 0xaf4)
		00000ce0  00000801  ENT   0x8 (D 8)
		00000ce4  00000040  SL    0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=487 start=826 end=829>
	<code>    for (bi = 0; bi < 4096; bi++) {</code>
	<emi>
		00000ce8  00000023  LI    0x0 (D 0)
		00000cec  00000840  SL    0x8 (D 8)
		00000cf0  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=488 start=829 end=836>
	<code>      if (bp->data[bi] == 0xff) continue;</code>
	<emi>
		00000cf4  0000000e  LL    0x0 (D 0)
		00000cf8  0000101c  LX    0x10 (D 16)
		00000cfc  00000855  ADDL  0x8 (D 8)
		00000d00  00000020  LXB 
		00000d04  0000ff3b  LBI   0xff (D 255)
		00000d08  0000008a  BNE   <fwd>
		00000d0c  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=489 start=836 end=839>
	<code>      for (bb = 0; bb < 8; bb++) {</code>
	<emi>
		00000d10  00000023  LI    0x0 (D 0)
		00000d14  00000440  SL    0x4 (D 4)
		00000d18  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=490 start=839 end=850>
	<code>        if (bp->data[bi] & (1 << bb)) continue; // is block free?</code>
	<emi>
		00000d1c  0000000e  LL    0x0 (D 0)
		00000d20  0000101c  LX    0x10 (D 16)
		00000d24  00000855  ADDL  0x8 (D 8)
		00000d28  00000020  LXB 
		00000d2c  0000009d  PSHA
		00000d30  00000123  LI    0x1 (D 1)
		00000d34  00000c73  SHLL  0xc (D 12)
		00000d38  000000a1  POPB
		00000d3c  00000068  AND 
		00000d40  00000084  BZ    <fwd>
		00000d44  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=491 start=850 end=861>
	<code>        bp->data[bi] |= (1 << bb);  // mark block in use</code>
	<emi>
		00000d48  00000123  LI    0x1 (D 1)
		00000d4c  00000473  SHLL  0x4 (D 4)
		00000d50  0000009d  PSHA
		00000d54  0000080e  LL    0x8 (D 8)
		00000d58  0000101c  LX    0x10 (D 16)
		00000d5c  00001055  ADDL  0x10 (D 16)
		00000d60  0000003e  LBA 
		00000d64  00000020  LXB 
		00000d68  0000006d  ORL 
		00000d6c  00000801  ENT   0x8 (D 8)
		00000d70  0000004c  SXB 
	</emi>
</stmt>
<stmt file=os.c line=492 start=861 end=865>
	<code>        bwrite(bp);</code>
	<emi>
		00000d74  0000000e  LL    0x0 (D 0)
		00000d78  0000009d  PSHA
		00000d7c  fffdb805  JSR   0xfffffdb8 (TO 0xb38)
		00000d80  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=493 start=865 end=869>
	<code>        brelse(bp);</code>
	<emi>
		00000d84  0000000e  LL    0x0 (D 0)
		00000d88  0000009d  PSHA
		00000d8c  fffdf005  JSR   0xfffffdf0 (TO 0xb80)
		00000d90  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=494 start=869 end=878>
	<code>        return b*(4096*8) + bi*8 + bb;</code>
	<emi>
		00000d94  0000080e  LL    0x8 (D 8)
		00000d98  0000085a  MULI  0x8 (D 8)
		00000d9c  0000009d  PSHA
		00000da0  0000140e  LL    0x14 (D 20)
		00000da4  0080005a  MULI  0x8000 (D 32768)
		00000da8  000000a1  POPB
		00000dac  00000053  ADD 
		00000db0  00000455  ADDL  0x4 (D 4)
		00000db4  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=495 start=878 end=878>
	<code>      }</code>
</stmt>
<stmt file=os.c line=496 start=878 end=884>
	<code>    }</code>
	<emi>
		00000db8  0000040e  LL    0x4 (D 4)
		00000dbc  ffffff57  SUBI  0xffffffff (D -1)
		00000dc0  00000440  SL    0x4 (D 4)
		00000dc4  0000040e  LL    0x4 (D 4)
		00000dc8  0000083b  LBI   0x8 (D 8)
		00000dcc  0000008c  BLT   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=497 start=884 end=894>
	<code>    brelse(bp);</code>
	<emi>
		00000dd0  0000080e  LL    0x8 (D 8)
		00000dd4  ffffff57  SUBI  0xffffffff (D -1)
		00000dd8  00000840  SL    0x8 (D 8)
		00000ddc  0000080e  LL    0x8 (D 8)
		00000de0  0010003b  LBI   0x1000 (D 4096)
		00000de4  0000008c  BLT   <fwd>
		00000de8  0000000e  LL    0x0 (D 0)
		00000dec  0000009d  PSHA
		00000df0  fffd8c05  JSR   0xfffffd8c (TO 0xb80)
		00000df4  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=498 start=894 end=894>
	<code>  }</code>
</stmt>
<stmt file=os.c line=499 start=894 end=904>
	<code>  panic("balloc: out of blocks");</code>
	<emi>
		00000df8  00000c0e  LL    0xc (D 12)
		00000dfc  ffffff57  SUBI  0xffffffff (D -1)
		00000e00  00000c40  SL    0xc (D 12)
		00000e04  00000c0e  LL    0xc (D 12)
		00000e08  0000103b  LBI   0x10 (D 16)
		00000e0c  0000008c  BLT   <fwd>
		00000e10  0000d308  LEAG  0xd3 (D 211)
		00000e14  0000009d  PSHA
		00000e18  fff71805  JSR   0xfffff718 (TO 0x534)
		00000e1c  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=500 start=904 end=904>
	<code>}</code>
</stmt>
<stmt file=os.c line=501 start=904 end=904>
	<code></code>
</stmt>
<stmt file=os.c line=502 start=904 end=904>
	<code>// free a disk block</code>
</stmt>
<stmt file=os.c line=503 start=904 end=905>
	<code>bfree(uint b)</code>
	<emi>
		00000e20  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=504 start=905 end=905>
	<code>{</code>
</stmt>
<stmt file=os.c line=505 start=905 end=905>
	<code>  int bi, m;</code>
</stmt>
<stmt file=os.c line=506 start=905 end=905>
	<code>  struct buf *bp;</code>
</stmt>
<stmt file=os.c line=507 start=905 end=905>
	<code></code>
</stmt>
<stmt file=os.c line=508 start=905 end=910>
	<code>  bzero(b);</code>
	<emi>
		00000e24  fffff001  ENT   0xfffffff0 (D -16)
		00000e28  0000180e  LL    0x18 (D 24)
		00000e2c  0000009d  PSHA
		00000e30  fffe3805  JSR   0xfffffe38 (TO 0xc6c)
		00000e34  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=509 start=910 end=910>
	<code></code>
</stmt>
<stmt file=os.c line=510 start=910 end=916>
	<code>  bp = bread(b / (4096*8));</code>
	<emi>
		00000e38  0000180e  LL    0x18 (D 24)
		00000e3c  00800060  DVUI  0x8000 (D 32768)
		00000e40  0000009d  PSHA
		00000e44  fffcac05  JSR   0xfffffcac (TO 0xaf4)
		00000e48  00000801  ENT   0x8 (D 8)
		00000e4c  00000440  SL    0x4 (D 4)
	</emi>
</stmt>
<stmt file=os.c line=511 start=916 end=922>
	<code>  m = 1 << (b & 7);</code>
	<emi>
		00000e50  0000180e  LL    0x18 (D 24)
		00000e54  00000769  ANDI  0x7 (D 7)
		00000e58  0000003e  LBA 
		00000e5c  00000123  LI    0x1 (D 1)
		00000e60  00000071  SHL 
		00000e64  00000840  SL    0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=512 start=922 end=926>
	<code>  b = (b / 8) & 4095;</code>
	<emi>
		00000e68  0000180e  LL    0x18 (D 24)
		00000e6c  00000860  DVUI  0x8 (D 8)
		00000e70  000fff69  ANDI  0xfff (D 4095)
		00000e74  00001840  SL    0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=513 start=926 end=936>
	<code>  if (!(bp->data[b] & m)) panic("freeing free block");</code>
	<emi>
		00000e78  0000040e  LL    0x4 (D 4)
		00000e7c  0000101c  LX    0x10 (D 16)
		00000e80  00001855  ADDL  0x18 (D 24)
		00000e84  00000020  LXB 
		00000e88  0000086a  ANDL  0x8 (D 8)
		00000e8c  00000086  BNZ   <fwd>
		00000e90  0000e908  LEAG  0xe9 (D 233)
		00000e94  0000009d  PSHA
		00000e98  fff69805  JSR   0xfffff698 (TO 0x534)
		00000e9c  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=514 start=936 end=947>
	<code>  bp->data[b] &= ~m;  // mark block free on disk</code>
	<emi>
		00000ea0  0000080e  LL    0x8 (D 8)
		00000ea4  ffffff6f  XORI  0xffffffff (D -1)
		00000ea8  0000009d  PSHA
		00000eac  00000c0e  LL    0xc (D 12)
		00000eb0  0000101c  LX    0x10 (D 16)
		00000eb4  00002055  ADDL  0x20 (D 32)
		00000eb8  0000003e  LBA 
		00000ebc  00000020  LXB 
		00000ec0  0000006a  ANDL
		00000ec4  00000801  ENT   0x8 (D 8)
		00000ec8  0000004c  SXB 
	</emi>
</stmt>
<stmt file=os.c line=515 start=947 end=951>
	<code>  bwrite(bp);</code>
	<emi>
		00000ecc  0000040e  LL    0x4 (D 4)
		00000ed0  0000009d  PSHA
		00000ed4  fffc6005  JSR   0xfffffc60 (TO 0xb38)
		00000ed8  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=516 start=951 end=955>
	<code>  brelse(bp);</code>
	<emi>
		00000edc  0000040e  LL    0x4 (D 4)
		00000ee0  0000009d  PSHA
		00000ee4  fffc9805  JSR   0xfffffc98 (TO 0xb80)
		00000ee8  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=517 start=955 end=955>
	<code>}</code>
</stmt>
<stmt file=os.c line=518 start=955 end=955>
	<code></code>
</stmt>
<stmt file=os.c line=519 start=955 end=955>
	<code>// Inodes:</code>
</stmt>
<stmt file=os.c line=520 start=955 end=955>
	<code>// An inode is a single, unnamed file in the file system.  The inode disk structure holds metadata</code>
</stmt>
<stmt file=os.c line=521 start=955 end=955>
	<code>// (the type, device numbers, and data size) along with a list of blocks where the data can be found.</code>
</stmt>
<stmt file=os.c line=522 start=955 end=955>
	<code>//</code>
</stmt>
<stmt file=os.c line=523 start=955 end=955>
	<code>// The kernel keeps a cache of the in-use on-disk structures to provide a place for synchronizing access</code>
</stmt>
<stmt file=os.c line=524 start=955 end=955>
	<code>// to inodes shared between multiple processes.</code>
</stmt>
<stmt file=os.c line=525 start=955 end=955>
	<code>// </code>
</stmt>
<stmt file=os.c line=526 start=955 end=955>
	<code>// ip->ref counts the number of pointer references to this cached inode; references are typically kept in</code>
</stmt>
<stmt file=os.c line=527 start=955 end=955>
	<code>// struct file and in u->cwd.  When ip->ref falls to zero, the inode is no longer cached.  It is an error</code>
</stmt>
<stmt file=os.c line=528 start=955 end=955>
	<code>// to use an inode without holding a reference to it.</code>
</stmt>
<stmt file=os.c line=529 start=955 end=955>
	<code>//</code>
</stmt>
<stmt file=os.c line=530 start=955 end=955>
	<code>// Processes are only allowed to read and write inode metadata and contents when holding the inode's lock,</code>
</stmt>
<stmt file=os.c line=531 start=955 end=955>
	<code>// represented by the I_BUSY flag in the in-memory copy.  Because inode locks are held during disk accesses, </code>
</stmt>
<stmt file=os.c line=532 start=955 end=955>
	<code>// they are implemented using a flag rather than with spin locks.  Callers are responsible for locking</code>
</stmt>
<stmt file=os.c line=533 start=955 end=955>
	<code>// inodes before passing them to routines in this file; leaving this responsibility with the caller makes</code>
</stmt>
<stmt file=os.c line=534 start=955 end=955>
	<code>// it possible for them to create arbitrarily-sized atomic operations.</code>
</stmt>
<stmt file=os.c line=535 start=955 end=955>
	<code>//</code>
</stmt>
<stmt file=os.c line=536 start=955 end=955>
	<code>// To give maximum control over locking to the callers, the routines in this file that return inode pointers </code>
</stmt>
<stmt file=os.c line=537 start=955 end=955>
	<code>// return pointers to *unlocked* inodes.  It is the callers' responsibility to lock them before using them.</code>
</stmt>
<stmt file=os.c line=538 start=955 end=955>
	<code>// A non-zero ip->ref keeps these unlocked inodes in the cache.</code>
</stmt>
<stmt file=os.c line=539 start=955 end=955>
	<code></code>
</stmt>
<stmt file=os.c line=540 start=955 end=955>
	<code>// find the inode with number inum and return the in-memory copy.  does not lock the inode and does not read it from disk</code>
</stmt>
<stmt file=os.c line=541 start=955 end=956>
	<code>struct inode *iget(uint inum)</code>
	<emi>
		00000eec  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=542 start=956 end=956>
	<code>{</code>
</stmt>
<stmt file=os.c line=543 start=956 end=956>
	<code>  struct inode *ip, *empty; int e = splhi();</code>
</stmt>
<stmt file=os.c line=544 start=956 end=956>
	<code></code>
</stmt>
<stmt file=os.c line=545 start=956 end=956>
	<code>  // is the inode already cached</code>
</stmt>
<stmt file=os.c line=546 start=956 end=961>
	<code>  empty = 0;</code>
	<emi>
		00000ef0  fffff001  ENT   0xfffffff0 (D -16)
		00000ef4  fff1a805  JSR   0xfffff1a8 (TO 0xa0)
		00000ef8  00000440  SL    0x4 (D 4)
		00000efc  00000023  LI    0x0 (D 0)
		00000f00  00000840  SL    0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=547 start=961 end=964>
	<code>  for (ip = &inode[0]; ip < &inode[NINODE]; ip++) {</code>
	<emi>
		00000f04  0022d808  LEAG  0x22d8 (D 8920)
		00000f08  00000c40  SL    0xc (D 12)
		00000f0c  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=548 start=964 end=973>
	<code>    if (ip->ref > 0 && ip->inum == inum) {</code>
	<emi>
		00000f10  00000c0e  LL    0xc (D 12)
		00000f14  0000041c  LX    0x4 (D 4)
		00000f18  0000003e  LBA 
		00000f1c  00000023  LI    0x0 (D 0)
		00000f20  0000008f  BGE   <fwd>
		00000f24  00000c0e  LL    0xc (D 12)
		00000f28  0000001c  LX  
		00000f2c  00001826  LBL   0x18 (D 24)
		00000f30  000f208a  BNE   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=549 start=973 end=979>
	<code>      ip->ref++;</code>
	<emi>
		00000f34  00000c0e  LL    0xc (D 12)
		00000f38  00000454  ADDI  0x4 (D 4)
		00000f3c  0000003e  LBA 
		00000f40  0000001c  LX  
		00000f44  ffffff57  SUBI  0xffffffff (D -1)
		00000f48  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=550 start=979 end=983>
	<code>      splx(e);</code>
	<emi>
		00000f4c  0000040e  LL    0x4 (D 4)
		00000f50  0000009d  PSHA
		00000f54  fff15005  JSR   0xfffff150 (TO 0xa8)
		00000f58  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=551 start=983 end=985>
	<code>      return ip;</code>
	<emi>
		00000f5c  00000c0e  LL    0xc (D 12)
		00000f60  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=552 start=985 end=985>
	<code>    }</code>
</stmt>
<stmt file=os.c line=553 start=985 end=992>
	<code>    if (!empty && !ip->ref) empty = ip; // remember empty slot</code>
	<emi>
		00000f64  0000080e  LL    0x8 (D 8)
		00000f68  00000086  BNZ   <fwd>
		00000f6c  00000c0e  LL    0xc (D 12)
		00000f70  0000041c  LX    0x4 (D 4)
		00000f74  000f6886  BNZ   <fwd>
		00000f78  00000c0e  LL    0xc (D 12)
		00000f7c  00000840  SL    0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=554 start=992 end=992>
	<code>  }</code>
</stmt>
<stmt file=os.c line=555 start=992 end=992>
	<code></code>
</stmt>
<stmt file=os.c line=556 start=992 end=992>
	<code>  // recycle an inode cache entry</code>
</stmt>
<stmt file=os.c line=557 start=992 end=1005>
	<code>  if (!empty) panic("iget: no inodes");</code>
	<emi>
		00000f80  00000c0e  LL    0xc (D 12)
		00000f84  fff06857  SUBI  0xfffff068 (D -3992)
		00000f88  00000c40  SL    0xc (D 12)
		00000f8c  032e8808  LEAG  0x32e88 (D 208520)
		00000f90  0000003e  LBA 
		00000f94  00000c0e  LL    0xc (D 12)
		00000f98  0000008d  BLTU  <fwd>
		00000f9c  0000080e  LL    0x8 (D 8)
		00000fa0  00000086  BNZ   <fwd>
		00000fa4  0000fc08  LEAG  0xfc (D 252)
		00000fa8  0000009d  PSHA
		00000fac  fff58405  JSR   0xfffff584 (TO 0x534)
		00000fb0  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=558 start=1005 end=1005>
	<code></code>
</stmt>
<stmt file=os.c line=559 start=1005 end=1007>
	<code>  ip = empty;</code>
	<emi>
		00000fb4  0000080e  LL    0x8 (D 8)
		00000fb8  00000c40  SL    0xc (D 12)
	</emi>
</stmt>
<stmt file=os.c line=560 start=1007 end=1010>
	<code>  ip->inum = inum;</code>
	<emi>
		00000fbc  0000180e  LL    0x18 (D 24)
		00000fc0  00000c26  LBL   0xc (D 12)
		00000fc4  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=561 start=1010 end=1015>
	<code>  ip->ref = 1;</code>
	<emi>
		00000fc8  00000c0e  LL    0xc (D 12)
		00000fcc  00000454  ADDI  0x4 (D 4)
		00000fd0  0000003e  LBA 
		00000fd4  00000123  LI    0x1 (D 1)
		00000fd8  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=562 start=1015 end=1020>
	<code>  ip->flags = 0;</code>
	<emi>
		00000fdc  00000c0e  LL    0xc (D 12)
		00000fe0  00000854  ADDI  0x8 (D 8)
		00000fe4  0000003e  LBA 
		00000fe8  00000023  LI    0x0 (D 0)
		00000fec  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=563 start=1020 end=1024>
	<code>  splx(e);</code>
	<emi>
		00000ff0  0000040e  LL    0x4 (D 4)
		00000ff4  0000009d  PSHA
		00000ff8  fff0ac05  JSR   0xfffff0ac (TO 0xa8)
		00000ffc  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=564 start=1024 end=1024>
	<code>  </code>
</stmt>
<stmt file=os.c line=565 start=1024 end=1026>
	<code>  return ip;</code>
	<emi>
		00001000  00000c0e  LL    0xc (D 12)
		00001004  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=566 start=1026 end=1026>
	<code>}</code>
</stmt>
<stmt file=os.c line=567 start=1026 end=1026>
	<code></code>
</stmt>
<stmt file=os.c line=568 start=1026 end=1026>
	<code>// allocate a new inode with the given mode</code>
</stmt>
<stmt file=os.c line=569 start=1026 end=1027>
	<code>struct inode *ialloc(ushort mode)</code>
	<emi>
		00001008  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=570 start=1027 end=1027>
	<code>{</code>
</stmt>
<stmt file=os.c line=571 start=1027 end=1027>
	<code>  int inum;</code>
</stmt>
<stmt file=os.c line=572 start=1027 end=1027>
	<code>  struct buf *bp;</code>
</stmt>
<stmt file=os.c line=573 start=1027 end=1027>
	<code>  struct dinode *dip;</code>
</stmt>
<stmt file=os.c line=574 start=1027 end=1027>
	<code></code>
</stmt>
<stmt file=os.c line=575 start=1027 end=1030>
	<code>  inum = balloc();</code>
	<emi>
		0000100c  fffff001  ENT   0xfffffff0 (D -16)
		00001010  fffcb005  JSR   0xfffffcb0 (TO 0xcc4)
		00001014  00000c40  SL    0xc (D 12)
	</emi>
</stmt>
<stmt file=os.c line=576 start=1030 end=1035>
	<code>  bp = bread(inum);</code>
	<emi>
		00001018  00000c0e  LL    0xc (D 12)
		0000101c  0000009d  PSHA
		00001020  fffad005  JSR   0xfffffad0 (TO 0xaf4)
		00001024  00000801  ENT   0x8 (D 8)
		00001028  00000840  SL    0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=577 start=1035 end=1038>
	<code>  dip = (struct dinode *)bp->data;</code>
	<emi>
		0000102c  0000080e  LL    0x8 (D 8)
		00001030  0000101c  LX    0x10 (D 16)
		00001034  00000440  SL    0x4 (D 4)
	</emi>
</stmt>
<stmt file=os.c line=578 start=1038 end=1044>
	<code>  memset(dip, 0, sizeof(*dip));</code>
	<emi>
		00001038  0010009e  PSHI  0x1000 (D 4096)
		0000103c  0000009e  PSHI  0x0 (D 0)
		00001040  0000140e  LL    0x14 (D 20)
		00001044  0000009d  PSHA
		00001048  ffefcc05  JSR   0xffffefcc (TO 0x18)
		0000104c  00001801  ENT   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=579 start=1044 end=1047>
	<code>  dip->mode = mode;</code>
	<emi>
		00001050  00001810  LLH   0x18 (D 24)
		00001054  00000426  LBL   0x4 (D 4)
		00001058  0000004b  SXH 
	</emi>
</stmt>
<stmt file=os.c line=580 start=1047 end=1051>
	<code>  bwrite(bp);   // mark it allocated on the disk</code>
	<emi>
		0000105c  0000080e  LL    0x8 (D 8)
		00001060  0000009d  PSHA
		00001064  fffad005  JSR   0xfffffad0 (TO 0xb38)
		00001068  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=581 start=1051 end=1055>
	<code>  brelse(bp);</code>
	<emi>
		0000106c  0000080e  LL    0x8 (D 8)
		00001070  0000009d  PSHA
		00001074  fffb0805  JSR   0xfffffb08 (TO 0xb80)
		00001078  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=582 start=1055 end=1060>
	<code>  return iget(inum);</code>
	<emi>
		0000107c  00000c0e  LL    0xc (D 12)
		00001080  0000009d  PSHA
		00001084  fffe6805  JSR   0xfffffe68 (TO 0xef0)
		00001088  00000801  ENT   0x8 (D 8)
		0000108c  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=583 start=1060 end=1060>
	<code>}</code>
</stmt>
<stmt file=os.c line=584 start=1060 end=1060>
	<code></code>
</stmt>
<stmt file=os.c line=585 start=1060 end=1060>
	<code>// copy modified memory inode to disk</code>
</stmt>
<stmt file=os.c line=586 start=1060 end=1061>
	<code>iupdate(struct inode *ip)</code>
	<emi>
		00001090  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=587 start=1061 end=1061>
	<code>{</code>
</stmt>
<stmt file=os.c line=588 start=1061 end=1061>
	<code>  struct buf *bp;</code>
</stmt>
<stmt file=os.c line=589 start=1061 end=1061>
	<code>  struct dinode *dip;</code>
</stmt>
<stmt file=os.c line=590 start=1061 end=1061>
	<code></code>
</stmt>
<stmt file=os.c line=591 start=1061 end=1068>
	<code>  bp = bread(ip->inum);</code>
	<emi>
		00001094  fffff801  ENT   0xfffffff8 (D -8)
		00001098  0000100e  LL    0x10 (D 16)
		0000109c  0000001c  LX  
		000010a0  0000009d  PSHA
		000010a4  fffa4c05  JSR   0xfffffa4c (TO 0xaf4)
		000010a8  00000801  ENT   0x8 (D 8)
		000010ac  00000440  SL    0x4 (D 4)
	</emi>
</stmt>
<stmt file=os.c line=592 start=1068 end=1071>
	<code>  dip = (struct dinode *)bp->data;</code>
	<emi>
		000010b0  0000040e  LL    0x4 (D 4)
		000010b4  0000101c  LX    0x10 (D 16)
		000010b8  00000040  SL    0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=593 start=1071 end=1075>
	<code>  dip->mode  = ip->mode;</code>
	<emi>
		000010bc  0000100e  LL    0x10 (D 16)
		000010c0  00000c1e  LXH   0xc (D 12)
		000010c4  00000026  LBL   0x0 (D 0)
		000010c8  0000004b  SXH 
	</emi>
</stmt>
<stmt file=os.c line=594 start=1075 end=1082>
	<code>  dip->nlink = ip->nlink;</code>
	<emi>
		000010cc  0000000e  LL    0x0 (D 0)
		000010d0  00000454  ADDI  0x4 (D 4)
		000010d4  0000009d  PSHA
		000010d8  0000180e  LL    0x18 (D 24)
		000010dc  0000101c  LX    0x10 (D 16)
		000010e0  000000a1  POPB
		000010e4  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=595 start=1082 end=1089>
	<code>  dip->size = ip->size;</code>
	<emi>
		000010e8  0000000e  LL    0x0 (D 0)
		000010ec  00000854  ADDI  0x8 (D 8)
		000010f0  0000009d  PSHA
		000010f4  0000180e  LL    0x18 (D 24)
		000010f8  0000141c  LX    0x14 (D 20)
		000010fc  000000a1  POPB
		00001100  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=596 start=1089 end=1089>
	<code>//  printf("iupdate() memcpy(dip->dir, ip->dir, %d)\n",sizeof(ip->dir));</code>
</stmt>
<stmt file=os.c line=597 start=1089 end=1098>
	<code>  memcpy(dip->dir, ip->dir, sizeof(ip->dir));</code>
	<emi>
		00001104  0007809e  PSHI  0x780 (D 1920)
		00001108  0000180e  LL    0x18 (D 24)
		0000110c  00001854  ADDI  0x18 (D 24)
		00001110  0000009d  PSHA
		00001114  0000100e  LL    0x10 (D 16)
		00001118  00005054  ADDI  0x50 (D 80)
		0000111c  0000009d  PSHA
		00001120  ffeedc05  JSR   0xffffeedc (TO 0x0)
		00001124  00001801  ENT   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=598 start=1098 end=1107>
	<code>  memcpy(dip->idir, ip->idir, sizeof(ip->idir));</code>
	<emi>
		00001128  0008009e  PSHI  0x800 (D 2048)
		0000112c  0000180e  LL    0x18 (D 24)
		00001130  00079854  ADDI  0x798 (D 1944)
		00001134  0000009d  PSHA
		00001138  0000100e  LL    0x10 (D 16)
		0000113c  0007d054  ADDI  0x7d0 (D 2000)
		00001140  0000009d  PSHA
		00001144  ffeeb805  JSR   0xffffeeb8 (TO 0x0)
		00001148  00001801  ENT   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=599 start=1107 end=1111>
	<code>  bwrite(bp);</code>
	<emi>
		0000114c  0000040e  LL    0x4 (D 4)
		00001150  0000009d  PSHA
		00001154  fff9e005  JSR   0xfffff9e0 (TO 0xb38)
		00001158  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=600 start=1111 end=1115>
	<code>  brelse(bp);</code>
	<emi>
		0000115c  0000040e  LL    0x4 (D 4)
		00001160  0000009d  PSHA
		00001164  fffa1805  JSR   0xfffffa18 (TO 0xb80)
		00001168  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=601 start=1115 end=1115>
	<code>}</code>
</stmt>
<stmt file=os.c line=602 start=1115 end=1115>
	<code></code>
</stmt>
<stmt file=os.c line=603 start=1115 end=1115>
	<code>// increment reference count for ip</code>
</stmt>
<stmt file=os.c line=604 start=1115 end=1116>
	<code>idup(struct inode *ip)</code>
	<emi>
		0000116c  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=605 start=1116 end=1116>
	<code>{</code>
</stmt>
<stmt file=os.c line=606 start=1116 end=1116>
	<code>  int e = splhi();</code>
</stmt>
<stmt file=os.c line=607 start=1116 end=1125>
	<code>  ip->ref++;</code>
	<emi>
		00001170  fffff801  ENT   0xfffffff8 (D -8)
		00001174  ffef2805  JSR   0xffffef28 (TO 0xa0)
		00001178  00000440  SL    0x4 (D 4)
		0000117c  0000100e  LL    0x10 (D 16)
		00001180  00000454  ADDI  0x4 (D 4)
		00001184  0000003e  LBA 
		00001188  0000001c  LX  
		0000118c  ffffff57  SUBI  0xffffffff (D -1)
		00001190  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=608 start=1125 end=1129>
	<code>  splx(e);</code>
	<emi>
		00001194  0000040e  LL    0x4 (D 4)
		00001198  0000009d  PSHA
		0000119c  ffef0805  JSR   0xffffef08 (TO 0xa8)
		000011a0  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=609 start=1129 end=1129>
	<code>}</code>
</stmt>
<stmt file=os.c line=610 start=1129 end=1129>
	<code></code>
</stmt>
<stmt file=os.c line=611 start=1129 end=1129>
	<code>// lock the given inode.  read the inode from disk if necessary</code>
</stmt>
<stmt file=os.c line=612 start=1129 end=1130>
	<code>ilock(struct inode *ip)</code>
	<emi>
		000011a4  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=613 start=1130 end=1130>
	<code>{</code>
</stmt>
<stmt file=os.c line=614 start=1130 end=1130>
	<code>  struct buf *bp;</code>
</stmt>
<stmt file=os.c line=615 start=1130 end=1130>
	<code>  struct dinode *dip;</code>
</stmt>
<stmt file=os.c line=616 start=1130 end=1130>
	<code>  int e = splhi();</code>
</stmt>
<stmt file=os.c line=617 start=1130 end=1130>
	<code></code>
</stmt>
<stmt file=os.c line=618 start=1130 end=1143>
	<code>  if (!ip || ip->ref < 1) panic("ilock");</code>
	<emi>
		000011a8  fffff001  ENT   0xfffffff0 (D -16)
		000011ac  ffeef005  JSR   0xffffeef0 (TO 0xa0)
		000011b0  00000440  SL    0x4 (D 4)
		000011b4  0000180e  LL    0x18 (D 24)
		000011b8  00000084  BZ    <fwd>
		000011bc  0000180e  LL    0x18 (D 24)
		000011c0  0000041c  LX    0x4 (D 4)
		000011c4  0000013b  LBI   0x1 (D 1)
		000011c8  0000008f  BGE   <fwd>
		000011cc  00010c08  LEAG  0x10c (D 268)
		000011d0  0000009d  PSHA
		000011d4  fff35c05  JSR   0xfffff35c (TO 0x534)
		000011d8  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=619 start=1143 end=1143>
	<code></code>
</stmt>
<stmt file=os.c line=620 start=1143 end=1148>
	<code>  while (ip->flags & I_BUSY) sleep(ip);</code>
	<emi>
		000011dc  00000003  JMP   <fwd>
		000011e0  0000180e  LL    0x18 (D 24)
		000011e4  0000009d  PSHA
		000011e8  000a5005  JSR   <fwd>
		000011ec  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=621 start=1148 end=1158>
	<code>  ip->flags |= I_BUSY;</code>
	<emi>
		000011f0  0000180e  LL    0x18 (D 24)
		000011f4  0000081c  LX    0x8 (D 8)
		000011f8  00000169  ANDI  0x1 (D 1)
		000011fc  00000086  BNZ   <fwd>
		00001200  0000180e  LL    0x18 (D 24)
		00001204  00000854  ADDI  0x8 (D 8)
		00001208  0000003e  LBA 
		0000120c  0000001c  LX  
		00001210  0000016c  ORI   0x1 (D 1)
		00001214  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=622 start=1158 end=1162>
	<code>  splx(e);</code>
	<emi>
		00001218  0000040e  LL    0x4 (D 4)
		0000121c  0000009d  PSHA
		00001220  ffee8405  JSR   0xffffee84 (TO 0xa8)
		00001224  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=623 start=1162 end=1162>
	<code>  </code>
</stmt>
<stmt file=os.c line=624 start=1162 end=1166>
	<code>  if (!(ip->flags & I_VALID)) {</code>
	<emi>
		00001228  0000180e  LL    0x18 (D 24)
		0000122c  0000081c  LX    0x8 (D 8)
		00001230  00000269  ANDI  0x2 (D 2)
		00001234  00000086  BNZ   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=625 start=1166 end=1172>
	<code>    bp = bread(ip->inum);</code>
	<emi>
		00001238  0000180e  LL    0x18 (D 24)
		0000123c  0000001c  LX  
		00001240  0000009d  PSHA
		00001244  fff8ac05  JSR   0xfffff8ac (TO 0xaf4)
		00001248  00000801  ENT   0x8 (D 8)
		0000124c  00000c40  SL    0xc (D 12)
	</emi>
</stmt>
<stmt file=os.c line=626 start=1172 end=1175>
	<code>    dip = (struct dinode *)bp->data;</code>
	<emi>
		00001250  00000c0e  LL    0xc (D 12)
		00001254  0000101c  LX    0x10 (D 16)
		00001258  00000840  SL    0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=627 start=1175 end=1182>
	<code>    ip->mode  = dip->mode;</code>
	<emi>
		0000125c  0000180e  LL    0x18 (D 24)
		00001260  00000c54  ADDI  0xc (D 12)
		00001264  0000009d  PSHA
		00001268  0000100e  LL    0x10 (D 16)
		0000126c  0000001e  LXH 
		00001270  000000a1  POPB
		00001274  0000004b  SXH 
	</emi>
</stmt>
<stmt file=os.c line=628 start=1182 end=1189>
	<code>    ip->nlink = dip->nlink;</code>
	<emi>
		00001278  0000180e  LL    0x18 (D 24)
		0000127c  00001054  ADDI  0x10 (D 16)
		00001280  0000009d  PSHA
		00001284  0000100e  LL    0x10 (D 16)
		00001288  0000041c  LX    0x4 (D 4)
		0000128c  000000a1  POPB
		00001290  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=629 start=1189 end=1196>
	<code>    ip->size = dip->size;</code>
	<emi>
		00001294  0000180e  LL    0x18 (D 24)
		00001298  00001454  ADDI  0x14 (D 20)
		0000129c  0000009d  PSHA
		000012a0  0000100e  LL    0x10 (D 16)
		000012a4  0000081c  LX    0x8 (D 8)
		000012a8  000000a1  POPB
		000012ac  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=630 start=1196 end=1205>
	<code>    memcpy(ip->dir,  dip->dir,  sizeof(ip->dir));</code>
	<emi>
		000012b0  0007809e  PSHI  0x780 (D 1920)
		000012b4  0000100e  LL    0x10 (D 16)
		000012b8  00005054  ADDI  0x50 (D 80)
		000012bc  0000009d  PSHA
		000012c0  0000280e  LL    0x28 (D 40)
		000012c4  00001854  ADDI  0x18 (D 24)
		000012c8  0000009d  PSHA
		000012cc  ffed3005  JSR   0xffffed30 (TO 0x0)
		000012d0  00001801  ENT   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=631 start=1205 end=1214>
	<code>    memcpy(ip->idir, dip->idir, sizeof(ip->idir));</code>
	<emi>
		000012d4  0008009e  PSHI  0x800 (D 2048)
		000012d8  0000100e  LL    0x10 (D 16)
		000012dc  0007d054  ADDI  0x7d0 (D 2000)
		000012e0  0000009d  PSHA
		000012e4  0000280e  LL    0x28 (D 40)
		000012e8  00079854  ADDI  0x798 (D 1944)
		000012ec  0000009d  PSHA
		000012f0  ffed0c05  JSR   0xffffed0c (TO 0x0)
		000012f4  00001801  ENT   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=632 start=1214 end=1218>
	<code>    brelse(bp);</code>
	<emi>
		000012f8  00000c0e  LL    0xc (D 12)
		000012fc  0000009d  PSHA
		00001300  fff87c05  JSR   0xfffff87c (TO 0xb80)
		00001304  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=633 start=1218 end=1224>
	<code>    ip->flags |= I_VALID;</code>
	<emi>
		00001308  0000180e  LL    0x18 (D 24)
		0000130c  00000854  ADDI  0x8 (D 8)
		00001310  0000003e  LBA 
		00001314  0000001c  LX  
		00001318  0000026c  ORI   0x2 (D 2)
		0000131c  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=634 start=1224 end=1231>
	<code>    if (!ip->mode) panic("ilock: no mode");</code>
	<emi>
		00001320  0000180e  LL    0x18 (D 24)
		00001324  00000c1e  LXH   0xc (D 12)
		00001328  00000086  BNZ   <fwd>
		0000132c  00011208  LEAG  0x112 (D 274)
		00001330  0000009d  PSHA
		00001334  fff1fc05  JSR   0xfffff1fc (TO 0x534)
		00001338  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=635 start=1231 end=1231>
	<code>  }</code>
</stmt>
<stmt file=os.c line=636 start=1231 end=1231>
	<code>}</code>
</stmt>
<stmt file=os.c line=637 start=1231 end=1231>
	<code></code>
</stmt>
<stmt file=os.c line=638 start=1231 end=1231>
	<code>// unlock the given inode</code>
</stmt>
<stmt file=os.c line=639 start=1231 end=1232>
	<code>iunlock(struct inode *ip)</code>
	<emi>
		0000133c  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=640 start=1232 end=1232>
	<code>{</code>
</stmt>
<stmt file=os.c line=641 start=1232 end=1232>
	<code>  int e = splhi();</code>
</stmt>
<stmt file=os.c line=642 start=1232 end=1249>
	<code>  if (!ip || !(ip->flags & I_BUSY) || ip->ref < 1) panic("iunlock");</code>
	<emi>
		00001340  fffff801  ENT   0xfffffff8 (D -8)
		00001344  ffed5805  JSR   0xffffed58 (TO 0xa0)
		00001348  00000440  SL    0x4 (D 4)
		0000134c  0000100e  LL    0x10 (D 16)
		00001350  00000084  BZ    <fwd>
		00001354  0000100e  LL    0x10 (D 16)
		00001358  0000081c  LX    0x8 (D 8)
		0000135c  00000169  ANDI  0x1 (D 1)
		00001360  00135084  BZ    <fwd>
		00001364  0000100e  LL    0x10 (D 16)
		00001368  0000041c  LX    0x4 (D 4)
		0000136c  0000013b  LBI   0x1 (D 1)
		00001370  0000008f  BGE   <fwd>
		00001374  00012108  LEAG  0x121 (D 289)
		00001378  0000009d  PSHA
		0000137c  fff1b405  JSR   0xfffff1b4 (TO 0x534)
		00001380  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=643 start=1249 end=1249>
	<code></code>
</stmt>
<stmt file=os.c line=644 start=1249 end=1255>
	<code>  ip->flags &= ~I_BUSY;</code>
	<emi>
		00001384  0000100e  LL    0x10 (D 16)
		00001388  00000854  ADDI  0x8 (D 8)
		0000138c  0000003e  LBA 
		00001390  0000001c  LX  
		00001394  fffffe69  ANDI  0xfffffffe (D -2)
		00001398  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=645 start=1255 end=1259>
	<code>  wakeup(ip);</code>
	<emi>
		0000139c  0000100e  LL    0x10 (D 16)
		000013a0  0000009d  PSHA
		000013a4  000c5005  JSR   <fwd>
		000013a8  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=646 start=1259 end=1263>
	<code>  splx(e);</code>
	<emi>
		000013ac  0000040e  LL    0x4 (D 4)
		000013b0  0000009d  PSHA
		000013b4  ffecf005  JSR   0xffffecf0 (TO 0xa8)
		000013b8  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=647 start=1263 end=1263>
	<code>}</code>
</stmt>
<stmt file=os.c line=648 start=1263 end=1263>
	<code></code>
</stmt>
<stmt file=os.c line=649 start=1263 end=1263>
	<code>// drop a reference to an in-memory inode</code>
</stmt>
<stmt file=os.c line=650 start=1263 end=1263>
	<code>// if that was the last reference, the inode cache entry can be recycled</code>
</stmt>
<stmt file=os.c line=651 start=1263 end=1263>
	<code>// if that was the last reference and the inode has no links</code>
</stmt>
<stmt file=os.c line=652 start=1263 end=1263>
	<code>// to it, free the inode (and its content) on disk</code>
</stmt>
<stmt file=os.c line=653 start=1263 end=1264>
	<code>iput(struct inode *ip)</code>
	<emi>
		000013bc  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=654 start=1264 end=1264>
	<code>{</code>
</stmt>
<stmt file=os.c line=655 start=1264 end=1264>
	<code>  int e = splhi();</code>
</stmt>
<stmt file=os.c line=656 start=1264 end=1278>
	<code>  if (ip->ref == 1 && (ip->flags & I_VALID) && !ip->nlink) {</code>
	<emi>
		000013c0  fffff801  ENT   0xfffffff8 (D -8)
		000013c4  ffecd805  JSR   0xffffecd8 (TO 0xa0)
		000013c8  00000440  SL    0x4 (D 4)
		000013cc  0000100e  LL    0x10 (D 16)
		000013d0  0000041c  LX    0x4 (D 4)
		000013d4  0000013b  LBI   0x1 (D 1)
		000013d8  0000008a  BNE   <fwd>
		000013dc  0000100e  LL    0x10 (D 16)
		000013e0  0000081c  LX    0x8 (D 8)
		000013e4  00000269  ANDI  0x2 (D 2)
		000013e8  0013d884  BZ    <fwd>
		000013ec  0000100e  LL    0x10 (D 16)
		000013f0  0000101c  LX    0x10 (D 16)
		000013f4  0013e886  BNZ   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=657 start=1278 end=1278>
	<code>    // inode has no links: truncate and free inode</code>
</stmt>
<stmt file=os.c line=658 start=1278 end=1286>
	<code>    if (ip->flags & I_BUSY) panic("iput busy");</code>
	<emi>
		000013f8  0000100e  LL    0x10 (D 16)
		000013fc  0000081c  LX    0x8 (D 8)
		00001400  00000169  ANDI  0x1 (D 1)
		00001404  00000084  BZ    <fwd>
		00001408  00012908  LEAG  0x129 (D 297)
		0000140c  0000009d  PSHA
		00001410  fff12005  JSR   0xfffff120 (TO 0x534)
		00001414  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=659 start=1286 end=1292>
	<code>    ip->flags |= I_BUSY;</code>
	<emi>
		00001418  0000100e  LL    0x10 (D 16)
		0000141c  00000854  ADDI  0x8 (D 8)
		00001420  0000003e  LBA 
		00001424  0000001c  LX  
		00001428  0000016c  ORI   0x1 (D 1)
		0000142c  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=660 start=1292 end=1296>
	<code>    splx(e);</code>
	<emi>
		00001430  0000040e  LL    0x4 (D 4)
		00001434  0000009d  PSHA
		00001438  ffec6c05  JSR   0xffffec6c (TO 0xa8)
		0000143c  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=661 start=1296 end=1300>
	<code>    itrunc(ip);</code>
	<emi>
		00001440  0000100e  LL    0x10 (D 16)
		00001444  0000009d  PSHA
		00001448  00000005  JSR   <fwd>
		0000144c  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=662 start=1300 end=1305>
	<code>    ip->mode = 0;</code>
	<emi>
		00001450  0000100e  LL    0x10 (D 16)
		00001454  00000c54  ADDI  0xc (D 12)
		00001458  0000003e  LBA 
		0000145c  00000023  LI    0x0 (D 0)
		00001460  0000004b  SXH 
	</emi>
</stmt>
<stmt file=os.c line=663 start=1305 end=1310>
	<code>    bfree(ip->inum); </code>
	<emi>
		00001464  0000100e  LL    0x10 (D 16)
		00001468  0000001c  LX  
		0000146c  0000009d  PSHA
		00001470  fff9b005  JSR   0xfffff9b0 (TO 0xe24)
		00001474  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=664 start=1310 end=1312>
	<code>    e = splhi();</code>
	<emi>
		00001478  ffec2405  JSR   0xffffec24 (TO 0xa0)
		0000147c  00000440  SL    0x4 (D 4)
	</emi>
</stmt>
<stmt file=os.c line=665 start=1312 end=1317>
	<code>    ip->flags = 0;</code>
	<emi>
		00001480  0000100e  LL    0x10 (D 16)
		00001484  00000854  ADDI  0x8 (D 8)
		00001488  0000003e  LBA 
		0000148c  00000023  LI    0x0 (D 0)
		00001490  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=666 start=1317 end=1321>
	<code>    wakeup(ip);</code>
	<emi>
		00001494  0000100e  LL    0x10 (D 16)
		00001498  0000009d  PSHA
		0000149c  0013a405  JSR   <fwd>
		000014a0  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=667 start=1321 end=1321>
	<code>  }</code>
</stmt>
<stmt file=os.c line=668 start=1321 end=1327>
	<code>  ip->ref--;</code>
	<emi>
		000014a4  0000100e  LL    0x10 (D 16)
		000014a8  00000454  ADDI  0x4 (D 4)
		000014ac  0000003e  LBA 
		000014b0  0000001c  LX  
		000014b4  00000157  SUBI  0x1 (D 1)
		000014b8  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=669 start=1327 end=1331>
	<code>  splx(e);</code>
	<emi>
		000014bc  0000040e  LL    0x4 (D 4)
		000014c0  0000009d  PSHA
		000014c4  ffebe005  JSR   0xffffebe0 (TO 0xa8)
		000014c8  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=670 start=1331 end=1331>
	<code>}</code>
</stmt>
<stmt file=os.c line=671 start=1331 end=1331>
	<code></code>
</stmt>
<stmt file=os.c line=672 start=1331 end=1331>
	<code>// common idiom: unlock, then put</code>
</stmt>
<stmt file=os.c line=673 start=1331 end=1332>
	<code>iunlockput(struct inode *ip)</code>
	<emi>
		000014cc  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=674 start=1332 end=1332>
	<code>{</code>
</stmt>
<stmt file=os.c line=675 start=1332 end=1336>
	<code>  iunlock(ip);</code>
	<emi>
		000014d0  0000080e  LL    0x8 (D 8)
		000014d4  0000009d  PSHA
		000014d8  fffe6405  JSR   0xfffffe64 (TO 0x1340)
		000014dc  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=676 start=1336 end=1340>
	<code>  iput(ip);</code>
	<emi>
		000014e0  0000080e  LL    0x8 (D 8)
		000014e4  0000009d  PSHA
		000014e8  fffed405  JSR   0xfffffed4 (TO 0x13c0)
		000014ec  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=677 start=1340 end=1340>
	<code>}</code>
</stmt>
<stmt file=os.c line=678 start=1340 end=1340>
	<code></code>
</stmt>
<stmt file=os.c line=679 start=1340 end=1340>
	<code>// Inode contents:</code>
</stmt>
<stmt file=os.c line=680 start=1340 end=1340>
	<code>// The contents (data) associated with each inode is stored in a sequence of blocks on the disk.</code>
</stmt>
<stmt file=os.c line=681 start=1340 end=1340>
	<code>// The first NDIR blocks are listed in ip->dir[].  The next NIDIR blocks are listed in the block ip->idir[].</code>
</stmt>
<stmt file=os.c line=682 start=1340 end=1340>
	<code>// Return the disk block address of the nth block in inode ip. If there is no such block, bmap allocates one.</code>
</stmt>
<stmt file=os.c line=683 start=1340 end=1341>
	<code>uint bmap(struct inode *ip, uint bn)</code>
	<emi>
		000014f0  00000002  LEV   0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=684 start=1341 end=1341>
	<code>{</code>
</stmt>
<stmt file=os.c line=685 start=1341 end=1341>
	<code>  uint addr, *a;</code>
</stmt>
<stmt file=os.c line=686 start=1341 end=1341>
	<code>  struct buf *bp;</code>
</stmt>
<stmt file=os.c line=687 start=1341 end=1341>
	<code></code>
</stmt>
<stmt file=os.c line=688 start=1341 end=1345>
	<code>  if (bn < NDIR) {</code>
	<emi>
		000014f4  fffff001  ENT   0xfffffff0 (D -16)
		000014f8  0000200e  LL    0x20 (D 32)
		000014fc  0001e03b  LBI   0x1e0 (D 480)
		00001500  00000090  BGEU  <fwd>
	</emi>
</stmt>
<stmt file=os.c line=689 start=1345 end=1367>
	<code>    if (!(addr = ip->dir[bn])) ip->dir[bn] = addr = balloc();</code>
	<emi>
		00001504  0000180e  LL    0x18 (D 24)
		00001508  00001854  ADDI  0x18 (D 24)
		0000150c  0000009d  PSHA
		00001510  0000280e  LL    0x28 (D 40)
		00001514  0000045a  MULI  0x4 (D 4)
		00001518  000000a1  POPB
		0000151c  00000053  ADD 
		00001520  0000001c  LX  
		00001524  00000c40  SL    0xc (D 12)
		00001528  00000086  BNZ   <fwd>
		0000152c  0000180e  LL    0x18 (D 24)
		00001530  00001854  ADDI  0x18 (D 24)
		00001534  0000009d  PSHA
		00001538  0000280e  LL    0x28 (D 40)
		0000153c  0000045a  MULI  0x4 (D 4)
		00001540  000000a1  POPB
		00001544  00000053  ADD 
		00001548  0000009d  PSHA
		0000154c  fff77405  JSR   0xfffff774 (TO 0xcc4)
		00001550  00001440  SL    0x14 (D 20)
		00001554  000000a1  POPB
		00001558  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=690 start=1367 end=1369>
	<code>    return addr;</code>
	<emi>
		0000155c  00000c0e  LL    0xc (D 12)
		00001560  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=691 start=1369 end=1369>
	<code>  }</code>
</stmt>
<stmt file=os.c line=692 start=1369 end=1372>
	<code>  bn -= NDIR;</code>
	<emi>
		00001564  0000200e  LL    0x20 (D 32)
		00001568  0001e057  SUBI  0x1e0 (D 480)
		0000156c  00002040  SL    0x20 (D 32)
	</emi>
</stmt>
<stmt file=os.c line=693 start=1372 end=1379>
	<code>  if (bn >= NIDIR * 1024) panic("bmap: out of range");</code>
	<emi>
		00001570  0000200e  LL    0x20 (D 32)
		00001574  0800003b  LBI   0x80000 (D 524288)
		00001578  0000008d  BLTU  <fwd>
		0000157c  00013308  LEAG  0x133 (D 307)
		00001580  0000009d  PSHA
		00001584  ffefac05  JSR   0xffffefac (TO 0x534)
		00001588  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=694 start=1379 end=1379>
	<code></code>
</stmt>
<stmt file=os.c line=695 start=1379 end=1379>
	<code>  // load indirect block, allocating if necessary</code>
</stmt>
<stmt file=os.c line=696 start=1379 end=1403>
	<code>  if (!(addr = ip->idir[bn / 1024])) ip->idir[bn / 1024] = addr = balloc();</code>
	<emi>
		0000158c  0000180e  LL    0x18 (D 24)
		00001590  00079854  ADDI  0x798 (D 1944)
		00001594  0000009d  PSHA
		00001598  0000280e  LL    0x28 (D 40)
		0000159c  00040060  DVUI  0x400 (D 1024)
		000015a0  0000045a  MULI  0x4 (D 4)
		000015a4  000000a1  POPB
		000015a8  00000053  ADD 
		000015ac  0000001c  LX  
		000015b0  00000c40  SL    0xc (D 12)
		000015b4  00000086  BNZ   <fwd>
		000015b8  0000180e  LL    0x18 (D 24)
		000015bc  00079854  ADDI  0x798 (D 1944)
		000015c0  0000009d  PSHA
		000015c4  0000280e  LL    0x28 (D 40)
		000015c8  00040060  DVUI  0x400 (D 1024)
		000015cc  0000045a  MULI  0x4 (D 4)
		000015d0  000000a1  POPB
		000015d4  00000053  ADD 
		000015d8  0000009d  PSHA
		000015dc  fff6e405  JSR   0xfffff6e4 (TO 0xcc4)
		000015e0  00001440  SL    0x14 (D 20)
		000015e4  000000a1  POPB
		000015e8  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=697 start=1403 end=1408>
	<code>  bp = bread(addr);</code>
	<emi>
		000015ec  00000c0e  LL    0xc (D 12)
		000015f0  0000009d  PSHA
		000015f4  fff4fc05  JSR   0xfffff4fc (TO 0xaf4)
		000015f8  00000801  ENT   0x8 (D 8)
		000015fc  00000440  SL    0x4 (D 4)
	</emi>
</stmt>
<stmt file=os.c line=698 start=1408 end=1411>
	<code>  a = (uint *)bp->data;</code>
	<emi>
		00001600  0000040e  LL    0x4 (D 4)
		00001604  0000101c  LX    0x10 (D 16)
		00001608  00000840  SL    0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=699 start=1411 end=1418>
	<code>  if (!(addr = a[bn & 1023])) {</code>
	<emi>
		0000160c  0000200e  LL    0x20 (D 32)
		00001610  0003ff69  ANDI  0x3ff (D 1023)
		00001614  0000045a  MULI  0x4 (D 4)
		00001618  00000855  ADDL  0x8 (D 8)
		0000161c  0000001c  LX  
		00001620  00000c40  SL    0xc (D 12)
		00001624  00000086  BNZ   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=700 start=1418 end=1427>
	<code>    a[bn & 1023] = addr = balloc();</code>
	<emi>
		00001628  0000200e  LL    0x20 (D 32)
		0000162c  0003ff69  ANDI  0x3ff (D 1023)
		00001630  0000045a  MULI  0x4 (D 4)
		00001634  00000855  ADDL  0x8 (D 8)
		00001638  0000009d  PSHA
		0000163c  fff68405  JSR   0xfffff684 (TO 0xcc4)
		00001640  00001440  SL    0x14 (D 20)
		00001644  000000a1  POPB
		00001648  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=701 start=1427 end=1431>
	<code>    bwrite(bp);</code>
	<emi>
		0000164c  0000040e  LL    0x4 (D 4)
		00001650  0000009d  PSHA
		00001654  fff4e005  JSR   0xfffff4e0 (TO 0xb38)
		00001658  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=702 start=1431 end=1431>
	<code>  }</code>
</stmt>
<stmt file=os.c line=703 start=1431 end=1435>
	<code>  brelse(bp);</code>
	<emi>
		0000165c  0000040e  LL    0x4 (D 4)
		00001660  0000009d  PSHA
		00001664  fff51805  JSR   0xfffff518 (TO 0xb80)
		00001668  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=704 start=1435 end=1437>
	<code>  return addr;</code>
	<emi>
		0000166c  00000c0e  LL    0xc (D 12)
		00001670  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=705 start=1437 end=1437>
	<code>}</code>
</stmt>
<stmt file=os.c line=706 start=1437 end=1437>
	<code></code>
</stmt>
<stmt file=os.c line=707 start=1437 end=1437>
	<code>// truncate inode (discard contents)</code>
</stmt>
<stmt file=os.c line=708 start=1437 end=1437>
	<code>// only called when the inode has no links to it (no directory entries referring to it)</code>
</stmt>
<stmt file=os.c line=709 start=1437 end=1437>
	<code>// and has no in-memory reference to it (is not an open file or current directory)</code>
</stmt>
<stmt file=os.c line=710 start=1437 end=1438>
	<code>itrunc(struct inode *ip)</code>
	<emi>
		00001674  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=711 start=1438 end=1438>
	<code>{</code>
</stmt>
<stmt file=os.c line=712 start=1438 end=1438>
	<code>  int i, j;</code>
</stmt>
<stmt file=os.c line=713 start=1438 end=1438>
	<code>  struct buf *bp;</code>
</stmt>
<stmt file=os.c line=714 start=1438 end=1438>
	<code>  uint *a;</code>
</stmt>
<stmt file=os.c line=715 start=1438 end=1438>
	<code></code>
</stmt>
<stmt file=os.c line=716 start=1438 end=1442>
	<code>  for (i = 0; i < NDIR; i++) {</code>
	<emi>
		00001678  fffff001  ENT   0xfffffff0 (D -16)
		0000167c  00000023  LI    0x0 (D 0)
		00001680  00000c40  SL    0xc (D 12)
		00001684  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=717 start=1442 end=1452>
	<code>    if (!ip->dir[i]) goto done;  // XXX done by ip->size?</code>
	<emi>
		00001688  0000180e  LL    0x18 (D 24)
		0000168c  00001854  ADDI  0x18 (D 24)
		00001690  0000009d  PSHA
		00001694  0000140e  LL    0x14 (D 20)
		00001698  0000045a  MULI  0x4 (D 4)
		0000169c  000000a1  POPB
		000016a0  00000053  ADD 
		000016a4  0000001c  LX  
		000016a8  00000086  BNZ   <fwd>
		000016ac  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=718 start=1452 end=1463>
	<code>    bfree(ip->dir[i]);</code>
	<emi>
		000016b0  0000180e  LL    0x18 (D 24)
		000016b4  00001854  ADDI  0x18 (D 24)
		000016b8  0000009d  PSHA
		000016bc  0000140e  LL    0x14 (D 20)
		000016c0  0000045a  MULI  0x4 (D 4)
		000016c4  000000a1  POPB
		000016c8  00000053  ADD 
		000016cc  0000001c  LX  
		000016d0  0000009d  PSHA
		000016d4  fff74c05  JSR   0xfffff74c (TO 0xe24)
		000016d8  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=719 start=1463 end=1473>
	<code>    ip->dir[i] = 0;</code>
	<emi>
		000016dc  0000180e  LL    0x18 (D 24)
		000016e0  00001854  ADDI  0x18 (D 24)
		000016e4  0000009d  PSHA
		000016e8  0000140e  LL    0x14 (D 20)
		000016ec  0000045a  MULI  0x4 (D 4)
		000016f0  000000a1  POPB
		000016f4  00000053  ADD 
		000016f8  0000003e  LBA 
		000016fc  00000023  LI    0x0 (D 0)
		00001700  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=720 start=1473 end=1473>
	<code>  }</code>
</stmt>
<stmt file=os.c line=721 start=1473 end=1473>
	<code>  </code>
</stmt>
<stmt file=os.c line=722 start=1473 end=1482>
	<code>  for (i = 0; i < NIDIR; i++) {</code>
	<emi>
		00001704  00000c0e  LL    0xc (D 12)
		00001708  ffffff57  SUBI  0xffffffff (D -1)
		0000170c  00000c40  SL    0xc (D 12)
		00001710  00000c0e  LL    0xc (D 12)
		00001714  0001e03b  LBI   0x1e0 (D 480)
		00001718  0000008c  BLT   <fwd>
		0000171c  00000023  LI    0x0 (D 0)
		00001720  00000c40  SL    0xc (D 12)
		00001724  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=723 start=1482 end=1492>
	<code>    if (!ip->idir[i]) break;</code>
	<emi>
		00001728  0000180e  LL    0x18 (D 24)
		0000172c  00079854  ADDI  0x798 (D 1944)
		00001730  0000009d  PSHA
		00001734  0000140e  LL    0x14 (D 20)
		00001738  0000045a  MULI  0x4 (D 4)
		0000173c  000000a1  POPB
		00001740  00000053  ADD 
		00001744  0000001c  LX  
		00001748  00000086  BNZ   <fwd>
		0000174c  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=724 start=1492 end=1504>
	<code>    bp = bread(ip->idir[i]);</code>
	<emi>
		00001750  0000180e  LL    0x18 (D 24)
		00001754  00079854  ADDI  0x798 (D 1944)
		00001758  0000009d  PSHA
		0000175c  0000140e  LL    0x14 (D 20)
		00001760  0000045a  MULI  0x4 (D 4)
		00001764  000000a1  POPB
		00001768  00000053  ADD 
		0000176c  0000001c  LX  
		00001770  0000009d  PSHA
		00001774  fff37c05  JSR   0xfffff37c (TO 0xaf4)
		00001778  00000801  ENT   0x8 (D 8)
		0000177c  00000440  SL    0x4 (D 4)
	</emi>
</stmt>
<stmt file=os.c line=725 start=1504 end=1507>
	<code>    a = (uint *)bp->data;</code>
	<emi>
		00001780  0000040e  LL    0x4 (D 4)
		00001784  0000101c  LX    0x10 (D 16)
		00001788  00000040  SL    0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=726 start=1507 end=1510>
	<code>    for (j = 0; j < 1024; j++) {</code>
	<emi>
		0000178c  00000023  LI    0x0 (D 0)
		00001790  00000840  SL    0x8 (D 8)
		00001794  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=727 start=1510 end=1516>
	<code>      if (!a[j]) break;</code>
	<emi>
		00001798  0000080e  LL    0x8 (D 8)
		0000179c  0000045a  MULI  0x4 (D 4)
		000017a0  00000055  ADDL  0x0 (D 0)
		000017a4  0000001c  LX  
		000017a8  00000086  BNZ   <fwd>
		000017ac  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=728 start=1516 end=1523>
	<code>      bfree(a[j]);</code>
	<emi>
		000017b0  0000080e  LL    0x8 (D 8)
		000017b4  0000045a  MULI  0x4 (D 4)
		000017b8  00000055  ADDL  0x0 (D 0)
		000017bc  0000001c  LX  
		000017c0  0000009d  PSHA
		000017c4  fff65c05  JSR   0xfffff65c (TO 0xe24)
		000017c8  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=729 start=1523 end=1523>
	<code>    }</code>
</stmt>
<stmt file=os.c line=730 start=1523 end=1533>
	<code>    brelse(bp);</code>
	<emi>
		000017cc  0000080e  LL    0x8 (D 8)
		000017d0  ffffff57  SUBI  0xffffffff (D -1)
		000017d4  00000840  SL    0x8 (D 8)
		000017d8  0000080e  LL    0x8 (D 8)
		000017dc  0004003b  LBI   0x400 (D 1024)
		000017e0  0000008c  BLT   <fwd>
		000017e4  0000040e  LL    0x4 (D 4)
		000017e8  0000009d  PSHA
		000017ec  fff39005  JSR   0xfffff390 (TO 0xb80)
		000017f0  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=731 start=1533 end=1544>
	<code>    bfree(ip->idir[i]);</code>
	<emi>
		000017f4  0000180e  LL    0x18 (D 24)
		000017f8  00079854  ADDI  0x798 (D 1944)
		000017fc  0000009d  PSHA
		00001800  0000140e  LL    0x14 (D 20)
		00001804  0000045a  MULI  0x4 (D 4)
		00001808  000000a1  POPB
		0000180c  00000053  ADD 
		00001810  0000001c  LX  
		00001814  0000009d  PSHA
		00001818  fff60805  JSR   0xfffff608 (TO 0xe24)
		0000181c  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=732 start=1544 end=1554>
	<code>    ip->idir[i] = 0;</code>
	<emi>
		00001820  0000180e  LL    0x18 (D 24)
		00001824  00079854  ADDI  0x798 (D 1944)
		00001828  0000009d  PSHA
		0000182c  0000140e  LL    0x14 (D 20)
		00001830  0000045a  MULI  0x4 (D 4)
		00001834  000000a1  POPB
		00001838  00000053  ADD 
		0000183c  0000003e  LBA 
		00001840  00000023  LI    0x0 (D 0)
		00001844  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=733 start=1554 end=1554>
	<code>  }</code>
</stmt>
<stmt file=os.c line=734 start=1554 end=1554>
	<code></code>
</stmt>
<stmt file=os.c line=735 start=1554 end=1560>
	<code>done:</code>
	<emi>
		00001848  00000c0e  LL    0xc (D 12)
		0000184c  ffffff57  SUBI  0xffffffff (D -1)
		00001850  00000c40  SL    0xc (D 12)
		00001854  00000c0e  LL    0xc (D 12)
		00001858  0002003b  LBI   0x200 (D 512)
		0000185c  0000008c  BLT   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=736 start=1560 end=1565>
	<code>  ip->size = 0;</code>
	<emi>
		00001860  0000180e  LL    0x18 (D 24)
		00001864  00001454  ADDI  0x14 (D 20)
		00001868  0000003e  LBA 
		0000186c  00000023  LI    0x0 (D 0)
		00001870  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=737 start=1565 end=1569>
	<code>  iupdate(ip);</code>
	<emi>
		00001874  0000180e  LL    0x18 (D 24)
		00001878  0000009d  PSHA
		0000187c  fff81405  JSR   0xfffff814 (TO 0x1094)
		00001880  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=738 start=1569 end=1569>
	<code>}</code>
</stmt>
<stmt file=os.c line=739 start=1569 end=1569>
	<code></code>
</stmt>
<stmt file=os.c line=740 start=1569 end=1569>
	<code>// copy stat information from inode</code>
</stmt>
<stmt file=os.c line=741 start=1569 end=1570>
	<code>stati(struct inode *ip, struct stat *st)</code>
	<emi>
		00001884  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=742 start=1570 end=1570>
	<code>{</code>
</stmt>
<stmt file=os.c line=743 start=1570 end=1573>
	<code>  st->st_dev   = 0; // XXX</code>
	<emi>
		00001888  00000023  LI    0x0 (D 0)
		0000188c  00001026  LBL   0x10 (D 16)
		00001890  0000004b  SXH 
	</emi>
</stmt>
<stmt file=os.c line=744 start=1573 end=1580>
	<code>  st->st_mode  = ip->mode;</code>
	<emi>
		00001894  0000100e  LL    0x10 (D 16)
		00001898  00000254  ADDI  0x2 (D 2)
		0000189c  0000009d  PSHA
		000018a0  0000100e  LL    0x10 (D 16)
		000018a4  00000c1e  LXH   0xc (D 12)
		000018a8  000000a1  POPB
		000018ac  0000004b  SXH 
	</emi>
</stmt>
<stmt file=os.c line=745 start=1580 end=1587>
	<code>  st->st_ino   = ip->inum;</code>
	<emi>
		000018b0  0000100e  LL    0x10 (D 16)
		000018b4  00000454  ADDI  0x4 (D 4)
		000018b8  0000009d  PSHA
		000018bc  0000100e  LL    0x10 (D 16)
		000018c0  0000001c  LX  
		000018c4  000000a1  POPB
		000018c8  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=746 start=1587 end=1594>
	<code>  st->st_nlink = ip->nlink;</code>
	<emi>
		000018cc  0000100e  LL    0x10 (D 16)
		000018d0  00000854  ADDI  0x8 (D 8)
		000018d4  0000009d  PSHA
		000018d8  0000100e  LL    0x10 (D 16)
		000018dc  0000101c  LX    0x10 (D 16)
		000018e0  000000a1  POPB
		000018e4  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=747 start=1594 end=1601>
	<code>  st->st_size  = ip->size;</code>
	<emi>
		000018e8  0000100e  LL    0x10 (D 16)
		000018ec  00000c54  ADDI  0xc (D 12)
		000018f0  0000009d  PSHA
		000018f4  0000100e  LL    0x10 (D 16)
		000018f8  0000141c  LX    0x14 (D 20)
		000018fc  000000a1  POPB
		00001900  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=748 start=1601 end=1601>
	<code>}</code>
</stmt>
<stmt file=os.c line=749 start=1601 end=1601>
	<code></code>
</stmt>
<stmt file=os.c line=750 start=1601 end=1601>
	<code>// read data from inode</code>
</stmt>
<stmt file=os.c line=751 start=1601 end=1602>
	<code>int readi(struct inode *ip, char *dst, uint off, uint n)</code>
	<emi>
		00001904  00000002  LEV   0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=752 start=1602 end=1602>
	<code>{</code>
</stmt>
<stmt file=os.c line=753 start=1602 end=1602>
	<code>  uint tot, m;</code>
</stmt>
<stmt file=os.c line=754 start=1602 end=1602>
	<code>  struct buf *bp;</code>
</stmt>
<stmt file=os.c line=755 start=1602 end=1602>
	<code></code>
</stmt>
<stmt file=os.c line=756 start=1602 end=1608>
	<code>  if ((ip->mode & S_IFMT) == S_IFCHR) { // S_IFBLK ??</code>
	<emi>
		00001908  fffff001  ENT   0xfffffff0 (D -16)
		0000190c  0000180e  LL    0x18 (D 24)
		00001910  00000c1e  LXH   0xc (D 12)
		00001914  00f00069  ANDI  0xf000 (D 61440)
		00001918  0020003b  LBI   0x2000 (D 8192)
		0000191c  0000008a  BNE   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=757 start=1608 end=1608>
	<code>//    if (ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read) return -1;</code>
</stmt>
<stmt file=os.c line=758 start=1608 end=1608>
	<code>//    return devsw[ip->major].read(ip, dst, n);</code>
</stmt>
<stmt file=os.c line=759 start=1608 end=1623>
	<code>    if (ip->dir[0] >= NDEV || !devsw[ip->dir[0]].read) return -1; // XXX refactor</code>
	<emi>
		00001920  0000180e  LL    0x18 (D 24)
		00001924  0000181c  LX    0x18 (D 24)
		00001928  00000a3b  LBI   0xa (D 10)
		0000192c  00000090  BGEU  <fwd>
		00001930  00211808  LEAG  0x2118 (D 8472)
		00001934  0000009d  PSHA
		00001938  0000200e  LL    0x20 (D 32)
		0000193c  0000181c  LX    0x18 (D 24)
		00001940  0000085a  MULI  0x8 (D 8)
		00001944  000000a1  POPB
		00001948  00000053  ADD 
		0000194c  0000001c  LX  
		00001950  00000086  BNZ   <fwd>
		00001954  ffffff23  LI    0xffffffff (D -1)
		00001958  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=760 start=1623 end=1640>
	<code>    return devsw[ip->dir[0]].read(ip, dst, n);</code>
	<emi>
		0000195c  0000300e  LL    0x30 (D 48)
		00001960  0000009d  PSHA
		00001964  0000280e  LL    0x28 (D 40)
		00001968  0000009d  PSHA
		0000196c  0000280e  LL    0x28 (D 40)
		00001970  0000009d  PSHA
		00001974  00211808  LEAG  0x2118 (D 8472)
		00001978  0000009d  PSHA
		0000197c  0000380e  LL    0x38 (D 56)
		00001980  0000181c  LX    0x18 (D 24)
		00001984  0000085a  MULI  0x8 (D 8)
		00001988  000000a1  POPB
		0000198c  00000053  ADD 
		00001990  0000001c  LX  
		00001994  00000006  JSRA
		00001998  00001801  ENT   0x18 (D 24)
		0000199c  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=761 start=1640 end=1640>
	<code>  }</code>
</stmt>
<stmt file=os.c line=762 start=1640 end=1640>
	<code></code>
</stmt>
<stmt file=os.c line=763 start=1640 end=1650>
	<code>  if (off > ip->size || off + n < off) return -1;</code>
	<emi>
		000019a0  0000180e  LL    0x18 (D 24)
		000019a4  0000141c  LX    0x14 (D 20)
		000019a8  00002826  LBL   0x28 (D 40)
		000019ac  0000008d  BLTU  <fwd>
		000019b0  0000280e  LL    0x28 (D 40)
		000019b4  00003055  ADDL  0x30 (D 48)
		000019b8  00002826  LBL   0x28 (D 40)
		000019bc  00000090  BGEU  <fwd>
		000019c0  ffffff23  LI    0xffffffff (D -1)
		000019c4  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=764 start=1650 end=1661>
	<code>  if (off + n > ip->size) n = ip->size - off;</code>
	<emi>
		000019c8  0000280e  LL    0x28 (D 40)
		000019cc  00003055  ADDL  0x30 (D 48)
		000019d0  0000009d  PSHA
		000019d4  0000200e  LL    0x20 (D 32)
		000019d8  0000141c  LX    0x14 (D 20)
		000019dc  000000a1  POPB
		000019e0  00000090  BGEU  <fwd>
		000019e4  0000180e  LL    0x18 (D 24)
		000019e8  0000141c  LX    0x14 (D 20)
		000019ec  00002858  SUBL  0x28 (D 40)
		000019f0  00003040  SL    0x30 (D 48)
	</emi>
</stmt>
<stmt file=os.c line=765 start=1661 end=1661>
	<code></code>
</stmt>
<stmt file=os.c line=766 start=1661 end=1664>
	<code>  for (tot = n; tot; tot -= m, off += m, dst += m) {</code>
	<emi>
		000019f4  0000300e  LL    0x30 (D 48)
		000019f8  00000c40  SL    0xc (D 12)
		000019fc  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=767 start=1664 end=1675>
	<code>    bp = bread(bmap(ip, off/PAGE));</code>
	<emi>
		00001a00  0000280e  LL    0x28 (D 40)
		00001a04  00100060  DVUI  0x1000 (D 4096)
		00001a08  0000009d  PSHA
		00001a0c  0000200e  LL    0x20 (D 32)
		00001a10  0000009d  PSHA
		00001a14  fffadc05  JSR   0xfffffadc (TO 0x14f4)
		00001a18  00001001  ENT   0x10 (D 16)
		00001a1c  0000009d  PSHA
		00001a20  fff0d005  JSR   0xfffff0d0 (TO 0xaf4)
		00001a24  00000801  ENT   0x8 (D 8)
		00001a28  00000440  SL    0x4 (D 4)
	</emi>
</stmt>
<stmt file=os.c line=768 start=1675 end=1686>
	<code>    if ((m = PAGE - off%PAGE) > tot) m = tot;</code>
	<emi>
		00001a2c  0000280e  LL    0x28 (D 40)
		00001a30  00100066  MDUI  0x1000 (D 4096)
		00001a34  0000003e  LBA 
		00001a38  00100023  LI    0x1000 (D 4096)
		00001a3c  00000056  SUB 
		00001a40  00000840  SL    0x8 (D 8)
		00001a44  0000003e  LBA 
		00001a48  00000c0e  LL    0xc (D 12)
		00001a4c  00000090  BGEU  <fwd>
		00001a50  00000c0e  LL    0xc (D 12)
		00001a54  00000840  SL    0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=769 start=1686 end=1700>
	<code>    memcpy(dst, bp->data + off%PAGE, m);</code>
	<emi>
		00001a58  0000080e  LL    0x8 (D 8)
		00001a5c  0000009d  PSHA
		00001a60  00000c0e  LL    0xc (D 12)
		00001a64  0000101c  LX    0x10 (D 16)
		00001a68  0000009d  PSHA
		00001a6c  0000380e  LL    0x38 (D 56)
		00001a70  00100066  MDUI  0x1000 (D 4096)
		00001a74  000000a1  POPB
		00001a78  00000053  ADD 
		00001a7c  0000009d  PSHA
		00001a80  0000300e  LL    0x30 (D 48)
		00001a84  0000009d  PSHA
		00001a88  ffe57405  JSR   0xffffe574 (TO 0x0)
		00001a8c  00001801  ENT   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=770 start=1700 end=1704>
	<code>    brelse(bp);</code>
	<emi>
		00001a90  0000040e  LL    0x4 (D 4)
		00001a94  0000009d  PSHA
		00001a98  fff0e405  JSR   0xfffff0e4 (TO 0xb80)
		00001a9c  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=771 start=1704 end=1704>
	<code>  }</code>
</stmt>
<stmt file=os.c line=772 start=1704 end=1717>
	<code>  return n;</code>
	<emi>
		00001aa0  00000c0e  LL    0xc (D 12)
		00001aa4  00000858  SUBL  0x8 (D 8)
		00001aa8  00000c40  SL    0xc (D 12)
		00001aac  0000280e  LL    0x28 (D 40)
		00001ab0  00000855  ADDL  0x8 (D 8)
		00001ab4  00002840  SL    0x28 (D 40)
		00001ab8  0000200e  LL    0x20 (D 32)
		00001abc  00000855  ADDL  0x8 (D 8)
		00001ac0  00002040  SL    0x20 (D 32)
		00001ac4  00000c0e  LL    0xc (D 12)
		00001ac8  00000086  BNZ   <fwd>
		00001acc  0000300e  LL    0x30 (D 48)
		00001ad0  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=773 start=1717 end=1717>
	<code>}</code>
</stmt>
<stmt file=os.c line=774 start=1717 end=1717>
	<code></code>
</stmt>
<stmt file=os.c line=775 start=1717 end=1717>
	<code>// write data to inode</code>
</stmt>
<stmt file=os.c line=776 start=1717 end=1718>
	<code>int writei(struct inode *ip, char *src, uint off, uint n)</code>
	<emi>
		00001ad4  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=777 start=1718 end=1718>
	<code>{</code>
</stmt>
<stmt file=os.c line=778 start=1718 end=1718>
	<code>  uint tot, m;</code>
</stmt>
<stmt file=os.c line=779 start=1718 end=1718>
	<code>  struct buf *bp;</code>
</stmt>
<stmt file=os.c line=780 start=1718 end=1718>
	<code></code>
</stmt>
<stmt file=os.c line=781 start=1718 end=1724>
	<code>  if ((ip->mode & S_IFMT) == S_IFCHR) { // XXX S_IFBLK ??</code>
	<emi>
		00001ad8  fffff001  ENT   0xfffffff0 (D -16)
		00001adc  0000180e  LL    0x18 (D 24)
		00001ae0  00000c1e  LXH   0xc (D 12)
		00001ae4  00f00069  ANDI  0xf000 (D 61440)
		00001ae8  0020003b  LBI   0x2000 (D 8192)
		00001aec  0000008a  BNE   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=782 start=1724 end=1724>
	<code>//    if (ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write) return -1;</code>
</stmt>
<stmt file=os.c line=783 start=1724 end=1724>
	<code>//    return devsw[ip->major].write(ip, src, n);</code>
</stmt>
<stmt file=os.c line=784 start=1724 end=1739>
	<code>    if (ip->dir[0] >= NDEV || !devsw[ip->dir[0]].write) return -1; // XXX refactor</code>
	<emi>
		00001af0  0000180e  LL    0x18 (D 24)
		00001af4  0000181c  LX    0x18 (D 24)
		00001af8  00000a3b  LBI   0xa (D 10)
		00001afc  00000090  BGEU  <fwd>
		00001b00  00211808  LEAG  0x2118 (D 8472)
		00001b04  0000009d  PSHA
		00001b08  0000200e  LL    0x20 (D 32)
		00001b0c  0000181c  LX    0x18 (D 24)
		00001b10  0000085a  MULI  0x8 (D 8)
		00001b14  000000a1  POPB
		00001b18  00000053  ADD 
		00001b1c  0000041c  LX    0x4 (D 4)
		00001b20  00000086  BNZ   <fwd>
		00001b24  ffffff23  LI    0xffffffff (D -1)
		00001b28  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=785 start=1739 end=1756>
	<code>    return devsw[ip->dir[0]].write(ip, src, n);</code>
	<emi>
		00001b2c  0000300e  LL    0x30 (D 48)
		00001b30  0000009d  PSHA
		00001b34  0000280e  LL    0x28 (D 40)
		00001b38  0000009d  PSHA
		00001b3c  0000280e  LL    0x28 (D 40)
		00001b40  0000009d  PSHA
		00001b44  00211808  LEAG  0x2118 (D 8472)
		00001b48  0000009d  PSHA
		00001b4c  0000380e  LL    0x38 (D 56)
		00001b50  0000181c  LX    0x18 (D 24)
		00001b54  0000085a  MULI  0x8 (D 8)
		00001b58  000000a1  POPB
		00001b5c  00000053  ADD 
		00001b60  0000041c  LX    0x4 (D 4)
		00001b64  00000006  JSRA
		00001b68  00001801  ENT   0x18 (D 24)
		00001b6c  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=786 start=1756 end=1756>
	<code>  }</code>
</stmt>
<stmt file=os.c line=787 start=1756 end=1766>
	<code>  if (off > ip->size || off + n < off) return -1;</code>
	<emi>
		00001b70  0000180e  LL    0x18 (D 24)
		00001b74  0000141c  LX    0x14 (D 20)
		00001b78  00002826  LBL   0x28 (D 40)
		00001b7c  0000008d  BLTU  <fwd>
		00001b80  0000280e  LL    0x28 (D 40)
		00001b84  00003055  ADDL  0x30 (D 48)
		00001b88  00002826  LBL   0x28 (D 40)
		00001b8c  00000090  BGEU  <fwd>
		00001b90  ffffff23  LI    0xffffffff (D -1)
		00001b94  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=788 start=1766 end=1774>
	<code>  if (off + n > (NDIR + NIDIR*1024)*PAGE) return -1;</code>
	<emi>
		00001b98  0000280e  LL    0x28 (D 40)
		00001b9c  00003055  ADDL  0x30 (D 48)
		00001ba0  0000003e  LBA 
		00001ba4  ffff8023  LI    0xffffff80 (D -128)
		00001ba8  1e000024  LHI   0x1e0000 (D 1966080)
		00001bac  00000090  BGEU  <fwd>
		00001bb0  ffffff23  LI    0xffffffff (D -1)
		00001bb4  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=789 start=1774 end=1774>
	<code></code>
</stmt>
<stmt file=os.c line=790 start=1774 end=1777>
	<code>  for (tot = n; tot; tot -= m, off += m, src += m) {</code>
	<emi>
		00001bb8  0000300e  LL    0x30 (D 48)
		00001bbc  00000c40  SL    0xc (D 12)
		00001bc0  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=791 start=1777 end=1788>
	<code>    bp = bread(bmap(ip, off/PAGE));</code>
	<emi>
		00001bc4  0000280e  LL    0x28 (D 40)
		00001bc8  00100060  DVUI  0x1000 (D 4096)
		00001bcc  0000009d  PSHA
		00001bd0  0000200e  LL    0x20 (D 32)
		00001bd4  0000009d  PSHA
		00001bd8  fff91805  JSR   0xfffff918 (TO 0x14f4)
		00001bdc  00001001  ENT   0x10 (D 16)
		00001be0  0000009d  PSHA
		00001be4  ffef0c05  JSR   0xffffef0c (TO 0xaf4)
		00001be8  00000801  ENT   0x8 (D 8)
		00001bec  00000440  SL    0x4 (D 4)
	</emi>
</stmt>
<stmt file=os.c line=792 start=1788 end=1799>
	<code>    if ((m = PAGE - off%PAGE) > tot) m = tot;</code>
	<emi>
		00001bf0  0000280e  LL    0x28 (D 40)
		00001bf4  00100066  MDUI  0x1000 (D 4096)
		00001bf8  0000003e  LBA 
		00001bfc  00100023  LI    0x1000 (D 4096)
		00001c00  00000056  SUB 
		00001c04  00000840  SL    0x8 (D 8)
		00001c08  0000003e  LBA 
		00001c0c  00000c0e  LL    0xc (D 12)
		00001c10  00000090  BGEU  <fwd>
		00001c14  00000c0e  LL    0xc (D 12)
		00001c18  00000840  SL    0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=793 start=1799 end=1813>
	<code>    memcpy(bp->data + off%PAGE, src, m);</code>
	<emi>
		00001c1c  0000080e  LL    0x8 (D 8)
		00001c20  0000009d  PSHA
		00001c24  0000280e  LL    0x28 (D 40)
		00001c28  0000009d  PSHA
		00001c2c  0000140e  LL    0x14 (D 20)
		00001c30  0000101c  LX    0x10 (D 16)
		00001c34  0000009d  PSHA
		00001c38  0000400e  LL    0x40 (D 64)
		00001c3c  00100066  MDUI  0x1000 (D 4096)
		00001c40  000000a1  POPB
		00001c44  00000053  ADD 
		00001c48  0000009d  PSHA
		00001c4c  ffe3b005  JSR   0xffffe3b0 (TO 0x0)
		00001c50  00001801  ENT   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=794 start=1813 end=1817>
	<code>    bwrite(bp);</code>
	<emi>
		00001c54  0000040e  LL    0x4 (D 4)
		00001c58  0000009d  PSHA
		00001c5c  ffeed805  JSR   0xffffeed8 (TO 0xb38)
		00001c60  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=795 start=1817 end=1821>
	<code>    brelse(bp);</code>
	<emi>
		00001c64  0000040e  LL    0x4 (D 4)
		00001c68  0000009d  PSHA
		00001c6c  ffef1005  JSR   0xffffef10 (TO 0xb80)
		00001c70  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=796 start=1821 end=1821>
	<code>  }</code>
</stmt>
<stmt file=os.c line=797 start=1821 end=1839>
	<code>  if (n > 0 && off > ip->size) {</code>
	<emi>
		00001c74  00000c0e  LL    0xc (D 12)
		00001c78  00000858  SUBL  0x8 (D 8)
		00001c7c  00000c40  SL    0xc (D 12)
		00001c80  0000280e  LL    0x28 (D 40)
		00001c84  00000855  ADDL  0x8 (D 8)
		00001c88  00002840  SL    0x28 (D 40)
		00001c8c  0000200e  LL    0x20 (D 32)
		00001c90  00000855  ADDL  0x8 (D 8)
		00001c94  00002040  SL    0x20 (D 32)
		00001c98  00000c0e  LL    0xc (D 12)
		00001c9c  00000086  BNZ   <fwd>
		00001ca0  00000023  LI    0x0 (D 0)
		00001ca4  00003026  LBL   0x30 (D 48)
		00001ca8  00000090  BGEU  <fwd>
		00001cac  0000180e  LL    0x18 (D 24)
		00001cb0  0000141c  LX    0x14 (D 20)
		00001cb4  00002826  LBL   0x28 (D 40)
		00001cb8  001ca890  BGEU  <fwd>
	</emi>
</stmt>
<stmt file=os.c line=798 start=1839 end=1844>
	<code>    ip->size = off;</code>
	<emi>
		00001cbc  0000180e  LL    0x18 (D 24)
		00001cc0  00001454  ADDI  0x14 (D 20)
		00001cc4  0000003e  LBA 
		00001cc8  0000280e  LL    0x28 (D 40)
		00001ccc  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=799 start=1844 end=1848>
	<code>    iupdate(ip);</code>
	<emi>
		00001cd0  0000180e  LL    0x18 (D 24)
		00001cd4  0000009d  PSHA
		00001cd8  fff3b805  JSR   0xfffff3b8 (TO 0x1094)
		00001cdc  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=800 start=1848 end=1848>
	<code>  }</code>
</stmt>
<stmt file=os.c line=801 start=1848 end=1850>
	<code>  return n;</code>
	<emi>
		00001ce0  0000300e  LL    0x30 (D 48)
		00001ce4  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=802 start=1850 end=1850>
	<code>}</code>
</stmt>
<stmt file=os.c line=803 start=1850 end=1850>
	<code></code>
</stmt>
<stmt file=os.c line=804 start=1850 end=1850>
	<code>// directories:</code>
</stmt>
<stmt file=os.c line=805 start=1850 end=1851>
	<code>int namecmp(char *p, char *q) </code>
	<emi>
		00001ce8  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=806 start=1851 end=1851>
	<code>{</code>
</stmt>
<stmt file=os.c line=807 start=1851 end=1851>
	<code>  uint n = DIRSIZ;</code>
</stmt>
<stmt file=os.c line=808 start=1851 end=1882>
	<code>  while (n) { if (!*p || *p != *q) return *p - *q; n--; p++; q++; } // XXX</code>
	<emi>
		00001cec  fffff801  ENT   0xfffffff8 (D -8)
		00001cf0  0000fc23  LI    0xfc (D 252)
		00001cf4  00000440  SL    0x4 (D 4)
		00001cf8  00000003  JMP   <fwd>
		00001cfc  0000100e  LL    0x10 (D 16)
		00001d00  0000001f  LXC 
		00001d04  00000084  BZ    <fwd>
		00001d08  0000180e  LL    0x18 (D 24)
		00001d0c  0000001f  LXC 
		00001d10  0000009d  PSHA
		00001d14  0000180e  LL    0x18 (D 24)
		00001d18  0000001f  LXC 
		00001d1c  000000a1  POPB
		00001d20  00000088  BE    <fwd>
		00001d24  0000180e  LL    0x18 (D 24)
		00001d28  0000001f  LXC 
		00001d2c  0000009d  PSHA
		00001d30  0000180e  LL    0x18 (D 24)
		00001d34  0000001f  LXC 
		00001d38  000000a1  POPB
		00001d3c  00000056  SUB 
		00001d40  00000802  LEV   0x8 (D 8)
		00001d44  0000040e  LL    0x4 (D 4)
		00001d48  00000157  SUBI  0x1 (D 1)
		00001d4c  00000440  SL    0x4 (D 4)
		00001d50  0000100e  LL    0x10 (D 16)
		00001d54  ffffff57  SUBI  0xffffffff (D -1)
		00001d58  00001040  SL    0x10 (D 16)
		00001d5c  0000180e  LL    0x18 (D 24)
		00001d60  ffffff57  SUBI  0xffffffff (D -1)
		00001d64  00001840  SL    0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=809 start=1882 end=1886>
	<code>  return 0;</code>
	<emi>
		00001d68  0000040e  LL    0x4 (D 4)
		00001d6c  00000086  BNZ   <fwd>
		00001d70  00000023  LI    0x0 (D 0)
		00001d74  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=810 start=1886 end=1886>
	<code>}</code>
</stmt>
<stmt file=os.c line=811 start=1886 end=1886>
	<code></code>
</stmt>
<stmt file=os.c line=812 start=1886 end=1886>
	<code>// look for a directory entry in a directory. If found, set *poff to byte offset of entry.</code>
</stmt>
<stmt file=os.c line=813 start=1886 end=1887>
	<code>struct inode *dirlookup(struct inode *dp, char *name, uint *poff)</code>
	<emi>
		00001d78  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=814 start=1887 end=1887>
	<code>{</code>
</stmt>
<stmt file=os.c line=815 start=1887 end=1887>
	<code>  uint off; struct direct de;</code>
</stmt>
<stmt file=os.c line=816 start=1887 end=1887>
	<code></code>
</stmt>
<stmt file=os.c line=817 start=1887 end=1897>
	<code>  if ((dp->mode & S_IFMT) != S_IFDIR) panic("dirlookup not DIR");</code>
	<emi>
		00001d7c  fffef801  ENT   0xfffffef8 (D -264)
		00001d80  0001100e  LL    0x110 (D 272)
		00001d84  00000c1e  LXH   0xc (D 12)
		00001d88  00f00069  ANDI  0xf000 (D 61440)
		00001d8c  0040003b  LBI   0x4000 (D 16384)
		00001d90  00000088  BE    <fwd>
		00001d94  00014608  LEAG  0x146 (D 326)
		00001d98  0000009d  PSHA
		00001d9c  ffe79405  JSR   0xffffe794 (TO 0x534)
		00001da0  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=818 start=1897 end=1900>
	<code>  for (off = 0; off < dp->size; off += sizeof(de)) {</code>
	<emi>
		00001da4  00000023  LI    0x0 (D 0)
		00001da8  00010440  SL    0x104 (D 260)
		00001dac  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=819 start=1900 end=1915>
	<code>    if (readi(dp, (char *)&de, off, sizeof(de)) != sizeof(de)) panic("dirlink read");</code>
	<emi>
		00001db0  0001009e  PSHI  0x100 (D 256)
		00001db4  00010c0e  LL    0x10c (D 268)
		00001db8  0000009d  PSHA
		00001dbc  00001407  LEA   0x14 (D 20)
		00001dc0  0000009d  PSHA
		00001dc4  0001280e  LL    0x128 (D 296)
		00001dc8  0000009d  PSHA
		00001dcc  fffb3805  JSR   0xfffffb38 (TO 0x1908)
		00001dd0  00002001  ENT   0x20 (D 32)
		00001dd4  0001003b  LBI   0x100 (D 256)
		00001dd8  00000088  BE    <fwd>
		00001ddc  00015808  LEAG  0x158 (D 344)
		00001de0  0000009d  PSHA
		00001de4  ffe74c05  JSR   0xffffe74c (TO 0x534)
		00001de8  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=820 start=1915 end=1924>
	<code>    if (de.d_ino && !namecmp(name, de.d_name)) { // entry matches path element</code>
	<emi>
		00001dec  0000040e  LL    0x4 (D 4)
		00001df0  00000084  BZ    <fwd>
		00001df4  00000807  LEA   0x8 (D 8)
		00001df8  0000009d  PSHA
		00001dfc  0001200e  LL    0x120 (D 288)
		00001e00  0000009d  PSHA
		00001e04  fffee405  JSR   0xfffffee4 (TO 0x1cec)
		00001e08  00001001  ENT   0x10 (D 16)
		00001e0c  001df086  BNZ   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=821 start=1924 end=1929>
	<code>      if (poff) *poff = off;</code>
	<emi>
		00001e10  0001200e  LL    0x120 (D 288)
		00001e14  00000084  BZ    <fwd>
		00001e18  0001040e  LL    0x104 (D 260)
		00001e1c  00012026  LBL   0x120 (D 288)
		00001e20  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=822 start=1929 end=1934>
	<code>      return iget(de.d_ino);</code>
	<emi>
		00001e24  0000040e  LL    0x4 (D 4)
		00001e28  0000009d  PSHA
		00001e2c  fff0c005  JSR   0xfffff0c0 (TO 0xef0)
		00001e30  00000801  ENT   0x8 (D 8)
		00001e34  00010802  LEV   0x108 (D 264)
	</emi>
</stmt>
<stmt file=os.c line=823 start=1934 end=1934>
	<code>    }</code>
</stmt>
<stmt file=os.c line=824 start=1934 end=1934>
	<code>  }</code>
</stmt>
<stmt file=os.c line=825 start=1934 end=1944>
	<code>  return 0;</code>
	<emi>
		00001e38  0001040e  LL    0x104 (D 260)
		00001e3c  00010054  ADDI  0x100 (D 256)
		00001e40  00010440  SL    0x104 (D 260)
		00001e44  0001100e  LL    0x110 (D 272)
		00001e48  0000141c  LX    0x14 (D 20)
		00001e4c  0000003e  LBA 
		00001e50  0001040e  LL    0x104 (D 260)
		00001e54  0000008d  BLTU  <fwd>
		00001e58  00000023  LI    0x0 (D 0)
		00001e5c  00010802  LEV   0x108 (D 264)
	</emi>
</stmt>
<stmt file=os.c line=826 start=1944 end=1944>
	<code>}</code>
</stmt>
<stmt file=os.c line=827 start=1944 end=1944>
	<code></code>
</stmt>
<stmt file=os.c line=828 start=1944 end=1944>
	<code>// write a new directory entry (name, inum) into the directory dp</code>
</stmt>
<stmt file=os.c line=829 start=1944 end=1945>
	<code>int dirlink(struct inode *dp, char *name, uint inum)</code>
	<emi>
		00001e60  00010802  LEV   0x108 (D 264)
	</emi>
</stmt>
<stmt file=os.c line=830 start=1945 end=1945>
	<code>{</code>
</stmt>
<stmt file=os.c line=831 start=1945 end=1945>
	<code>  int off;</code>
</stmt>
<stmt file=os.c line=832 start=1945 end=1945>
	<code>  struct direct de;</code>
</stmt>
<stmt file=os.c line=833 start=1945 end=1945>
	<code>  struct inode *ip;</code>
</stmt>
<stmt file=os.c line=834 start=1945 end=1945>
	<code></code>
</stmt>
<stmt file=os.c line=835 start=1945 end=1945>
	<code>  // check that name is not present</code>
</stmt>
<stmt file=os.c line=836 start=1945 end=1955>
	<code>  if (ip = dirlookup(dp, name, 0)) {</code>
	<emi>
		00001e64  fffef801  ENT   0xfffffef8 (D -264)
		00001e68  0000009e  PSHI  0x0 (D 0)
		00001e6c  0001200e  LL    0x120 (D 288)
		00001e70  0000009d  PSHA
		00001e74  0001200e  LL    0x120 (D 288)
		00001e78  0000009d  PSHA
		00001e7c  fffefc05  JSR   0xfffffefc (TO 0x1d7c)
		00001e80  00001801  ENT   0x18 (D 24)
		00001e84  00000040  SL    0x0 (D 0)
		00001e88  00000084  BZ    <fwd>
	</emi>
</stmt>
<stmt file=os.c line=837 start=1955 end=1959>
	<code>    iput(ip);</code>
	<emi>
		00001e8c  0000000e  LL    0x0 (D 0)
		00001e90  0000009d  PSHA
		00001e94  fff52805  JSR   0xfffff528 (TO 0x13c0)
		00001e98  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=838 start=1959 end=1961>
	<code>    return -1;</code>
	<emi>
		00001e9c  ffffff23  LI    0xffffffff (D -1)
		00001ea0  00010802  LEV   0x108 (D 264)
	</emi>
</stmt>
<stmt file=os.c line=839 start=1961 end=1961>
	<code>  }</code>
</stmt>
<stmt file=os.c line=840 start=1961 end=1961>
	<code>  // look for an empty direct</code>
</stmt>
<stmt file=os.c line=841 start=1961 end=1964>
	<code>  for (off = 0; off < dp->size; off += sizeof(de)) {</code>
	<emi>
		00001ea4  00000023  LI    0x0 (D 0)
		00001ea8  00010440  SL    0x104 (D 260)
		00001eac  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=842 start=1964 end=1979>
	<code>    if (readi(dp, (char *)&de, off, sizeof(de)) != sizeof(de)) panic("dirlink read");</code>
	<emi>
		00001eb0  0001009e  PSHI  0x100 (D 256)
		00001eb4  00010c0e  LL    0x10c (D 268)
		00001eb8  0000009d  PSHA
		00001ebc  00001407  LEA   0x14 (D 20)
		00001ec0  0000009d  PSHA
		00001ec4  0001280e  LL    0x128 (D 296)
		00001ec8  0000009d  PSHA
		00001ecc  fffa3805  JSR   0xfffffa38 (TO 0x1908)
		00001ed0  00002001  ENT   0x20 (D 32)
		00001ed4  0001003b  LBI   0x100 (D 256)
		00001ed8  00000088  BE    <fwd>
		00001edc  00016508  LEAG  0x165 (D 357)
		00001ee0  0000009d  PSHA
		00001ee4  ffe64c05  JSR   0xffffe64c (TO 0x534)
		00001ee8  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=843 start=1979 end=1982>
	<code>    if (!de.d_ino) break;</code>
	<emi>
		00001eec  0000040e  LL    0x4 (D 4)
		00001ef0  00000086  BNZ   <fwd>
		00001ef4  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=844 start=1982 end=1982>
	<code>  }</code>
</stmt>
<stmt file=os.c line=845 start=1982 end=1997>
	<code>  xstrncpy(de.d_name, name, DIRSIZ);</code>
	<emi>
		00001ef8  0001040e  LL    0x104 (D 260)
		00001efc  00010054  ADDI  0x100 (D 256)
		00001f00  00010440  SL    0x104 (D 260)
		00001f04  0001100e  LL    0x110 (D 272)
		00001f08  0000141c  LX    0x14 (D 20)
		00001f0c  0000003e  LBA 
		00001f10  0001040e  LL    0x104 (D 260)
		00001f14  0000008d  BLTU  <fwd>
		00001f18  0000fc9e  PSHI  0xfc (D 252)
		00001f1c  0001200e  LL    0x120 (D 288)
		00001f20  0000009d  PSHA
		00001f24  00001807  LEA   0x18 (D 24)
		00001f28  0000009d  PSHA
		00001f2c  ffe1b005  JSR   0xffffe1b0 (TO 0xe0)
		00001f30  00001801  ENT   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=846 start=1997 end=1999>
	<code>  de.d_ino = inum;</code>
	<emi>
		00001f34  0001200e  LL    0x120 (D 288)
		00001f38  00000440  SL    0x4 (D 4)
	</emi>
</stmt>
<stmt file=os.c line=847 start=1999 end=2014>
	<code>  if (writei(dp, (char *)&de, off, sizeof(de)) != sizeof(de)) panic("dirlink");</code>
	<emi>
		00001f3c  0001009e  PSHI  0x100 (D 256)
		00001f40  00010c0e  LL    0x10c (D 268)
		00001f44  0000009d  PSHA
		00001f48  00001407  LEA   0x14 (D 20)
		00001f4c  0000009d  PSHA
		00001f50  0001280e  LL    0x128 (D 296)
		00001f54  0000009d  PSHA
		00001f58  fffb7c05  JSR   0xfffffb7c (TO 0x1ad8)
		00001f5c  00002001  ENT   0x20 (D 32)
		00001f60  0001003b  LBI   0x100 (D 256)
		00001f64  00000088  BE    <fwd>
		00001f68  00017208  LEAG  0x172 (D 370)
		00001f6c  0000009d  PSHA
		00001f70  ffe5c005  JSR   0xffffe5c0 (TO 0x534)
		00001f74  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=848 start=2014 end=2014>
	<code>  </code>
</stmt>
<stmt file=os.c line=849 start=2014 end=2016>
	<code>  return 0;</code>
	<emi>
		00001f78  00000023  LI    0x0 (D 0)
		00001f7c  00010802  LEV   0x108 (D 264)
	</emi>
</stmt>
<stmt file=os.c line=850 start=2016 end=2016>
	<code>}</code>
</stmt>
<stmt file=os.c line=851 start=2016 end=2016>
	<code></code>
</stmt>
<stmt file=os.c line=852 start=2016 end=2016>
	<code>// is the directory dp empty except for "." and ".." ?</code>
</stmt>
<stmt file=os.c line=853 start=2016 end=2017>
	<code>int isdirempty(struct inode *dp)</code>
	<emi>
		00001f80  00010802  LEV   0x108 (D 264)
	</emi>
</stmt>
<stmt file=os.c line=854 start=2017 end=2017>
	<code>{</code>
</stmt>
<stmt file=os.c line=855 start=2017 end=2017>
	<code>  int off;</code>
</stmt>
<stmt file=os.c line=856 start=2017 end=2017>
	<code>  struct direct de;</code>
</stmt>
<stmt file=os.c line=857 start=2017 end=2017>
	<code></code>
</stmt>
<stmt file=os.c line=858 start=2017 end=2021>
	<code>  for (off=2*sizeof(de); off<dp->size; off+=sizeof(de)) {</code>
	<emi>
		00001f84  fffef801  ENT   0xfffffef8 (D -264)
		00001f88  00020023  LI    0x200 (D 512)
		00001f8c  00010440  SL    0x104 (D 260)
		00001f90  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=859 start=2021 end=2036>
	<code>    if (readi(dp, (char *)&de, off, sizeof(de)) != sizeof(de)) panic("isdirempty: readi");</code>
	<emi>
		00001f94  0001009e  PSHI  0x100 (D 256)
		00001f98  00010c0e  LL    0x10c (D 268)
		00001f9c  0000009d  PSHA
		00001fa0  00001407  LEA   0x14 (D 20)
		00001fa4  0000009d  PSHA
		00001fa8  0001280e  LL    0x128 (D 296)
		00001fac  0000009d  PSHA
		00001fb0  fff95405  JSR   0xfffff954 (TO 0x1908)
		00001fb4  00002001  ENT   0x20 (D 32)
		00001fb8  0001003b  LBI   0x100 (D 256)
		00001fbc  00000088  BE    <fwd>
		00001fc0  00017a08  LEAG  0x17a (D 378)
		00001fc4  0000009d  PSHA
		00001fc8  ffe56805  JSR   0xffffe568 (TO 0x534)
		00001fcc  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=860 start=2036 end=2040>
	<code>    if (de.d_ino) return 0;</code>
	<emi>
		00001fd0  0000040e  LL    0x4 (D 4)
		00001fd4  00000084  BZ    <fwd>
		00001fd8  00000023  LI    0x0 (D 0)
		00001fdc  00010802  LEV   0x108 (D 264)
	</emi>
</stmt>
<stmt file=os.c line=861 start=2040 end=2040>
	<code>  }</code>
</stmt>
<stmt file=os.c line=862 start=2040 end=2050>
	<code>  return 1;</code>
	<emi>
		00001fe0  0001040e  LL    0x104 (D 260)
		00001fe4  00010054  ADDI  0x100 (D 256)
		00001fe8  00010440  SL    0x104 (D 260)
		00001fec  0001100e  LL    0x110 (D 272)
		00001ff0  0000141c  LX    0x14 (D 20)
		00001ff4  0000003e  LBA 
		00001ff8  0001040e  LL    0x104 (D 260)
		00001ffc  0000008d  BLTU  <fwd>
		00002000  00000123  LI    0x1 (D 1)
		00002004  00010802  LEV   0x108 (D 264)
	</emi>
</stmt>
<stmt file=os.c line=863 start=2050 end=2050>
	<code>}</code>
</stmt>
<stmt file=os.c line=864 start=2050 end=2050>
	<code></code>
</stmt>
<stmt file=os.c line=865 start=2050 end=2050>
	<code>// paths:</code>
</stmt>
<stmt file=os.c line=866 start=2050 end=2050>
	<code>// Copy the next path element from path into name.  Return a pointer to the element following the copied one.</code>
</stmt>
<stmt file=os.c line=867 start=2050 end=2050>
	<code>// The returned path has no leading slashes, so the caller can check *path=='\0' to see if the name is the last one.</code>
</stmt>
<stmt file=os.c line=868 start=2050 end=2050>
	<code>// If no name to remove, return 0.</code>
</stmt>
<stmt file=os.c line=869 start=2050 end=2050>
	<code>//</code>
</stmt>
<stmt file=os.c line=870 start=2050 end=2050>
	<code>// Examples:</code>
</stmt>
<stmt file=os.c line=871 start=2050 end=2050>
	<code>//   skipelem("a/bb/c", name) = "bb/c", setting name = "a"</code>
</stmt>
<stmt file=os.c line=872 start=2050 end=2050>
	<code>//   skipelem("///a//bb", name) = "bb", setting name = "a"</code>
</stmt>
<stmt file=os.c line=873 start=2050 end=2050>
	<code>//   skipelem("a", name) = "", setting name = "a"</code>
</stmt>
<stmt file=os.c line=874 start=2050 end=2050>
	<code>//   skipelem("", name) = skipelem("////", name) = 0</code>
</stmt>
<stmt file=os.c line=875 start=2050 end=2050>
	<code>//</code>
</stmt>
<stmt file=os.c line=876 start=2050 end=2051>
	<code>char *skipelem(char *path, char *name)</code>
	<emi>
		00002008  00010802  LEV   0x108 (D 264)
	</emi>
</stmt>
<stmt file=os.c line=877 start=2051 end=2051>
	<code>{</code>
</stmt>
<stmt file=os.c line=878 start=2051 end=2051>
	<code>  char *s;</code>
</stmt>
<stmt file=os.c line=879 start=2051 end=2051>
	<code>  int len;</code>
</stmt>
<stmt file=os.c line=880 start=2051 end=2051>
	<code></code>
</stmt>
<stmt file=os.c line=881 start=2051 end=2056>
	<code>  while (*path == '/') path++;</code>
	<emi>
		0000200c  fffff801  ENT   0xfffffff8 (D -8)
		00002010  00000003  JMP   <fwd>
		00002014  0000100e  LL    0x10 (D 16)
		00002018  ffffff57  SUBI  0xffffffff (D -1)
		0000201c  00001040  SL    0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=882 start=2056 end=2065>
	<code>  if (!*path) return 0;</code>
	<emi>
		00002020  0000100e  LL    0x10 (D 16)
		00002024  0000001f  LXC 
		00002028  00002f3b  LBI   0x2f (D 47)
		0000202c  00000088  BE    <fwd>
		00002030  0000100e  LL    0x10 (D 16)
		00002034  0000001f  LXC 
		00002038  00000086  BNZ   <fwd>
		0000203c  00000023  LI    0x0 (D 0)
		00002040  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=883 start=2065 end=2067>
	<code>  s = path;</code>
	<emi>
		00002044  0000100e  LL    0x10 (D 16)
		00002048  00000440  SL    0x4 (D 4)
	</emi>
</stmt>
<stmt file=os.c line=884 start=2067 end=2071>
	<code>  while (*path != '/' && *path) path++;</code>
	<emi>
		0000204c  00000003  JMP   <fwd>
		00002050  0000100e  LL    0x10 (D 16)
		00002054  ffffff57  SUBI  0xffffffff (D -1)
		00002058  00001040  SL    0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=885 start=2071 end=2082>
	<code>  len = path - s;</code>
	<emi>
		0000205c  0000100e  LL    0x10 (D 16)
		00002060  0000001f  LXC 
		00002064  00002f3b  LBI   0x2f (D 47)
		00002068  00000088  BE    <fwd>
		0000206c  0000100e  LL    0x10 (D 16)
		00002070  0000001f  LXC 
		00002074  00000086  BNZ   <fwd>
		00002078  0000100e  LL    0x10 (D 16)
		0000207c  00000458  SUBL  0x4 (D 4)
		00002080  0000015d  DIVI  0x1 (D 1)
		00002084  00000040  SL    0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=886 start=2082 end=2092>
	<code>  if (len >= DIRSIZ) memcpy(name, s, DIRSIZ);</code>
	<emi>
		00002088  0000000e  LL    0x0 (D 0)
		0000208c  0000fc3b  LBI   0xfc (D 252)
		00002090  0000008c  BLT   <fwd>
		00002094  0000fc9e  PSHI  0xfc (D 252)
		00002098  00000c0e  LL    0xc (D 12)
		0000209c  0000009d  PSHA
		000020a0  0000280e  LL    0x28 (D 40)
		000020a4  0000009d  PSHA
		000020a8  ffdf5405  JSR   0xffffdf54 (TO 0x0)
		000020ac  00001801  ENT   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=887 start=2092 end=2093>
	<code>  else {</code>
	<emi>
		000020b0  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=888 start=2093 end=2101>
	<code>    memcpy(name, s, len);</code>
	<emi>
		000020b4  0000000e  LL    0x0 (D 0)
		000020b8  0000009d  PSHA
		000020bc  00000c0e  LL    0xc (D 12)
		000020c0  0000009d  PSHA
		000020c4  0000280e  LL    0x28 (D 40)
		000020c8  0000009d  PSHA
		000020cc  ffdf3005  JSR   0xffffdf30 (TO 0x0)
		000020d0  00001801  ENT   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=889 start=2101 end=2106>
	<code>    name[len] = 0;</code>
	<emi>
		000020d4  0000180e  LL    0x18 (D 24)
		000020d8  00000055  ADDL  0x0 (D 0)
		000020dc  0000003e  LBA 
		000020e0  00000023  LI    0x0 (D 0)
		000020e4  0000004c  SXB 
	</emi>
</stmt>
<stmt file=os.c line=890 start=2106 end=2106>
	<code>  }</code>
</stmt>
<stmt file=os.c line=891 start=2106 end=2110>
	<code>  while (*path == '/') path++;</code>
	<emi>
		000020e8  00000003  JMP   <fwd>
		000020ec  0000100e  LL    0x10 (D 16)
		000020f0  ffffff57  SUBI  0xffffffff (D -1)
		000020f4  00001040  SL    0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=892 start=2110 end=2116>
	<code>  return path;</code>
	<emi>
		000020f8  0000100e  LL    0x10 (D 16)
		000020fc  0000001f  LXC 
		00002100  00002f3b  LBI   0x2f (D 47)
		00002104  00000088  BE    <fwd>
		00002108  0000100e  LL    0x10 (D 16)
		0000210c  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=893 start=2116 end=2116>
	<code>}</code>
</stmt>
<stmt file=os.c line=894 start=2116 end=2116>
	<code></code>
</stmt>
<stmt file=os.c line=895 start=2116 end=2116>
	<code>// Look up and return the inode for a path name</code>
</stmt>
<stmt file=os.c line=896 start=2116 end=2117>
	<code>struct inode *namei(char *path)</code>
	<emi>
		00002110  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=897 start=2117 end=2117>
	<code>{</code>
</stmt>
<stmt file=os.c line=898 start=2117 end=2117>
	<code>  char name[DIRSIZ];</code>
</stmt>
<stmt file=os.c line=899 start=2117 end=2117>
	<code>  struct inode *ip, *next;</code>
</stmt>
<stmt file=os.c line=900 start=2117 end=2117>
	<code></code>
</stmt>
<stmt file=os.c line=901 start=2117 end=2133>
	<code>  if (*path == '/') ip = iget(ROOTINO); else idup(ip = u->cwd);</code>
	<emi>
		00002114  fffef801  ENT   0xfffffef8 (D -264)
		00002118  0001100e  LL    0x110 (D 272)
		0000211c  0000001f  LXC 
		00002120  00002f3b  LBI   0x2f (D 47)
		00002124  0000008a  BNE   <fwd>
		00002128  0000109e  PSHI  0x10 (D 16)
		0000212c  ffedc005  JSR   0xffffedc0 (TO 0xef0)
		00002130  00000801  ENT   0x8 (D 8)
		00002134  00000840  SL    0x8 (D 8)
		00002138  00000003  JMP   <fwd>
		0000213c  00210015  LG    0x2100 (D 8448)
		00002140  0000701c  LX    0x70 (D 112)
		00002144  00000840  SL    0x8 (D 8)
		00002148  0000009d  PSHA
		0000214c  fff02005  JSR   0xfffff020 (TO 0x1170)
		00002150  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=902 start=2133 end=2133>
	<code>  </code>
</stmt>
<stmt file=os.c line=903 start=2133 end=2134>
	<code>  while (path = skipelem(path, name)) {</code>
	<emi>
		00002154  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=904 start=2134 end=2138>
	<code>    ilock(ip);</code>
	<emi>
		00002158  0000080e  LL    0x8 (D 8)
		0000215c  0000009d  PSHA
		00002160  fff04405  JSR   0xfffff044 (TO 0x11a8)
		00002164  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=905 start=2138 end=2152>
	<code>    if ((ip->mode & S_IFMT) != S_IFDIR || !(next = dirlookup(ip, name, 0))) {</code>
	<emi>
		00002168  0000080e  LL    0x8 (D 8)
		0000216c  00000c1e  LXH   0xc (D 12)
		00002170  00f00069  ANDI  0xf000 (D 61440)
		00002174  0040003b  LBI   0x4000 (D 16384)
		00002178  0000008a  BNE   <fwd>
		0000217c  0000009e  PSHI  0x0 (D 0)
		00002180  00001407  LEA   0x14 (D 20)
		00002184  0000009d  PSHA
		00002188  0000180e  LL    0x18 (D 24)
		0000218c  0000009d  PSHA
		00002190  fffbe805  JSR   0xfffffbe8 (TO 0x1d7c)
		00002194  00001801  ENT   0x18 (D 24)
		00002198  00000440  SL    0x4 (D 4)
		0000219c  00000086  BNZ   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=906 start=2152 end=2156>
	<code>      iunlockput(ip);</code>
	<emi>
		000021a0  0000080e  LL    0x8 (D 8)
		000021a4  0000009d  PSHA
		000021a8  fff32405  JSR   0xfffff324 (TO 0x14d0)
		000021ac  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=907 start=2156 end=2158>
	<code>      return 0;</code>
	<emi>
		000021b0  00000023  LI    0x0 (D 0)
		000021b4  00010802  LEV   0x108 (D 264)
	</emi>
</stmt>
<stmt file=os.c line=908 start=2158 end=2158>
	<code>    }</code>
</stmt>
<stmt file=os.c line=909 start=2158 end=2162>
	<code>    iunlockput(ip);</code>
	<emi>
		000021b8  0000080e  LL    0x8 (D 8)
		000021bc  0000009d  PSHA
		000021c0  fff30c05  JSR   0xfffff30c (TO 0x14d0)
		000021c4  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=910 start=2162 end=2164>
	<code>    ip = next;</code>
	<emi>
		000021c8  0000040e  LL    0x4 (D 4)
		000021cc  00000840  SL    0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=911 start=2164 end=2164>
	<code>  }</code>
</stmt>
<stmt file=os.c line=912 start=2164 end=2174>
	<code>  return ip;</code>
	<emi>
		000021d0  00000c07  LEA   0xc (D 12)
		000021d4  0000009d  PSHA
		000021d8  0001180e  LL    0x118 (D 280)
		000021dc  0000009d  PSHA
		000021e0  fffe2805  JSR   0xfffffe28 (TO 0x200c)
		000021e4  00001001  ENT   0x10 (D 16)
		000021e8  00011040  SL    0x110 (D 272)
		000021ec  00000086  BNZ   <fwd>
		000021f0  0000080e  LL    0x8 (D 8)
		000021f4  00010802  LEV   0x108 (D 264)
	</emi>
</stmt>
<stmt file=os.c line=913 start=2174 end=2174>
	<code>}</code>
</stmt>
<stmt file=os.c line=914 start=2174 end=2174>
	<code>// return the inode for the parent and copy the final path element into name, which must have room for DIRSIZ bytes.</code>
</stmt>
<stmt file=os.c line=915 start=2174 end=2175>
	<code>struct inode *nameiparent(char *path, char *name)</code>
	<emi>
		000021f8  00010802  LEV   0x108 (D 264)
	</emi>
</stmt>
<stmt file=os.c line=916 start=2175 end=2175>
	<code>{</code>
</stmt>
<stmt file=os.c line=917 start=2175 end=2175>
	<code>  struct inode *ip, *next;</code>
</stmt>
<stmt file=os.c line=918 start=2175 end=2175>
	<code></code>
</stmt>
<stmt file=os.c line=919 start=2175 end=2191>
	<code>  if (*path == '/') ip = iget(ROOTINO); else idup(ip = u->cwd);</code>
	<emi>
		000021fc  fffff801  ENT   0xfffffff8 (D -8)
		00002200  0000100e  LL    0x10 (D 16)
		00002204  0000001f  LXC 
		00002208  00002f3b  LBI   0x2f (D 47)
		0000220c  0000008a  BNE   <fwd>
		00002210  0000109e  PSHI  0x10 (D 16)
		00002214  ffecd805  JSR   0xffffecd8 (TO 0xef0)
		00002218  00000801  ENT   0x8 (D 8)
		0000221c  00000440  SL    0x4 (D 4)
		00002220  00000003  JMP   <fwd>
		00002224  00210015  LG    0x2100 (D 8448)
		00002228  0000701c  LX    0x70 (D 112)
		0000222c  00000440  SL    0x4 (D 4)
		00002230  0000009d  PSHA
		00002234  ffef3805  JSR   0xffffef38 (TO 0x1170)
		00002238  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=920 start=2191 end=2191>
	<code>  </code>
</stmt>
<stmt file=os.c line=921 start=2191 end=2192>
	<code>  while (path = skipelem(path, name)) {</code>
	<emi>
		0000223c  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=922 start=2192 end=2196>
	<code>    ilock(ip);</code>
	<emi>
		00002240  0000040e  LL    0x4 (D 4)
		00002244  0000009d  PSHA
		00002248  ffef5c05  JSR   0xffffef5c (TO 0x11a8)
		0000224c  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=923 start=2196 end=2201>
	<code>    if ((ip->mode & S_IFMT) != S_IFDIR) {</code>
	<emi>
		00002250  0000040e  LL    0x4 (D 4)
		00002254  00000c1e  LXH   0xc (D 12)
		00002258  00f00069  ANDI  0xf000 (D 61440)
		0000225c  0040003b  LBI   0x4000 (D 16384)
		00002260  00000088  BE    <fwd>
	</emi>
</stmt>
<stmt file=os.c line=924 start=2201 end=2205>
	<code>      iunlockput(ip);</code>
	<emi>
		00002264  0000040e  LL    0x4 (D 4)
		00002268  0000009d  PSHA
		0000226c  fff26005  JSR   0xfffff260 (TO 0x14d0)
		00002270  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=925 start=2205 end=2207>
	<code>      return 0;</code>
	<emi>
		00002274  00000023  LI    0x0 (D 0)
		00002278  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=926 start=2207 end=2207>
	<code>    }</code>
</stmt>
<stmt file=os.c line=927 start=2207 end=2210>
	<code>    if (!*path) { // stop one level early</code>
	<emi>
		0000227c  0000100e  LL    0x10 (D 16)
		00002280  0000001f  LXC 
		00002284  00000086  BNZ   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=928 start=2210 end=2214>
	<code>      iunlock(ip);</code>
	<emi>
		00002288  0000040e  LL    0x4 (D 4)
		0000228c  0000009d  PSHA
		00002290  fff0ac05  JSR   0xfffff0ac (TO 0x1340)
		00002294  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=929 start=2214 end=2216>
	<code>      return ip;</code>
	<emi>
		00002298  0000040e  LL    0x4 (D 4)
		0000229c  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=930 start=2216 end=2216>
	<code>    }</code>
</stmt>
<stmt file=os.c line=931 start=2216 end=2225>
	<code>    if (!(next = dirlookup(ip, name, 0))) {</code>
	<emi>
		000022a0  0000009e  PSHI  0x0 (D 0)
		000022a4  0000200e  LL    0x20 (D 32)
		000022a8  0000009d  PSHA
		000022ac  0000140e  LL    0x14 (D 20)
		000022b0  0000009d  PSHA
		000022b4  fffac405  JSR   0xfffffac4 (TO 0x1d7c)
		000022b8  00001801  ENT   0x18 (D 24)
		000022bc  00000040  SL    0x0 (D 0)
		000022c0  00000086  BNZ   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=932 start=2225 end=2229>
	<code>      iunlockput(ip);</code>
	<emi>
		000022c4  0000040e  LL    0x4 (D 4)
		000022c8  0000009d  PSHA
		000022cc  fff20005  JSR   0xfffff200 (TO 0x14d0)
		000022d0  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=933 start=2229 end=2231>
	<code>      return 0;</code>
	<emi>
		000022d4  00000023  LI    0x0 (D 0)
		000022d8  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=934 start=2231 end=2231>
	<code>    }</code>
</stmt>
<stmt file=os.c line=935 start=2231 end=2235>
	<code>    iunlockput(ip);</code>
	<emi>
		000022dc  0000040e  LL    0x4 (D 4)
		000022e0  0000009d  PSHA
		000022e4  fff1e805  JSR   0xfffff1e8 (TO 0x14d0)
		000022e8  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=936 start=2235 end=2237>
	<code>    ip = next;</code>
	<emi>
		000022ec  0000000e  LL    0x0 (D 0)
		000022f0  00000440  SL    0x4 (D 4)
	</emi>
</stmt>
<stmt file=os.c line=937 start=2237 end=2237>
	<code>  }</code>
</stmt>
<stmt file=os.c line=938 start=2237 end=2249>
	<code>  iput(ip);</code>
	<emi>
		000022f4  0000180e  LL    0x18 (D 24)
		000022f8  0000009d  PSHA
		000022fc  0000180e  LL    0x18 (D 24)
		00002300  0000009d  PSHA
		00002304  fffd0405  JSR   0xfffffd04 (TO 0x200c)
		00002308  00001001  ENT   0x10 (D 16)
		0000230c  00001040  SL    0x10 (D 16)
		00002310  00000086  BNZ   <fwd>
		00002314  0000040e  LL    0x4 (D 4)
		00002318  0000009d  PSHA
		0000231c  fff0a005  JSR   0xfffff0a0 (TO 0x13c0)
		00002320  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=939 start=2249 end=2251>
	<code>  return 0;</code>
	<emi>
		00002324  00000023  LI    0x0 (D 0)
		00002328  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=940 start=2251 end=2251>
	<code>}</code>
</stmt>
<stmt file=os.c line=941 start=2251 end=2251>
	<code></code>
</stmt>
<stmt file=os.c line=942 start=2251 end=2251>
	<code>// pipes:</code>
</stmt>
<stmt file=os.c line=943 start=2251 end=2252>
	<code>void pipeclose(struct pipe *p, int writable)</code>
	<emi>
		0000232c  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=944 start=2252 end=2252>
	<code>{</code>
</stmt>
<stmt file=os.c line=945 start=2252 end=2252>
	<code>  int e = splhi();</code>
</stmt>
<stmt file=os.c line=946 start=2252 end=2257>
	<code>  if (writable) {</code>
	<emi>
		00002330  fffff801  ENT   0xfffffff8 (D -8)
		00002334  ffdd6805  JSR   0xffffdd68 (TO 0xa0)
		00002338  00000440  SL    0x4 (D 4)
		0000233c  0000180e  LL    0x18 (D 24)
		00002340  00000084  BZ    <fwd>
	</emi>
</stmt>
<stmt file=os.c line=947 start=2257 end=2262>
	<code>    p->writeopen = 0;</code>
	<emi>
		00002344  0000100e  LL    0x10 (D 16)
		00002348  000fac54  ADDI  0xfac (D 4012)
		0000234c  0000003e  LBA 
		00002350  00000023  LI    0x0 (D 0)
		00002354  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=948 start=2262 end=2267>
	<code>    wakeup(&p->nread);</code>
	<emi>
		00002358  0000100e  LL    0x10 (D 16)
		0000235c  000fa054  ADDI  0xfa0 (D 4000)
		00002360  0000009d  PSHA
		00002364  00149c05  JSR   <fwd>
		00002368  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=949 start=2267 end=2268>
	<code>  } else {</code>
	<emi>
		0000236c  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=950 start=2268 end=2273>
	<code>    p->readopen = 0;</code>
	<emi>
		00002370  0000100e  LL    0x10 (D 16)
		00002374  000fa854  ADDI  0xfa8 (D 4008)
		00002378  0000003e  LBA 
		0000237c  00000023  LI    0x0 (D 0)
		00002380  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=951 start=2273 end=2278>
	<code>    wakeup(&p->nwrite);</code>
	<emi>
		00002384  0000100e  LL    0x10 (D 16)
		00002388  000fa454  ADDI  0xfa4 (D 4004)
		0000238c  0000009d  PSHA
		00002390  00236405  JSR   <fwd>
		00002394  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=952 start=2278 end=2278>
	<code>  }</code>
</stmt>
<stmt file=os.c line=953 start=2278 end=2288>
	<code>  if (!p->readopen && !p->writeopen) kfree(p);</code>
	<emi>
		00002398  0000100e  LL    0x10 (D 16)
		0000239c  000fa81c  LX    0xfa8 (D 4008)
		000023a0  00000086  BNZ   <fwd>
		000023a4  0000100e  LL    0x10 (D 16)
		000023a8  000fac1c  LX    0xfac (D 4012)
		000023ac  0023a086  BNZ   <fwd>
		000023b0  0000100e  LL    0x10 (D 16)
		000023b4  0000009d  PSHA
		000023b8  ffdebc05  JSR   0xffffdebc (TO 0x278)
		000023bc  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=954 start=2288 end=2292>
	<code>  splx(e);</code>
	<emi>
		000023c0  0000040e  LL    0x4 (D 4)
		000023c4  0000009d  PSHA
		000023c8  ffdcdc05  JSR   0xffffdcdc (TO 0xa8)
		000023cc  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=955 start=2292 end=2292>
	<code>}</code>
</stmt>
<stmt file=os.c line=956 start=2292 end=2292>
	<code></code>
</stmt>
<stmt file=os.c line=957 start=2292 end=2293>
	<code>int pipewrite(struct pipe *p, char *addr, int n)</code>
	<emi>
		000023d0  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=958 start=2293 end=2293>
	<code>{</code>
</stmt>
<stmt file=os.c line=959 start=2293 end=2293>
	<code>  int i, e = splhi();</code>
</stmt>
<stmt file=os.c line=960 start=2293 end=2293>
	<code></code>
</stmt>
<stmt file=os.c line=961 start=2293 end=2299>
	<code>  for (i = 0; i < n; i++) {</code>
	<emi>
		000023d4  fffff801  ENT   0xfffffff8 (D -8)
		000023d8  ffdcc405  JSR   0xffffdcc4 (TO 0xa0)
		000023dc  00000040  SL    0x0 (D 0)
		000023e0  00000023  LI    0x0 (D 0)
		000023e4  00000440  SL    0x4 (D 4)
		000023e8  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=962 start=2299 end=2300>
	<code>    while (p->nwrite == p->nread + PIPESIZE) {  // XXX DOC: pipewrite-full</code>
	<emi>
		000023ec  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=963 start=2300 end=2306>
	<code>      if (!p->readopen || u->killed) {</code>
	<emi>
		000023f0  0000100e  LL    0x10 (D 16)
		000023f4  000fa81c  LX    0xfa8 (D 4008)
		000023f8  00000084  BZ    <fwd>
		000023fc  00210015  LG    0x2100 (D 8448)
		00002400  00002c1c  LX    0x2c (D 44)
		00002404  00000084  BZ    <fwd>
	</emi>
</stmt>
<stmt file=os.c line=964 start=2306 end=2310>
	<code>        splx(e);</code>
	<emi>
		00002408  0000000e  LL    0x0 (D 0)
		0000240c  0000009d  PSHA
		00002410  ffdc9405  JSR   0xffffdc94 (TO 0xa8)
		00002414  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=965 start=2310 end=2312>
	<code>        return -1;</code>
	<emi>
		00002418  ffffff23  LI    0xffffffff (D -1)
		0000241c  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=966 start=2312 end=2312>
	<code>      }</code>
</stmt>
<stmt file=os.c line=967 start=2312 end=2317>
	<code>      wakeup(&p->nread);</code>
	<emi>
		00002420  0000100e  LL    0x10 (D 16)
		00002424  000fa054  ADDI  0xfa0 (D 4000)
		00002428  0000009d  PSHA
		0000242c  00239005  JSR   <fwd>
		00002430  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=968 start=2317 end=2322>
	<code>      sleep(&p->nwrite);  // XXX DOC: pipewrite-sleep</code>
	<emi>
		00002434  0000100e  LL    0x10 (D 16)
		00002438  000fa454  ADDI  0xfa4 (D 4004)
		0000243c  0000009d  PSHA
		00002440  0011e805  JSR   <fwd>
		00002444  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=969 start=2322 end=2322>
	<code>    }</code>
</stmt>
<stmt file=os.c line=970 start=2322 end=2345>
	<code>    p->data[p->nwrite++ % PIPESIZE] = addr[i]; // XXX pagefault possible in cli (use inode locks instead?)</code>
	<emi>
		00002448  0000100e  LL    0x10 (D 16)
		0000244c  000fa41c  LX    0xfa4 (D 4004)
		00002450  0000009d  PSHA
		00002454  0000180e  LL    0x18 (D 24)
		00002458  000fa01c  LX    0xfa0 (D 4000)
		0000245c  000fa054  ADDI  0xfa0 (D 4000)
		00002460  000000a1  POPB
		00002464  00000088  BE    <fwd>
		00002468  0000100e  LL    0x10 (D 16)
		0000246c  000fa454  ADDI  0xfa4 (D 4004)
		00002470  0000003e  LBA 
		00002474  0000001c  LX  
		00002478  ffffff57  SUBI  0xffffffff (D -1)
		0000247c  0000004a  SX  
		00002480  ffffff54  ADDI  0xffffffff (D -1)
		00002484  000fa066  MDUI  0xfa0 (D 4000)
		00002488  00001055  ADDL  0x10 (D 16)
		0000248c  0000009d  PSHA
		00002490  0000200e  LL    0x20 (D 32)
		00002494  00000c55  ADDL  0xc (D 12)
		00002498  0000001f  LXC 
		0000249c  000000a1  POPB
		000024a0  0000004c  SXB 
	</emi>
</stmt>
<stmt file=os.c line=971 start=2345 end=2345>
	<code>  }</code>
</stmt>
<stmt file=os.c line=972 start=2345 end=2356>
	<code>  wakeup(&p->nread);  // XXX DOC: pipewrite-wakeup</code>
	<emi>
		000024a4  0000040e  LL    0x4 (D 4)
		000024a8  ffffff57  SUBI  0xffffffff (D -1)
		000024ac  00000440  SL    0x4 (D 4)
		000024b0  0000040e  LL    0x4 (D 4)
		000024b4  00002026  LBL   0x20 (D 32)
		000024b8  0000008c  BLT   <fwd>
		000024bc  0000100e  LL    0x10 (D 16)
		000024c0  000fa054  ADDI  0xfa0 (D 4000)
		000024c4  0000009d  PSHA
		000024c8  00242c05  JSR   <fwd>
		000024cc  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=973 start=2356 end=2360>
	<code>  splx(e);</code>
	<emi>
		000024d0  0000000e  LL    0x0 (D 0)
		000024d4  0000009d  PSHA
		000024d8  ffdbcc05  JSR   0xffffdbcc (TO 0xa8)
		000024dc  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=974 start=2360 end=2362>
	<code>  return n;</code>
	<emi>
		000024e0  0000200e  LL    0x20 (D 32)
		000024e4  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=975 start=2362 end=2362>
	<code>}</code>
</stmt>
<stmt file=os.c line=976 start=2362 end=2362>
	<code></code>
</stmt>
<stmt file=os.c line=977 start=2362 end=2363>
	<code>int piperead(struct pipe *p, char *addr, int n)</code>
	<emi>
		000024e8  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=978 start=2363 end=2363>
	<code>{</code>
</stmt>
<stmt file=os.c line=979 start=2363 end=2363>
	<code>  int i, e = splhi();</code>
</stmt>
<stmt file=os.c line=980 start=2363 end=2363>
	<code></code>
</stmt>
<stmt file=os.c line=981 start=2363 end=2367>
	<code>  while (p->nread == p->nwrite && p->writeopen) {  // XXX DOC: pipe-empty</code>
	<emi>
		000024ec  fffff801  ENT   0xfffffff8 (D -8)
		000024f0  ffdbac05  JSR   0xffffdbac (TO 0xa0)
		000024f4  00000040  SL    0x0 (D 0)
		000024f8  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=982 start=2367 end=2370>
	<code>    if (u->killed) {</code>
	<emi>
		000024fc  00210015  LG    0x2100 (D 8448)
		00002500  00002c1c  LX    0x2c (D 44)
		00002504  00000084  BZ    <fwd>
	</emi>
</stmt>
<stmt file=os.c line=983 start=2370 end=2374>
	<code>      splx(e);</code>
	<emi>
		00002508  0000000e  LL    0x0 (D 0)
		0000250c  0000009d  PSHA
		00002510  ffdb9405  JSR   0xffffdb94 (TO 0xa8)
		00002514  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=984 start=2374 end=2376>
	<code>      return -1;</code>
	<emi>
		00002518  ffffff23  LI    0xffffffff (D -1)
		0000251c  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=985 start=2376 end=2376>
	<code>    }</code>
</stmt>
<stmt file=os.c line=986 start=2376 end=2381>
	<code>    sleep(&p->nread); // XXX DOC: piperead-sleep</code>
	<emi>
		00002520  0000100e  LL    0x10 (D 16)
		00002524  000fa054  ADDI  0xfa0 (D 4000)
		00002528  0000009d  PSHA
		0000252c  00244005  JSR   <fwd>
		00002530  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=987 start=2381 end=2381>
	<code>  }</code>
</stmt>
<stmt file=os.c line=988 start=2381 end=2394>
	<code>  for (i = 0; i < n; i++) {  // XXX DOC: piperead-copy</code>
	<emi>
		00002534  0000100e  LL    0x10 (D 16)
		00002538  000fa41c  LX    0xfa4 (D 4004)
		0000253c  0000009d  PSHA
		00002540  0000180e  LL    0x18 (D 24)
		00002544  000fa01c  LX    0xfa0 (D 4000)
		00002548  000000a1  POPB
		0000254c  0000008a  BNE   <fwd>
		00002550  0000100e  LL    0x10 (D 16)
		00002554  000fac1c  LX    0xfac (D 4012)
		00002558  00000086  BNZ   <fwd>
		0000255c  00000023  LI    0x0 (D 0)
		00002560  00000440  SL    0x4 (D 4)
		00002564  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=989 start=2394 end=2402>
	<code>    if (p->nread == p->nwrite) break;</code>
	<emi>
		00002568  0000100e  LL    0x10 (D 16)
		0000256c  000fa41c  LX    0xfa4 (D 4004)
		00002570  0000009d  PSHA
		00002574  0000180e  LL    0x18 (D 24)
		00002578  000fa01c  LX    0xfa0 (D 4000)
		0000257c  000000a1  POPB
		00002580  0000008a  BNE   <fwd>
		00002584  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=990 start=2402 end=2417>
	<code>    addr[i] = p->data[p->nread++ % PIPESIZE]; // XXX pagefault possible in cli (use inode locks instead?)</code>
	<emi>
		00002588  0000180e  LL    0x18 (D 24)
		0000258c  00000455  ADDL  0x4 (D 4)
		00002590  0000009d  PSHA
		00002594  0000180e  LL    0x18 (D 24)
		00002598  000fa054  ADDI  0xfa0 (D 4000)
		0000259c  0000003e  LBA 
		000025a0  0000001c  LX  
		000025a4  ffffff57  SUBI  0xffffffff (D -1)
		000025a8  0000004a  SX  
		000025ac  ffffff54  ADDI  0xffffffff (D -1)
		000025b0  000fa066  MDUI  0xfa0 (D 4000)
		000025b4  00001855  ADDL  0x18 (D 24)
		000025b8  0000001f  LXC 
		000025bc  000000a1  POPB
		000025c0  0000004c  SXB 
	</emi>
</stmt>
<stmt file=os.c line=991 start=2417 end=2417>
	<code>  }</code>
</stmt>
<stmt file=os.c line=992 start=2417 end=2428>
	<code>  wakeup(&p->nwrite);  // XXX DOC: piperead-wakeup</code>
	<emi>
		000025c4  0000040e  LL    0x4 (D 4)
		000025c8  ffffff57  SUBI  0xffffffff (D -1)
		000025cc  00000440  SL    0x4 (D 4)
		000025d0  0000040e  LL    0x4 (D 4)
		000025d4  00002026  LBL   0x20 (D 32)
		000025d8  0000008c  BLT   <fwd>
		000025dc  0000100e  LL    0x10 (D 16)
		000025e0  000fa454  ADDI  0xfa4 (D 4004)
		000025e4  0000009d  PSHA
		000025e8  0024c805  JSR   <fwd>
		000025ec  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=993 start=2428 end=2432>
	<code>  splx(e);</code>
	<emi>
		000025f0  0000000e  LL    0x0 (D 0)
		000025f4  0000009d  PSHA
		000025f8  ffdaac05  JSR   0xffffdaac (TO 0xa8)
		000025fc  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=994 start=2432 end=2434>
	<code>  return i;</code>
	<emi>
		00002600  0000040e  LL    0x4 (D 4)
		00002604  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=995 start=2434 end=2434>
	<code>}</code>
</stmt>
<stmt file=os.c line=996 start=2434 end=2434>
	<code></code>
</stmt>
<stmt file=os.c line=997 start=2434 end=2434>
	<code>// allocate a file structure</code>
</stmt>
<stmt file=os.c line=998 start=2434 end=2435>
	<code>struct file *filealloc()</code>
	<emi>
		00002608  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=999 start=2435 end=2435>
	<code>{</code>
</stmt>
<stmt file=os.c line=1000 start=2435 end=2435>
	<code>  struct file *f; int e = splhi();</code>
</stmt>
<stmt file=os.c line=1001 start=2435 end=2435>
	<code></code>
</stmt>
<stmt file=os.c line=1002 start=2435 end=2441>
	<code>  for (f = file; f < file + NFILE; f++) {</code>
	<emi>
		0000260c  fffff801  ENT   0xfffffff8 (D -8)
		00002610  ffda8c05  JSR   0xffffda8c (TO 0xa0)
		00002614  00000040  SL    0x0 (D 0)
		00002618  032e8808  LEAG  0x32e88 (D 208520)
		0000261c  00000440  SL    0x4 (D 4)
		00002620  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1003 start=2441 end=2444>
	<code>    if (!f->ref) {</code>
	<emi>
		00002624  0000040e  LL    0x4 (D 4)
		00002628  0000041c  LX    0x4 (D 4)
		0000262c  00000086  BNZ   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1004 start=2444 end=2449>
	<code>      f->ref = 1;</code>
	<emi>
		00002630  0000040e  LL    0x4 (D 4)
		00002634  00000454  ADDI  0x4 (D 4)
		00002638  0000003e  LBA 
		0000263c  00000123  LI    0x1 (D 1)
		00002640  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1005 start=2449 end=2453>
	<code>      splx(e);</code>
	<emi>
		00002644  0000000e  LL    0x0 (D 0)
		00002648  0000009d  PSHA
		0000264c  ffda5805  JSR   0xffffda58 (TO 0xa8)
		00002650  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1006 start=2453 end=2455>
	<code>      return f;</code>
	<emi>
		00002654  0000040e  LL    0x4 (D 4)
		00002658  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1007 start=2455 end=2455>
	<code>    }</code>
</stmt>
<stmt file=os.c line=1008 start=2455 end=2455>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1009 start=2455 end=2466>
	<code>  splx(e);</code>
	<emi>
		0000265c  0000040e  LL    0x4 (D 4)
		00002660  ffffe857  SUBI  0xffffffe8 (D -24)
		00002664  00000440  SL    0x4 (D 4)
		00002668  0337e808  LEAG  0x337e8 (D 210920)
		0000266c  0000003e  LBA 
		00002670  0000040e  LL    0x4 (D 4)
		00002674  0000008d  BLTU  <fwd>
		00002678  0000000e  LL    0x0 (D 0)
		0000267c  0000009d  PSHA
		00002680  ffda2405  JSR   0xffffda24 (TO 0xa8)
		00002684  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1010 start=2466 end=2468>
	<code>  return 0;</code>
	<emi>
		00002688  00000023  LI    0x0 (D 0)
		0000268c  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1011 start=2468 end=2468>
	<code>}</code>
</stmt>
<stmt file=os.c line=1012 start=2468 end=2468>
	<code></code>
</stmt>
<stmt file=os.c line=1013 start=2468 end=2468>
	<code>// increment ref count for file</code>
</stmt>
<stmt file=os.c line=1014 start=2468 end=2469>
	<code>struct file *filedup(struct file *f)</code>
	<emi>
		00002690  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1015 start=2469 end=2469>
	<code>{</code>
</stmt>
<stmt file=os.c line=1016 start=2469 end=2469>
	<code>  int e = splhi();</code>
</stmt>
<stmt file=os.c line=1017 start=2469 end=2480>
	<code>  if (f->ref < 1) panic("filedup");</code>
	<emi>
		00002694  fffff801  ENT   0xfffffff8 (D -8)
		00002698  ffda0405  JSR   0xffffda04 (TO 0xa0)
		0000269c  00000440  SL    0x4 (D 4)
		000026a0  0000100e  LL    0x10 (D 16)
		000026a4  0000041c  LX    0x4 (D 4)
		000026a8  0000013b  LBI   0x1 (D 1)
		000026ac  0000008f  BGE   <fwd>
		000026b0  00018c08  LEAG  0x18c (D 396)
		000026b4  0000009d  PSHA
		000026b8  ffde7805  JSR   0xffffde78 (TO 0x534)
		000026bc  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1018 start=2480 end=2486>
	<code>  f->ref++;</code>
	<emi>
		000026c0  0000100e  LL    0x10 (D 16)
		000026c4  00000454  ADDI  0x4 (D 4)
		000026c8  0000003e  LBA 
		000026cc  0000001c  LX  
		000026d0  ffffff57  SUBI  0xffffffff (D -1)
		000026d4  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1019 start=2486 end=2490>
	<code>  splx(e);</code>
	<emi>
		000026d8  0000040e  LL    0x4 (D 4)
		000026dc  0000009d  PSHA
		000026e0  ffd9c405  JSR   0xffffd9c4 (TO 0xa8)
		000026e4  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1020 start=2490 end=2492>
	<code>  return f;</code>
	<emi>
		000026e8  0000100e  LL    0x10 (D 16)
		000026ec  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1021 start=2492 end=2492>
	<code>}</code>
</stmt>
<stmt file=os.c line=1022 start=2492 end=2492>
	<code></code>
</stmt>
<stmt file=os.c line=1023 start=2492 end=2492>
	<code>// allocate a file descriptor for the given file.  Takes over file reference from caller on success.</code>
</stmt>
<stmt file=os.c line=1024 start=2492 end=2493>
	<code>int fdalloc(struct file *f)</code>
	<emi>
		000026f0  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1025 start=2493 end=2493>
	<code>{</code>
</stmt>
<stmt file=os.c line=1026 start=2493 end=2493>
	<code>  int fd;</code>
</stmt>
<stmt file=os.c line=1027 start=2493 end=2493>
	<code></code>
</stmt>
<stmt file=os.c line=1028 start=2493 end=2497>
	<code>  for (fd = 0; fd < NOFILE; fd++) {</code>
	<emi>
		000026f4  fffff801  ENT   0xfffffff8 (D -8)
		000026f8  00000023  LI    0x0 (D 0)
		000026fc  00000440  SL    0x4 (D 4)
		00002700  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1029 start=2497 end=2506>
	<code>    if (!u->ofile[fd]) {</code>
	<emi>
		00002704  00210015  LG    0x2100 (D 8448)
		00002708  00003054  ADDI  0x30 (D 48)
		0000270c  0000009d  PSHA
		00002710  00000c0e  LL    0xc (D 12)
		00002714  0000045a  MULI  0x4 (D 4)
		00002718  000000a1  POPB
		0000271c  00000053  ADD 
		00002720  0000001c  LX  
		00002724  00000086  BNZ   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1030 start=2506 end=2516>
	<code>      u->ofile[fd] = f;</code>
	<emi>
		00002728  00210015  LG    0x2100 (D 8448)
		0000272c  00003054  ADDI  0x30 (D 48)
		00002730  0000009d  PSHA
		00002734  00000c0e  LL    0xc (D 12)
		00002738  0000045a  MULI  0x4 (D 4)
		0000273c  000000a1  POPB
		00002740  00000053  ADD 
		00002744  0000003e  LBA 
		00002748  0000100e  LL    0x10 (D 16)
		0000274c  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1031 start=2516 end=2518>
	<code>      return fd;</code>
	<emi>
		00002750  0000040e  LL    0x4 (D 4)
		00002754  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1032 start=2518 end=2518>
	<code>    }</code>
</stmt>
<stmt file=os.c line=1033 start=2518 end=2518>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1034 start=2518 end=2526>
	<code>  return -1;</code>
	<emi>
		00002758  0000040e  LL    0x4 (D 4)
		0000275c  ffffff57  SUBI  0xffffffff (D -1)
		00002760  00000440  SL    0x4 (D 4)
		00002764  0000040e  LL    0x4 (D 4)
		00002768  0000103b  LBI   0x10 (D 16)
		0000276c  0000008c  BLT   <fwd>
		00002770  ffffff23  LI    0xffffffff (D -1)
		00002774  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1035 start=2526 end=2526>
	<code>}</code>
</stmt>
<stmt file=os.c line=1036 start=2526 end=2526>
	<code></code>
</stmt>
<stmt file=os.c line=1037 start=2526 end=2527>
	<code>struct inode *create(char *path, ushort mode, int dev)</code>
	<emi>
		00002778  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1038 start=2527 end=2527>
	<code>{</code>
</stmt>
<stmt file=os.c line=1039 start=2527 end=2527>
	<code>  struct inode *ip, *dp;</code>
</stmt>
<stmt file=os.c line=1040 start=2527 end=2527>
	<code>  char name[DIRSIZ];</code>
</stmt>
<stmt file=os.c line=1041 start=2527 end=2527>
	<code></code>
</stmt>
<stmt file=os.c line=1042 start=2527 end=2538>
	<code>  if (!(dp = nameiparent(path, name))) return 0;</code>
	<emi>
		0000277c  fffef801  ENT   0xfffffef8 (D -264)
		00002780  00000407  LEA   0x4 (D 4)
		00002784  0000009d  PSHA
		00002788  0001180e  LL    0x118 (D 280)
		0000278c  0000009d  PSHA
		00002790  fffa6805  JSR   0xfffffa68 (TO 0x21fc)
		00002794  00001001  ENT   0x10 (D 16)
		00002798  00010040  SL    0x100 (D 256)
		0000279c  00000086  BNZ   <fwd>
		000027a0  00000023  LI    0x0 (D 0)
		000027a4  00010802  LEV   0x108 (D 264)
	</emi>
</stmt>
<stmt file=os.c line=1043 start=2538 end=2542>
	<code>  ilock(dp);</code>
	<emi>
		000027a8  0001000e  LL    0x100 (D 256)
		000027ac  0000009d  PSHA
		000027b0  ffe9f405  JSR   0xffffe9f4 (TO 0x11a8)
		000027b4  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1044 start=2542 end=2542>
	<code></code>
</stmt>
<stmt file=os.c line=1045 start=2542 end=2551>
	<code>  if (ip = dirlookup(dp, name, 0)) {</code>
	<emi>
		000027b8  0000009e  PSHI  0x0 (D 0)
		000027bc  00000c07  LEA   0xc (D 12)
		000027c0  0000009d  PSHA
		000027c4  0001100e  LL    0x110 (D 272)
		000027c8  0000009d  PSHA
		000027cc  fff5ac05  JSR   0xfffff5ac (TO 0x1d7c)
		000027d0  00001801  ENT   0x18 (D 24)
		000027d4  00010440  SL    0x104 (D 260)
		000027d8  00000084  BZ    <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1046 start=2551 end=2555>
	<code>    iunlockput(dp);</code>
	<emi>
		000027dc  0001000e  LL    0x100 (D 256)
		000027e0  0000009d  PSHA
		000027e4  ffece805  JSR   0xffffece8 (TO 0x14d0)
		000027e8  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1047 start=2555 end=2559>
	<code>    ilock(ip);</code>
	<emi>
		000027ec  0001040e  LL    0x104 (D 260)
		000027f0  0000009d  PSHA
		000027f4  ffe9b005  JSR   0xffffe9b0 (TO 0x11a8)
		000027f8  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1048 start=2559 end=2570>
	<code>    if ((mode & S_IFMT) == S_IFREG && (ip->mode & S_IFMT) == S_IFREG) return ip;</code>
	<emi>
		000027fc  00011810  LLH   0x118 (D 280)
		00002800  00f00069  ANDI  0xf000 (D 61440)
		00002804  0080003b  LBI   0x8000 (D 32768)
		00002808  0000008a  BNE   <fwd>
		0000280c  0001040e  LL    0x104 (D 260)
		00002810  00000c1e  LXH   0xc (D 12)
		00002814  00f00069  ANDI  0xf000 (D 61440)
		00002818  0080003b  LBI   0x8000 (D 32768)
		0000281c  0028088a  BNE   <fwd>
		00002820  0001040e  LL    0x104 (D 260)
		00002824  00010802  LEV   0x108 (D 264)
	</emi>
</stmt>
<stmt file=os.c line=1049 start=2570 end=2574>
	<code>    iunlockput(ip);</code>
	<emi>
		00002828  0001040e  LL    0x104 (D 260)
		0000282c  0000009d  PSHA
		00002830  ffec9c05  JSR   0xffffec9c (TO 0x14d0)
		00002834  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1050 start=2574 end=2576>
	<code>    return 0;</code>
	<emi>
		00002838  00000023  LI    0x0 (D 0)
		0000283c  00010802  LEV   0x108 (D 264)
	</emi>
</stmt>
<stmt file=os.c line=1051 start=2576 end=2576>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1052 start=2576 end=2576>
	<code></code>
</stmt>
<stmt file=os.c line=1053 start=2576 end=2586>
	<code>  if (!(ip = ialloc(mode))) panic("create: ialloc");</code>
	<emi>
		00002840  00011810  LLH   0x118 (D 280)
		00002844  0000009d  PSHA
		00002848  ffe7c005  JSR   0xffffe7c0 (TO 0x100c)
		0000284c  00000801  ENT   0x8 (D 8)
		00002850  00010440  SL    0x104 (D 260)
		00002854  00000086  BNZ   <fwd>
		00002858  00019408  LEAG  0x194 (D 404)
		0000285c  0000009d  PSHA
		00002860  ffdcd005  JSR   0xffffdcd0 (TO 0x534)
		00002864  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1054 start=2586 end=2586>
	<code></code>
</stmt>
<stmt file=os.c line=1055 start=2586 end=2590>
	<code>  ilock(ip);</code>
	<emi>
		00002868  0001040e  LL    0x104 (D 260)
		0000286c  0000009d  PSHA
		00002870  ffe93405  JSR   0xffffe934 (TO 0x11a8)
		00002874  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1056 start=2590 end=2599>
	<code>  if ((mode & S_IFMT) == S_IFCHR || (ip->mode & S_IFMT) == S_IFBLK) {</code>
	<emi>
		00002878  00011810  LLH   0x118 (D 280)
		0000287c  00f00069  ANDI  0xf000 (D 61440)
		00002880  0020003b  LBI   0x2000 (D 8192)
		00002884  00000088  BE    <fwd>
		00002888  0001040e  LL    0x104 (D 260)
		0000288c  00000c1e  LXH   0xc (D 12)
		00002890  00f00069  ANDI  0xf000 (D 61440)
		00002894  0030003b  LBI   0x3000 (D 12288)
		00002898  0000008a  BNE   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1057 start=2599 end=2607>
	<code>    ip->dir[0] = (dev >> 8) & 0xff;</code>
	<emi>
		0000289c  0001040e  LL    0x104 (D 260)
		000028a0  00001854  ADDI  0x18 (D 24)
		000028a4  0000009d  PSHA
		000028a8  0001280e  LL    0x128 (D 296)
		000028ac  00000875  SHRI  0x8 (D 8)
		000028b0  0000ff69  ANDI  0xff (D 255)
		000028b4  000000a1  POPB
		000028b8  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1058 start=2607 end=2615>
	<code>    ip->dir[1] = dev & 0xff;</code>
	<emi>
		000028bc  0001040e  LL    0x104 (D 260)
		000028c0  00001854  ADDI  0x18 (D 24)
		000028c4  00000454  ADDI  0x4 (D 4)
		000028c8  0000009d  PSHA
		000028cc  0001280e  LL    0x128 (D 296)
		000028d0  0000ff69  ANDI  0xff (D 255)
		000028d4  000000a1  POPB
		000028d8  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1059 start=2615 end=2615>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1060 start=2615 end=2620>
	<code>  ip->nlink = 1;</code>
	<emi>
		000028dc  0001040e  LL    0x104 (D 260)
		000028e0  00001054  ADDI  0x10 (D 16)
		000028e4  0000003e  LBA 
		000028e8  00000123  LI    0x1 (D 1)
		000028ec  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1061 start=2620 end=2624>
	<code>  iupdate(ip);</code>
	<emi>
		000028f0  0001040e  LL    0x104 (D 260)
		000028f4  0000009d  PSHA
		000028f8  ffe79805  JSR   0xffffe798 (TO 0x1094)
		000028fc  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1062 start=2624 end=2624>
	<code></code>
</stmt>
<stmt file=os.c line=1063 start=2624 end=2628>
	<code>  if ((mode & S_IFMT) == S_IFDIR) {  // create . and .. entries</code>
	<emi>
		00002900  00011810  LLH   0x118 (D 280)
		00002904  00f00069  ANDI  0xf000 (D 61440)
		00002908  0040003b  LBI   0x4000 (D 16384)
		0000290c  0000008a  BNE   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1064 start=2628 end=2634>
	<code>    dp->nlink++;  // for ".."</code>
	<emi>
		00002910  0001000e  LL    0x100 (D 256)
		00002914  00001054  ADDI  0x10 (D 16)
		00002918  0000003e  LBA 
		0000291c  0000001c  LX  
		00002920  ffffff57  SUBI  0xffffffff (D -1)
		00002924  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1065 start=2634 end=2638>
	<code>    iupdate(dp);</code>
	<emi>
		00002928  0001000e  LL    0x100 (D 256)
		0000292c  0000009d  PSHA
		00002930  ffe76005  JSR   0xffffe760 (TO 0x1094)
		00002934  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1066 start=2638 end=2638>
	<code>    // no ip->nlink++ for ".": avoid cyclic ref count</code>
</stmt>
<stmt file=os.c line=1067 start=2638 end=2662>
	<code>    if (dirlink(ip, ".", ip->inum) || dirlink(ip, "..", dp->inum)) panic("create dots");</code>
	<emi>
		00002938  0001040e  LL    0x104 (D 260)
		0000293c  0000001c  LX  
		00002940  0000009d  PSHA
		00002944  0001a308  LEAG  0x1a3 (D 419)
		00002948  0000009d  PSHA
		0000294c  0001140e  LL    0x114 (D 276)
		00002950  0000009d  PSHA
		00002954  fff50c05  JSR   0xfffff50c (TO 0x1e64)
		00002958  00001801  ENT   0x18 (D 24)
		0000295c  00000086  BNZ   <fwd>
		00002960  0001000e  LL    0x100 (D 256)
		00002964  0000001c  LX  
		00002968  0000009d  PSHA
		0000296c  0001a508  LEAG  0x1a5 (D 421)
		00002970  0000009d  PSHA
		00002974  0001140e  LL    0x114 (D 276)
		00002978  0000009d  PSHA
		0000297c  fff4e405  JSR   0xfffff4e4 (TO 0x1e64)
		00002980  00001801  ENT   0x18 (D 24)
		00002984  00000084  BZ    <fwd>
		00002988  0001a808  LEAG  0x1a8 (D 424)
		0000298c  0000009d  PSHA
		00002990  ffdba005  JSR   0xffffdba0 (TO 0x534)
		00002994  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1068 start=2662 end=2662>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1069 start=2662 end=2662>
	<code></code>
</stmt>
<stmt file=os.c line=1070 start=2662 end=2676>
	<code>  if (dirlink(dp, name, ip->inum)) panic("create: dirlink");</code>
	<emi>
		00002998  0001040e  LL    0x104 (D 260)
		0000299c  0000001c  LX  
		000029a0  0000009d  PSHA
		000029a4  00000c07  LEA   0xc (D 12)
		000029a8  0000009d  PSHA
		000029ac  0001100e  LL    0x110 (D 272)
		000029b0  0000009d  PSHA
		000029b4  fff4ac05  JSR   0xfffff4ac (TO 0x1e64)
		000029b8  00001801  ENT   0x18 (D 24)
		000029bc  00000084  BZ    <fwd>
		000029c0  0001b408  LEAG  0x1b4 (D 436)
		000029c4  0000009d  PSHA
		000029c8  ffdb6805  JSR   0xffffdb68 (TO 0x534)
		000029cc  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1071 start=2676 end=2676>
	<code></code>
</stmt>
<stmt file=os.c line=1072 start=2676 end=2680>
	<code>  iunlockput(dp);</code>
	<emi>
		000029d0  0001000e  LL    0x100 (D 256)
		000029d4  0000009d  PSHA
		000029d8  ffeaf405  JSR   0xffffeaf4 (TO 0x14d0)
		000029dc  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1073 start=2680 end=2682>
	<code>  return ip;</code>
	<emi>
		000029e0  0001040e  LL    0x104 (D 260)
		000029e4  00010802  LEV   0x108 (D 264)
	</emi>
</stmt>
<stmt file=os.c line=1074 start=2682 end=2682>
	<code>}</code>
</stmt>
<stmt file=os.c line=1075 start=2682 end=2682>
	<code></code>
</stmt>
<stmt file=os.c line=1076 start=2682 end=2682>
	<code>// *** syscalls ***</code>
</stmt>
<stmt file=os.c line=1077 start=2682 end=2702>
	<code>int svalid(uint s) { return (s < u->sz) && memchr(s, 0, u->sz - s); }</code>
	<emi>
		000029e8  00010802  LEV   0x108 (D 264)
		000029ec  00210015  LG    0x2100 (D 8448)
		000029f0  0000081c  LX    0x8 (D 8)
		000029f4  0000003e  LBA 
		000029f8  0000080e  LL    0x8 (D 8)
		000029fc  00000090  BGEU  <fwd>
		00002a00  00210015  LG    0x2100 (D 8448)
		00002a04  0000081c  LX    0x8 (D 8)
		00002a08  00000858  SUBL  0x8 (D 8)
		00002a0c  0000009d  PSHA
		00002a10  0000009e  PSHI  0x0 (D 0)
		00002a14  0000180e  LL    0x18 (D 24)
		00002a18  0000009d  PSHA
		00002a1c  ffd61005  JSR   0xffffd610 (TO 0x30)
		00002a20  00001801  ENT   0x18 (D 24)
		00002a24  0029fc84  BZ    <fwd>
		00002a28  00000123  LI    0x1 (D 1)
		00002a2c  00000003  JMP   <fwd>
		00002a30  00000023  LI    0x0 (D 0)
		00002a34  00000002  LEV   0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=1078 start=2702 end=2718>
	<code>int mvalid(uint a, int n) { return a <= u->sz && a+n <= u->sz; }</code>
	<emi>
		00002a38  00000002  LEV   0x0 (D 0)
		00002a3c  00210015  LG    0x2100 (D 8448)
		00002a40  0000081c  LX    0x8 (D 8)
		00002a44  00000826  LBL   0x8 (D 8)
		00002a48  0000008d  BLTU  <fwd>
		00002a4c  0000080e  LL    0x8 (D 8)
		00002a50  00001055  ADDL  0x10 (D 16)
		00002a54  0000009d  PSHA
		00002a58  00210015  LG    0x2100 (D 8448)
		00002a5c  0000081c  LX    0x8 (D 8)
		00002a60  000000a1  POPB
		00002a64  002a488d  BLTU  <fwd>
		00002a68  00000123  LI    0x1 (D 1)
		00002a6c  00000003  JMP   <fwd>
		00002a70  00000023  LI    0x0 (D 0)
		00002a74  00000002  LEV   0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=1079 start=2718 end=2733>
	<code>struct file *getf(uint fd) { return (fd < NOFILE) ? u->ofile[fd] : 0; }</code>
	<emi>
		00002a78  00000002  LEV   0x0 (D 0)
		00002a7c  0000080e  LL    0x8 (D 8)
		00002a80  0000103b  LBI   0x10 (D 16)
		00002a84  00000090  BGEU  <fwd>
		00002a88  00210015  LG    0x2100 (D 8448)
		00002a8c  00003054  ADDI  0x30 (D 48)
		00002a90  0000009d  PSHA
		00002a94  0000100e  LL    0x10 (D 16)
		00002a98  0000045a  MULI  0x4 (D 4)
		00002a9c  000000a1  POPB
		00002aa0  00000053  ADD 
		00002aa4  0000001c  LX  
		00002aa8  00000003  JMP   <fwd>
		00002aac  00000023  LI    0x0 (D 0)
		00002ab0  00000002  LEV   0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=1080 start=2733 end=2733>
	<code></code>
</stmt>
<stmt file=os.c line=1081 start=2733 end=2738>
	<code>int sockopen(int family, int type, int protocol) { asm(LL,8); asm(LBL,16); asm(LCL,24); asm(NET1); }  </code>
	<emi>
		00002ab4  00000002  LEV   0x0 (D 0)
		00002ab8  0000080e  LL    0x8 (D 8)
		00002abc  00001026  LBL   0x10 (D 16)
		00002ac0  000018ac  LCL   0x18 (D 24)
		00002ac4  000000b3  NET1
	</emi>
</stmt>
<stmt file=os.c line=1082 start=2738 end=2741>
	<code>sockclose(int sd) { asm(LL,8); asm(NET2); } // XXX</code>
	<emi>
		00002ac8  00000002  LEV   0x0 (D 0)
		00002acc  0000080e  LL    0x8 (D 8)
		00002ad0  000000b4  NET2
	</emi>
</stmt>
<stmt file=os.c line=1083 start=2741 end=2746>
	<code>int sockconnect(int fd, uint family_port, uint addr) { asm(LL, 8); asm(LBL,16); asm(LCL,24); asm(NET3); }</code>
	<emi>
		00002ad4  00000002  LEV   0x0 (D 0)
		00002ad8  0000080e  LL    0x8 (D 8)
		00002adc  00001026  LBL   0x10 (D 16)
		00002ae0  000018ac  LCL   0x18 (D 24)
		00002ae4  000000b5  NET3
	</emi>
</stmt>
<stmt file=os.c line=1084 start=2746 end=2751>
	<code>int sockread (int sd, char *addr, int n) { asm(LL,8); asm(LBL,16); asm(LCL,24); asm(NET4); }</code>
	<emi>
		00002ae8  00000002  LEV   0x0 (D 0)
		00002aec  0000080e  LL    0x8 (D 8)
		00002af0  00001026  LBL   0x10 (D 16)
		00002af4  000018ac  LCL   0x18 (D 24)
		00002af8  000000b6  NET4
	</emi>
</stmt>
<stmt file=os.c line=1085 start=2751 end=2756>
	<code>int sockwrite(int sd, char *addr, int n) { asm(LL,8); asm(LBL,16); asm(LCL,24); asm(NET5); }</code>
	<emi>
		00002afc  00000002  LEV   0x0 (D 0)
		00002b00  0000080e  LL    0x8 (D 8)
		00002b04  00001026  LBL   0x10 (D 16)
		00002b08  000018ac  LCL   0x18 (D 24)
		00002b0c  000000b7  NET5
	</emi>
</stmt>
<stmt file=os.c line=1086 start=2756 end=2759>
	<code>int sockpoll(int sd) { asm(LL, 8); asm(NET6); }</code>
	<emi>
		00002b10  00000002  LEV   0x0 (D 0)
		00002b14  0000080e  LL    0x8 (D 8)
		00002b18  000000b8  NET6
	</emi>
</stmt>
<stmt file=os.c line=1087 start=2759 end=2760>
	<code>enum { M_OPEN, M_CLOSE, M_READ, M_WRITE, M_SEEK, M_FSTAT, M_SYNC };</code>
	<emi>
		00002b1c  00000002  LEV   0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=1088 start=2760 end=2760>
	<code></code>
</stmt>
<stmt file=os.c line=1089 start=2760 end=2760>
	<code>int socktx(int sd, void *p, int n)</code>
</stmt>
<stmt file=os.c line=1090 start=2760 end=2760>
	<code>{</code>
</stmt>
<stmt file=os.c line=1091 start=2760 end=2760>
	<code>  int r;</code>
</stmt>
<stmt file=os.c line=1092 start=2760 end=2762>
	<code>  while (n > 0) {</code>
	<emi>
		00002b20  fffff801  ENT   0xfffffff8 (D -8)
		00002b24  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1093 start=2762 end=2776>
	<code>    if ((r = sockwrite(sd, p, n)) <= 0) return -1;  // XXX need some kind of ready to write? XXX <= 0?</code>
	<emi>
		00002b28  0000200e  LL    0x20 (D 32)
		00002b2c  0000009d  PSHA
		00002b30  0000200e  LL    0x20 (D 32)
		00002b34  0000009d  PSHA
		00002b38  0000200e  LL    0x20 (D 32)
		00002b3c  0000009d  PSHA
		00002b40  ffffbc05  JSR   0xffffffbc (TO 0x2b00)
		00002b44  00001801  ENT   0x18 (D 24)
		00002b48  00000440  SL    0x4 (D 4)
		00002b4c  0000003e  LBA 
		00002b50  00000023  LI    0x0 (D 0)
		00002b54  0000008c  BLT   <fwd>
		00002b58  ffffff23  LI    0xffffffff (D -1)
		00002b5c  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1094 start=2776 end=2779>
	<code>    n -= r;</code>
	<emi>
		00002b60  0000200e  LL    0x20 (D 32)
		00002b64  00000458  SUBL  0x4 (D 4)
		00002b68  00002040  SL    0x20 (D 32)
	</emi>
</stmt>
<stmt file=os.c line=1095 start=2779 end=2782>
	<code>    p += r;</code>
	<emi>
		00002b6c  0000180e  LL    0x18 (D 24)
		00002b70  00000455  ADDL  0x4 (D 4)
		00002b74  00001840  SL    0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=1096 start=2782 end=2782>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1097 start=2782 end=2787>
	<code>  return 0;</code>
	<emi>
		00002b78  00000023  LI    0x0 (D 0)
		00002b7c  00002026  LBL   0x20 (D 32)
		00002b80  0000008c  BLT   <fwd>
		00002b84  00000023  LI    0x0 (D 0)
		00002b88  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1098 start=2787 end=2787>
	<code>}</code>
</stmt>
<stmt file=os.c line=1099 start=2787 end=2787>
	<code>// int cyc() { asm(CYC); } XXX</code>
</stmt>
<stmt file=os.c line=1100 start=2787 end=2788>
	<code>int sockrx(int sd, void *p, int n) // XXX this is always going to be slow until I fix the sockpoll (since ssleep waits for a comparitively long time (timer vs. em delta))</code>
	<emi>
		00002b8c  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1101 start=2788 end=2788>
	<code>{</code>
</stmt>
<stmt file=os.c line=1102 start=2788 end=2788>
	<code>  int r; // uint cy, nyc;</code>
</stmt>
<stmt file=os.c line=1103 start=2788 end=2790>
	<code>  while (n > 0) {</code>
	<emi>
		00002b90  fffff801  ENT   0xfffffff8 (D -8)
		00002b94  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1104 start=2790 end=2794>
	<code>    while (!sockpoll(sd)) ssleep(1); // XXX needs to block properly XXX should I lock the inode?</code>
	<emi>
		00002b98  00000003  JMP   <fwd>
		00002b9c  0000019e  PSHI  0x1 (D 1)
		00002ba0  00000005  JSR   <fwd>
		00002ba4  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1105 start=2794 end=2794>
	<code>//    while (!sockpoll(sd)) { printf("x"); ssleep(1); } // XXX needs to block properly XXX should I lock the inode?</code>
</stmt>
<stmt file=os.c line=1106 start=2794 end=2794>
	<code>//    while (!sockpoll(sd)) { cy = cyc(); for (r = 0; r < 10; r++) { nyc = cyc(); printf("[%d]",nyc - cy); cy = nyc; ssleep(100); } } // XXX needs to block properly XXX should I lock the inode?</code>
</stmt>
<stmt file=os.c line=1107 start=2794 end=2794>
	<code>//    while (!sockpoll(sd)) { cy = cyc(); for (r = 0; r < 10; r++) { nyc = cyc(); printf("[%d]",nyc - cy); cy = nyc; ssleep(1); } } // XXX needs to block properly XXX should I lock the inode?</code>
</stmt>
<stmt file=os.c line=1108 start=2794 end=2817>
	<code>    if ((r = sockread(sd, p, n)) <= 0) { printf("sockrx() sockread()\n"); return -1; } //  XXX <= 0?</code>
	<emi>
		00002ba8  0000100e  LL    0x10 (D 16)
		00002bac  0000009d  PSHA
		00002bb0  ffff6005  JSR   0xffffff60 (TO 0x2b14)
		00002bb4  00000801  ENT   0x8 (D 8)
		00002bb8  00000084  BZ    <fwd>
		00002bbc  0000200e  LL    0x20 (D 32)
		00002bc0  0000009d  PSHA
		00002bc4  0000200e  LL    0x20 (D 32)
		00002bc8  0000009d  PSHA
		00002bcc  0000200e  LL    0x20 (D 32)
		00002bd0  0000009d  PSHA
		00002bd4  ffff1405  JSR   0xffffff14 (TO 0x2aec)
		00002bd8  00001801  ENT   0x18 (D 24)
		00002bdc  00000440  SL    0x4 (D 4)
		00002be0  0000003e  LBA 
		00002be4  00000023  LI    0x0 (D 0)
		00002be8  0000008c  BLT   <fwd>
		00002bec  0001c408  LEAG  0x1c4 (D 452)
		00002bf0  0000009d  PSHA
		00002bf4  ffd7c005  JSR   0xffffd7c0 (TO 0x3b8)
		00002bf8  00000801  ENT   0x8 (D 8)
		00002bfc  ffffff23  LI    0xffffffff (D -1)
		00002c00  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1109 start=2817 end=2820>
	<code>    n -= r;</code>
	<emi>
		00002c04  0000200e  LL    0x20 (D 32)
		00002c08  00000458  SUBL  0x4 (D 4)
		00002c0c  00002040  SL    0x20 (D 32)
	</emi>
</stmt>
<stmt file=os.c line=1110 start=2820 end=2823>
	<code>    p += r; </code>
	<emi>
		00002c10  0000180e  LL    0x18 (D 24)
		00002c14  00000455  ADDL  0x4 (D 4)
		00002c18  00001840  SL    0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=1111 start=2823 end=2823>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1112 start=2823 end=2828>
	<code>  return 0;</code>
	<emi>
		00002c1c  00000023  LI    0x0 (D 0)
		00002c20  00002026  LBL   0x20 (D 32)
		00002c24  0000008c  BLT   <fwd>
		00002c28  00000023  LI    0x0 (D 0)
		00002c2c  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1113 start=2828 end=2828>
	<code>}</code>
</stmt>
<stmt file=os.c line=1114 start=2828 end=2828>
	<code></code>
</stmt>
<stmt file=os.c line=1115 start=2828 end=2829>
	<code>fileclose(struct file *f)</code>
	<emi>
		00002c30  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1116 start=2829 end=2829>
	<code>{</code>
</stmt>
<stmt file=os.c line=1117 start=2829 end=2829>
	<code>  struct file ff; int e = splhi();</code>
</stmt>
<stmt file=os.c line=1118 start=2829 end=2829>
	<code></code>
</stmt>
<stmt file=os.c line=1119 start=2829 end=2840>
	<code>  if (f->ref < 1) panic("close");</code>
	<emi>
		00002c34  ffffe001  ENT   0xffffffe0 (D -32)
		00002c38  ffd46405  JSR   0xffffd464 (TO 0xa0)
		00002c3c  00000440  SL    0x4 (D 4)
		00002c40  0000280e  LL    0x28 (D 40)
		00002c44  0000041c  LX    0x4 (D 4)
		00002c48  0000013b  LBI   0x1 (D 1)
		00002c4c  0000008f  BGE   <fwd>
		00002c50  0001d908  LEAG  0x1d9 (D 473)
		00002c54  0000009d  PSHA
		00002c58  ffd8d805  JSR   0xffffd8d8 (TO 0x534)
		00002c5c  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1120 start=2840 end=2849>
	<code>  if (--f->ref > 0) {</code>
	<emi>
		00002c60  0000280e  LL    0x28 (D 40)
		00002c64  00000454  ADDI  0x4 (D 4)
		00002c68  0000003e  LBA 
		00002c6c  0000001c  LX  
		00002c70  00000157  SUBI  0x1 (D 1)
		00002c74  0000004a  SX  
		00002c78  0000003e  LBA 
		00002c7c  00000023  LI    0x0 (D 0)
		00002c80  0000008f  BGE   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1121 start=2849 end=2853>
	<code>    splx(e);</code>
	<emi>
		00002c84  0000040e  LL    0x4 (D 4)
		00002c88  0000009d  PSHA
		00002c8c  ffd41805  JSR   0xffffd418 (TO 0xa8)
		00002c90  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1122 start=2853 end=2854>
	<code>    return;</code>
	<emi>
		00002c94  00002002  LEV   0x20 (D 32)
	</emi>
</stmt>
<stmt file=os.c line=1123 start=2854 end=2854>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1124 start=2854 end=2861>
	<code>  memcpy(&ff, f, sizeof(struct file)); //XXX  ff = *f;</code>
	<emi>
		00002c98  0000189e  PSHI  0x18 (D 24)
		00002c9c  0000300e  LL    0x30 (D 48)
		00002ca0  0000009d  PSHA
		00002ca4  00001807  LEA   0x18 (D 24)
		00002ca8  0000009d  PSHA
		00002cac  ffd35005  JSR   0xffffd350 (TO 0x0)
		00002cb0  00001801  ENT   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=1125 start=2861 end=2866>
	<code>  f->ref = 0;</code>
	<emi>
		00002cb4  0000280e  LL    0x28 (D 40)
		00002cb8  00000454  ADDI  0x4 (D 4)
		00002cbc  0000003e  LBA 
		00002cc0  00000023  LI    0x0 (D 0)
		00002cc4  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1126 start=2866 end=2869>
	<code>  f->type = FD_NONE;</code>
	<emi>
		00002cc8  00000023  LI    0x0 (D 0)
		00002ccc  00002826  LBL   0x28 (D 40)
		00002cd0  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1127 start=2869 end=2873>
	<code>  splx(e);</code>
	<emi>
		00002cd4  0000040e  LL    0x4 (D 4)
		00002cd8  0000009d  PSHA
		00002cdc  ffd3c805  JSR   0xffffd3c8 (TO 0xa8)
		00002ce0  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1128 start=2873 end=2873>
	<code>  </code>
</stmt>
<stmt file=os.c line=1129 start=2873 end=2875>
	<code>  switch (ff.type) {</code>
	<emi>
		00002ce4  0000080e  LL    0x8 (D 8)
		00002ce8  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1130 start=2875 end=2882>
	<code>  case FD_PIPE:   pipeclose(ff.pipe, ff.writable); break;</code>
	<emi>
		00002cec  00001111  LLC   0x11 (D 17)
		00002cf0  0000009d  PSHA
		00002cf4  00001c0e  LL    0x1c (D 28)
		00002cf8  0000009d  PSHA
		00002cfc  fff63005  JSR   0xfffff630 (TO 0x2330)
		00002d00  00001001  ENT   0x10 (D 16)
		00002d04  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1131 start=2882 end=2887>
	<code>  case FD_INODE:  iput(ff.ip); break;</code>
	<emi>
		00002d08  0000180e  LL    0x18 (D 24)
		00002d0c  0000009d  PSHA
		00002d10  ffe6ac05  JSR   0xffffe6ac (TO 0x13c0)
		00002d14  00000801  ENT   0x8 (D 8)
		00002d18  002d0403  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1132 start=2887 end=2887>
	<code>  case FD_SOCKET:</code>
</stmt>
<stmt file=os.c line=1133 start=2887 end=2891>
	<code>  case FD_RFS:    sockclose(ff.off);</code>
	<emi>
		00002d1c  00001c0e  LL    0x1c (D 28)
		00002d20  0000009d  PSHA
		00002d24  fffda405  JSR   0xfffffda4 (TO 0x2acc)
		00002d28  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1134 start=2891 end=2891>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1135 start=2891 end=2895>
	<code>}</code>
	<emi>
		00002d2c  002d1803  JMP   <fwd>
		00002d30  0000053b  LBI   0x5 (D 5)
		00002d34  002d2c90  BGEU  <fwd>
		00002d38  0001e004  JMPI  0x1e0 (D 480)
	</emi>
</stmt>
<stmt file=os.c line=1136 start=2895 end=2895>
	<code></code>
</stmt>
<stmt file=os.c line=1137 start=2895 end=2896>
	<code>int close(int fd)</code>
	<emi>
		00002d3c  00002002  LEV   0x20 (D 32)
	</emi>
</stmt>
<stmt file=os.c line=1138 start=2896 end=2896>
	<code>{</code>
</stmt>
<stmt file=os.c line=1139 start=2896 end=2896>
	<code>  struct file *f;</code>
</stmt>
<stmt file=os.c line=1140 start=2896 end=2905>
	<code>  if (!(f = getf(fd))) return -1;</code>
	<emi>
		00002d40  fffff801  ENT   0xfffffff8 (D -8)
		00002d44  0000100e  LL    0x10 (D 16)
		00002d48  0000009d  PSHA
		00002d4c  fffd2c05  JSR   0xfffffd2c (TO 0x2a7c)
		00002d50  00000801  ENT   0x8 (D 8)
		00002d54  00000440  SL    0x4 (D 4)
		00002d58  00000086  BNZ   <fwd>
		00002d5c  ffffff23  LI    0xffffffff (D -1)
		00002d60  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1141 start=2905 end=2915>
	<code>  u->ofile[fd] = 0;</code>
	<emi>
		00002d64  00210015  LG    0x2100 (D 8448)
		00002d68  00003054  ADDI  0x30 (D 48)
		00002d6c  0000009d  PSHA
		00002d70  0000180e  LL    0x18 (D 24)
		00002d74  0000045a  MULI  0x4 (D 4)
		00002d78  000000a1  POPB
		00002d7c  00000053  ADD 
		00002d80  0000003e  LBA 
		00002d84  00000023  LI    0x0 (D 0)
		00002d88  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1142 start=2915 end=2919>
	<code>  fileclose(f);</code>
	<emi>
		00002d8c  0000040e  LL    0x4 (D 4)
		00002d90  0000009d  PSHA
		00002d94  fffe9c05  JSR   0xfffffe9c (TO 0x2c34)
		00002d98  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1143 start=2919 end=2921>
	<code>  return 0;</code>
	<emi>
		00002d9c  00000023  LI    0x0 (D 0)
		00002da0  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1144 start=2921 end=2921>
	<code>}</code>
</stmt>
<stmt file=os.c line=1145 start=2921 end=2921>
	<code></code>
</stmt>
<stmt file=os.c line=1146 start=2921 end=2922>
	<code>int fstat(int fd, struct stat *st)</code>
	<emi>
		00002da4  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1147 start=2922 end=2922>
	<code>{</code>
</stmt>
<stmt file=os.c line=1148 start=2922 end=2922>
	<code>  int r; struct file *f;</code>
</stmt>
<stmt file=os.c line=1149 start=2922 end=2937>
	<code>  if (!(f = getf(fd)) || !mvalid(st, sizeof(struct stat))) return -1;</code>
	<emi>
		00002da8  fffff801  ENT   0xfffffff8 (D -8)
		00002dac  0000100e  LL    0x10 (D 16)
		00002db0  0000009d  PSHA
		00002db4  fffcc405  JSR   0xfffffcc4 (TO 0x2a7c)
		00002db8  00000801  ENT   0x8 (D 8)
		00002dbc  00000040  SL    0x0 (D 0)
		00002dc0  00000084  BZ    <fwd>
		00002dc4  0000109e  PSHI  0x10 (D 16)
		00002dc8  0000200e  LL    0x20 (D 32)
		00002dcc  0000009d  PSHA
		00002dd0  fffc6805  JSR   0xfffffc68 (TO 0x2a3c)
		00002dd4  00001001  ENT   0x10 (D 16)
		00002dd8  00000086  BNZ   <fwd>
		00002ddc  ffffff23  LI    0xffffffff (D -1)
		00002de0  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1150 start=2937 end=2940>
	<code>  switch (f->type) {</code>
	<emi>
		00002de4  0000000e  LL    0x0 (D 0)
		00002de8  0000001c  LX  
		00002dec  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1151 start=2940 end=2940>
	<code>  case FD_INODE:</code>
</stmt>
<stmt file=os.c line=1152 start=2940 end=2945>
	<code>    ilock(f->ip);</code>
	<emi>
		00002df0  0000000e  LL    0x0 (D 0)
		00002df4  0000101c  LX    0x10 (D 16)
		00002df8  0000009d  PSHA
		00002dfc  ffe3a805  JSR   0xffffe3a8 (TO 0x11a8)
		00002e00  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1153 start=2945 end=2952>
	<code>    stati(f->ip, st);</code>
	<emi>
		00002e04  0000180e  LL    0x18 (D 24)
		00002e08  0000009d  PSHA
		00002e0c  0000080e  LL    0x8 (D 8)
		00002e10  0000101c  LX    0x10 (D 16)
		00002e14  0000009d  PSHA
		00002e18  ffea6c05  JSR   0xffffea6c (TO 0x1888)
		00002e1c  00001001  ENT   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1154 start=2952 end=2957>
	<code>    iunlock(f->ip);</code>
	<emi>
		00002e20  0000000e  LL    0x0 (D 0)
		00002e24  0000101c  LX    0x10 (D 16)
		00002e28  0000009d  PSHA
		00002e2c  ffe51005  JSR   0xffffe510 (TO 0x1340)
		00002e30  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1155 start=2957 end=2959>
	<code>    return 0;</code>
	<emi>
		00002e34  00000023  LI    0x0 (D 0)
		00002e38  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1156 start=2959 end=2959>
	<code> case FD_RFS:</code>
</stmt>
<stmt file=os.c line=1157 start=2959 end=2961>
	<code>    r = M_FSTAT;</code>
	<emi>
		00002e3c  00000523  LI    0x5 (D 5)
		00002e40  00000440  SL    0x4 (D 4)
	</emi>
</stmt>
<stmt file=os.c line=1158 start=2961 end=2993>
	<code>    if (socktx(f->off, &r, 4) || sockrx(f->off, &r, 4) || (r == 0 && sockrx(f->off, st, sizeof(struct stat)))) return -1;</code>
	<emi>
		00002e44  0000049e  PSHI  0x4 (D 4)
		00002e48  00000c07  LEA   0xc (D 12)
		00002e4c  0000009d  PSHA
		00002e50  0000100e  LL    0x10 (D 16)
		00002e54  0000141c  LX    0x14 (D 20)
		00002e58  0000009d  PSHA
		00002e5c  fffcc005  JSR   0xfffffcc0 (TO 0x2b20)
		00002e60  00001801  ENT   0x18 (D 24)
		00002e64  00000086  BNZ   <fwd>
		00002e68  0000049e  PSHI  0x4 (D 4)
		00002e6c  00000c07  LEA   0xc (D 12)
		00002e70  0000009d  PSHA
		00002e74  0000100e  LL    0x10 (D 16)
		00002e78  0000141c  LX    0x14 (D 20)
		00002e7c  0000009d  PSHA
		00002e80  fffd0c05  JSR   0xfffffd0c (TO 0x2b90)
		00002e84  00001801  ENT   0x18 (D 24)
		00002e88  002e6486  BNZ   <fwd>
		00002e8c  0000040e  LL    0x4 (D 4)
		00002e90  0000003b  LBI   0x0 (D 0)
		00002e94  0000008a  BNE   <fwd>
		00002e98  0000109e  PSHI  0x10 (D 16)
		00002e9c  0000200e  LL    0x20 (D 32)
		00002ea0  0000009d  PSHA
		00002ea4  0000100e  LL    0x10 (D 16)
		00002ea8  0000141c  LX    0x14 (D 20)
		00002eac  0000009d  PSHA
		00002eb0  fffcdc05  JSR   0xfffffcdc (TO 0x2b90)
		00002eb4  00001801  ENT   0x18 (D 24)
		00002eb8  002e9484  BZ    <fwd>
		00002ebc  ffffff23  LI    0xffffffff (D -1)
		00002ec0  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1159 start=2993 end=2995>
	<code>    return r;</code>
	<emi>
		00002ec4  0000040e  LL    0x4 (D 4)
		00002ec8  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1160 start=2995 end=2995>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1161 start=2995 end=3001>
	<code>  return -1;</code>
	<emi>
		00002ecc  00000003  JMP   <fwd>
		00002ed0  0000053b  LBI   0x5 (D 5)
		00002ed4  002ecc90  BGEU  <fwd>
		00002ed8  0001f404  JMPI  0x1f4 (D 500)
		00002edc  ffffff23  LI    0xffffffff (D -1)
		00002ee0  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1162 start=3001 end=3001>
	<code>}</code>
</stmt>
<stmt file=os.c line=1163 start=3001 end=3001>
	<code></code>
</stmt>
<stmt file=os.c line=1164 start=3001 end=3002>
	<code>int read(int fd, char *addr, int n)</code>
	<emi>
		00002ee4  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1165 start=3002 end=3002>
	<code>{</code>
</stmt>
<stmt file=os.c line=1166 start=3002 end=3002>
	<code>  int r; int h[2]; struct file *f;</code>
</stmt>
<stmt file=os.c line=1167 start=3002 end=3021>
	<code>  if (!(f = getf(fd)) || !f->readable || !mvalid(addr, n)) return -1;</code>
	<emi>
		00002ee8  fffff001  ENT   0xfffffff0 (D -16)
		00002eec  0000180e  LL    0x18 (D 24)
		00002ef0  0000009d  PSHA
		00002ef4  fffb8405  JSR   0xfffffb84 (TO 0x2a7c)
		00002ef8  00000801  ENT   0x8 (D 8)
		00002efc  00000040  SL    0x0 (D 0)
		00002f00  00000084  BZ    <fwd>
		00002f04  0000000e  LL    0x0 (D 0)
		00002f08  0000081f  LXC   0x8 (D 8)
		00002f0c  002f0084  BZ    <fwd>
		00002f10  0000280e  LL    0x28 (D 40)
		00002f14  0000009d  PSHA
		00002f18  0000280e  LL    0x28 (D 40)
		00002f1c  0000009d  PSHA
		00002f20  fffb1805  JSR   0xfffffb18 (TO 0x2a3c)
		00002f24  00001001  ENT   0x10 (D 16)
		00002f28  00000086  BNZ   <fwd>
		00002f2c  ffffff23  LI    0xffffffff (D -1)
		00002f30  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1168 start=3021 end=3024>
	<code>  switch (f->type) {</code>
	<emi>
		00002f34  0000000e  LL    0x0 (D 0)
		00002f38  0000001c  LX  
		00002f3c  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1169 start=3024 end=3034>
	<code>  case FD_PIPE: return piperead(f->pipe, addr, n);</code>
	<emi>
		00002f40  0000280e  LL    0x28 (D 40)
		00002f44  0000009d  PSHA
		00002f48  0000280e  LL    0x28 (D 40)
		00002f4c  0000009d  PSHA
		00002f50  0000100e  LL    0x10 (D 16)
		00002f54  00000c1c  LX    0xc (D 12)
		00002f58  0000009d  PSHA
		00002f5c  fff58c05  JSR   0xfffff58c (TO 0x24ec)
		00002f60  00001801  ENT   0x18 (D 24)
		00002f64  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1170 start=3034 end=3034>
	<code>  case FD_SOCKET:</code>
</stmt>
<stmt file=os.c line=1171 start=3034 end=3038>
	<code>    while (!sockpoll(f->off)) ssleep(1); // XXX needs to block properly XXX should I lock the inode? (right now there isn't an inode!)</code>
	<emi>
		00002f68  00000003  JMP   <fwd>
		00002f6c  0000019e  PSHI  0x1 (D 1)
		00002f70  002ba005  JSR   <fwd>
		00002f74  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1172 start=3038 end=3054>
	<code>    return sockread(f->off, addr, n);</code>
	<emi>
		00002f78  0000000e  LL    0x0 (D 0)
		00002f7c  0000141c  LX    0x14 (D 20)
		00002f80  0000009d  PSHA
		00002f84  fffb8c05  JSR   0xfffffb8c (TO 0x2b14)
		00002f88  00000801  ENT   0x8 (D 8)
		00002f8c  00000084  BZ    <fwd>
		00002f90  0000280e  LL    0x28 (D 40)
		00002f94  0000009d  PSHA
		00002f98  0000280e  LL    0x28 (D 40)
		00002f9c  0000009d  PSHA
		00002fa0  0000100e  LL    0x10 (D 16)
		00002fa4  0000141c  LX    0x14 (D 20)
		00002fa8  0000009d  PSHA
		00002fac  fffb3c05  JSR   0xfffffb3c (TO 0x2aec)
		00002fb0  00001801  ENT   0x18 (D 24)
		00002fb4  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1173 start=3054 end=3054>
	<code>  case FD_INODE:</code>
</stmt>
<stmt file=os.c line=1174 start=3054 end=3059>
	<code>    ilock(f->ip);</code>
	<emi>
		00002fb8  0000000e  LL    0x0 (D 0)
		00002fbc  0000101c  LX    0x10 (D 16)
		00002fc0  0000009d  PSHA
		00002fc4  ffe1e005  JSR   0xffffe1e0 (TO 0x11a8)
		00002fc8  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1175 start=3059 end=3081>
	<code>    if ((r = readi(f->ip, addr, f->off, n)) > 0) f->off += r;</code>
	<emi>
		00002fcc  0000280e  LL    0x28 (D 40)
		00002fd0  0000009d  PSHA
		00002fd4  0000080e  LL    0x8 (D 8)
		00002fd8  0000141c  LX    0x14 (D 20)
		00002fdc  0000009d  PSHA
		00002fe0  0000300e  LL    0x30 (D 48)
		00002fe4  0000009d  PSHA
		00002fe8  0000180e  LL    0x18 (D 24)
		00002fec  0000101c  LX    0x10 (D 16)
		00002ff0  0000009d  PSHA
		00002ff4  ffe91005  JSR   0xffffe910 (TO 0x1908)
		00002ff8  00002001  ENT   0x20 (D 32)
		00002ffc  00000c40  SL    0xc (D 12)
		00003000  0000003e  LBA 
		00003004  00000023  LI    0x0 (D 0)
		00003008  0000008f  BGE   <fwd>
		0000300c  0000000e  LL    0x0 (D 0)
		00003010  00001454  ADDI  0x14 (D 20)
		00003014  0000003e  LBA 
		00003018  0000001c  LX  
		0000301c  00000c55  ADDL  0xc (D 12)
		00003020  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1176 start=3081 end=3086>
	<code>    iunlock(f->ip);</code>
	<emi>
		00003024  0000000e  LL    0x0 (D 0)
		00003028  0000101c  LX    0x10 (D 16)
		0000302c  0000009d  PSHA
		00003030  ffe30c05  JSR   0xffffe30c (TO 0x1340)
		00003034  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1177 start=3086 end=3088>
	<code>    return r;</code>
	<emi>
		00003038  00000c0e  LL    0xc (D 12)
		0000303c  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1178 start=3088 end=3088>
	<code>  case FD_RFS:</code>
</stmt>
<stmt file=os.c line=1179 start=3088 end=3090>
	<code>    h[0] = M_READ; // XXX lock the inode</code>
	<emi>
		00003040  00000223  LI    0x2 (D 2)
		00003044  00000440  SL    0x4 (D 4)
	</emi>
</stmt>
<stmt file=os.c line=1180 start=3090 end=3092>
	<code>    h[1] = n;</code>
	<emi>
		00003048  0000280e  LL    0x28 (D 40)
		0000304c  00000840  SL    0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1181 start=3092 end=3125>
	<code>    if (socktx(f->off, h, 8) || sockrx(f->off, &r, 4) || ((uint)r <= n && sockrx(f->off, addr, r))) return -1; // XXX need to zortch the file  is this correct for zero?</code>
	<emi>
		00003050  0000089e  PSHI  0x8 (D 8)
		00003054  00000c07  LEA   0xc (D 12)
		00003058  0000009d  PSHA
		0000305c  0000100e  LL    0x10 (D 16)
		00003060  0000141c  LX    0x14 (D 20)
		00003064  0000009d  PSHA
		00003068  fffab405  JSR   0xfffffab4 (TO 0x2b20)
		0000306c  00001801  ENT   0x18 (D 24)
		00003070  00000086  BNZ   <fwd>
		00003074  0000049e  PSHI  0x4 (D 4)
		00003078  00001407  LEA   0x14 (D 20)
		0000307c  0000009d  PSHA
		00003080  0000100e  LL    0x10 (D 16)
		00003084  0000141c  LX    0x14 (D 20)
		00003088  0000009d  PSHA
		0000308c  fffb0005  JSR   0xfffffb00 (TO 0x2b90)
		00003090  00001801  ENT   0x18 (D 24)
		00003094  00307086  BNZ   <fwd>
		00003098  0000280e  LL    0x28 (D 40)
		0000309c  00000c26  LBL   0xc (D 12)
		000030a0  0000008d  BLTU  <fwd>
		000030a4  00000c0e  LL    0xc (D 12)
		000030a8  0000009d  PSHA
		000030ac  0000280e  LL    0x28 (D 40)
		000030b0  0000009d  PSHA
		000030b4  0000100e  LL    0x10 (D 16)
		000030b8  0000141c  LX    0x14 (D 20)
		000030bc  0000009d  PSHA
		000030c0  fffacc05  JSR   0xfffffacc (TO 0x2b90)
		000030c4  00001801  ENT   0x18 (D 24)
		000030c8  0030a084  BZ    <fwd>
		000030cc  ffffff23  LI    0xffffffff (D -1)
		000030d0  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1182 start=3125 end=3127>
	<code>    return r;</code>
	<emi>
		000030d4  00000c0e  LL    0xc (D 12)
		000030d8  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1183 start=3127 end=3127>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1184 start=3127 end=3135>
	<code>  panic("read");</code>
	<emi>
		000030dc  00000003  JMP   <fwd>
		000030e0  0000053b  LBI   0x5 (D 5)
		000030e4  0030dc90  BGEU  <fwd>
		000030e8  00020804  JMPI  0x208 (D 520)
		000030ec  00021c08  LEAG  0x21c (D 540)
		000030f0  0000009d  PSHA
		000030f4  ffd43c05  JSR   0xffffd43c (TO 0x534)
		000030f8  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1185 start=3135 end=3135>
	<code>}</code>
</stmt>
<stmt file=os.c line=1186 start=3135 end=3136>
	<code>int write(int fd, char *addr, int n)</code>
	<emi>
		000030fc  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1187 start=3136 end=3136>
	<code>{</code>
</stmt>
<stmt file=os.c line=1188 start=3136 end=3136>
	<code>  int r, h[2]; struct file *f;</code>
</stmt>
<stmt file=os.c line=1189 start=3136 end=3155>
	<code>  if (!(f = getf(fd)) || !f->writable || !mvalid(addr, n)) return -1;</code>
	<emi>
		00003100  fffff001  ENT   0xfffffff0 (D -16)
		00003104  0000180e  LL    0x18 (D 24)
		00003108  0000009d  PSHA
		0000310c  fff96c05  JSR   0xfffff96c (TO 0x2a7c)
		00003110  00000801  ENT   0x8 (D 8)
		00003114  00000040  SL    0x0 (D 0)
		00003118  00000084  BZ    <fwd>
		0000311c  0000000e  LL    0x0 (D 0)
		00003120  0000091f  LXC   0x9 (D 9)
		00003124  00311884  BZ    <fwd>
		00003128  0000280e  LL    0x28 (D 40)
		0000312c  0000009d  PSHA
		00003130  0000280e  LL    0x28 (D 40)
		00003134  0000009d  PSHA
		00003138  fff90005  JSR   0xfffff900 (TO 0x2a3c)
		0000313c  00001001  ENT   0x10 (D 16)
		00003140  00000086  BNZ   <fwd>
		00003144  ffffff23  LI    0xffffffff (D -1)
		00003148  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1190 start=3155 end=3158>
	<code>  switch (f->type) {</code>
	<emi>
		0000314c  0000000e  LL    0x0 (D 0)
		00003150  0000001c  LX  
		00003154  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1191 start=3158 end=3168>
	<code>  case FD_PIPE: return pipewrite(f->pipe, addr, n);</code>
	<emi>
		00003158  0000280e  LL    0x28 (D 40)
		0000315c  0000009d  PSHA
		00003160  0000280e  LL    0x28 (D 40)
		00003164  0000009d  PSHA
		00003168  0000100e  LL    0x10 (D 16)
		0000316c  00000c1c  LX    0xc (D 12)
		00003170  0000009d  PSHA
		00003174  fff25c05  JSR   0xfffff25c (TO 0x23d4)
		00003178  00001801  ENT   0x18 (D 24)
		0000317c  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1192 start=3168 end=3178>
	<code>  case FD_SOCKET: return sockwrite(f->off, addr, n); // XXX needs to block</code>
	<emi>
		00003180  0000280e  LL    0x28 (D 40)
		00003184  0000009d  PSHA
		00003188  0000280e  LL    0x28 (D 40)
		0000318c  0000009d  PSHA
		00003190  0000100e  LL    0x10 (D 16)
		00003194  0000141c  LX    0x14 (D 20)
		00003198  0000009d  PSHA
		0000319c  fff96005  JSR   0xfffff960 (TO 0x2b00)
		000031a0  00001801  ENT   0x18 (D 24)
		000031a4  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1193 start=3178 end=3178>
	<code>  case FD_INODE:</code>
</stmt>
<stmt file=os.c line=1194 start=3178 end=3183>
	<code>    ilock(f->ip);</code>
	<emi>
		000031a8  0000000e  LL    0x0 (D 0)
		000031ac  0000101c  LX    0x10 (D 16)
		000031b0  0000009d  PSHA
		000031b4  ffdff005  JSR   0xffffdff0 (TO 0x11a8)
		000031b8  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1195 start=3183 end=3205>
	<code>    if ((r = writei(f->ip, addr, f->off, n)) > 0) f->off += r;</code>
	<emi>
		000031bc  0000280e  LL    0x28 (D 40)
		000031c0  0000009d  PSHA
		000031c4  0000080e  LL    0x8 (D 8)
		000031c8  0000141c  LX    0x14 (D 20)
		000031cc  0000009d  PSHA
		000031d0  0000300e  LL    0x30 (D 48)
		000031d4  0000009d  PSHA
		000031d8  0000180e  LL    0x18 (D 24)
		000031dc  0000101c  LX    0x10 (D 16)
		000031e0  0000009d  PSHA
		000031e4  ffe8f005  JSR   0xffffe8f0 (TO 0x1ad8)
		000031e8  00002001  ENT   0x20 (D 32)
		000031ec  00000c40  SL    0xc (D 12)
		000031f0  0000003e  LBA 
		000031f4  00000023  LI    0x0 (D 0)
		000031f8  0000008f  BGE   <fwd>
		000031fc  0000000e  LL    0x0 (D 0)
		00003200  00001454  ADDI  0x14 (D 20)
		00003204  0000003e  LBA 
		00003208  0000001c  LX  
		0000320c  00000c55  ADDL  0xc (D 12)
		00003210  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1196 start=3205 end=3210>
	<code>    iunlock(f->ip);</code>
	<emi>
		00003214  0000000e  LL    0x0 (D 0)
		00003218  0000101c  LX    0x10 (D 16)
		0000321c  0000009d  PSHA
		00003220  ffe11c05  JSR   0xffffe11c (TO 0x1340)
		00003224  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1197 start=3210 end=3212>
	<code>    return r;</code>
	<emi>
		00003228  00000c0e  LL    0xc (D 12)
		0000322c  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1198 start=3212 end=3212>
	<code>  case FD_RFS:</code>
</stmt>
<stmt file=os.c line=1199 start=3212 end=3214>
	<code>    h[0] = M_WRITE; // XXX lock the inode</code>
	<emi>
		00003230  00000323  LI    0x3 (D 3)
		00003234  00000440  SL    0x4 (D 4)
	</emi>
</stmt>
<stmt file=os.c line=1200 start=3214 end=3216>
	<code>    h[1] = n;</code>
	<emi>
		00003238  0000280e  LL    0x28 (D 40)
		0000323c  00000840  SL    0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1201 start=3216 end=3240>
	<code>    if (socktx(f->off, h, 8) || (n > 0 && socktx(f->off, addr, n))) return -1; // XXX need to zortch the file</code>
	<emi>
		00003240  0000089e  PSHI  0x8 (D 8)
		00003244  00000c07  LEA   0xc (D 12)
		00003248  0000009d  PSHA
		0000324c  0000100e  LL    0x10 (D 16)
		00003250  0000141c  LX    0x14 (D 20)
		00003254  0000009d  PSHA
		00003258  fff8c405  JSR   0xfffff8c4 (TO 0x2b20)
		0000325c  00001801  ENT   0x18 (D 24)
		00003260  00000086  BNZ   <fwd>
		00003264  00000023  LI    0x0 (D 0)
		00003268  00002826  LBL   0x28 (D 40)
		0000326c  0000008f  BGE   <fwd>
		00003270  0000280e  LL    0x28 (D 40)
		00003274  0000009d  PSHA
		00003278  0000280e  LL    0x28 (D 40)
		0000327c  0000009d  PSHA
		00003280  0000100e  LL    0x10 (D 16)
		00003284  0000141c  LX    0x14 (D 20)
		00003288  0000009d  PSHA
		0000328c  fff89005  JSR   0xfffff890 (TO 0x2b20)
		00003290  00001801  ENT   0x18 (D 24)
		00003294  00326c84  BZ    <fwd>
		00003298  ffffff23  LI    0xffffffff (D -1)
		0000329c  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1202 start=3240 end=3242>
	<code>    return n;</code>
	<emi>
		000032a0  0000280e  LL    0x28 (D 40)
		000032a4  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1203 start=3242 end=3242>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1204 start=3242 end=3250>
	<code>  panic("write");</code>
	<emi>
		000032a8  00000003  JMP   <fwd>
		000032ac  0000053b  LBI   0x5 (D 5)
		000032b0  0032a890  BGEU  <fwd>
		000032b4  00022404  JMPI  0x224 (D 548)
		000032b8  00023808  LEAG  0x238 (D 568)
		000032bc  0000009d  PSHA
		000032c0  ffd27005  JSR   0xffffd270 (TO 0x534)
		000032c4  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1205 start=3250 end=3250>
	<code>}</code>
</stmt>
<stmt file=os.c line=1206 start=3250 end=3250>
	<code></code>
</stmt>
<stmt file=os.c line=1207 start=3250 end=3251>
	<code>int lseek(int fd, int offset, uint whence)</code>
	<emi>
		000032c8  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1208 start=3251 end=3251>
	<code>{</code>
</stmt>
<stmt file=os.c line=1209 start=3251 end=3251>
	<code>  int r, h[3]; struct file *f;</code>
</stmt>
<stmt file=os.c line=1210 start=3251 end=3263>
	<code>  if (!(f = getf(fd)) || whence > SEEK_END) return -1;</code>
	<emi>
		000032cc  ffffe801  ENT   0xffffffe8 (D -24)
		000032d0  0000200e  LL    0x20 (D 32)
		000032d4  0000009d  PSHA
		000032d8  fff7a005  JSR   0xfffff7a0 (TO 0x2a7c)
		000032dc  00000801  ENT   0x8 (D 8)
		000032e0  00000440  SL    0x4 (D 4)
		000032e4  00000084  BZ    <fwd>
		000032e8  00000223  LI    0x2 (D 2)
		000032ec  00003026  LBL   0x30 (D 48)
		000032f0  00000090  BGEU  <fwd>
		000032f4  ffffff23  LI    0xffffffff (D -1)
		000032f8  00001802  LEV   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=1211 start=3263 end=3266>
	<code>  switch (f->type) {</code>
	<emi>
		000032fc  0000040e  LL    0x4 (D 4)
		00003300  0000001c  LX  
		00003304  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1212 start=3266 end=3266>
	<code>  case FD_INODE:</code>
</stmt>
<stmt file=os.c line=1213 start=3266 end=3271>
	<code>    ilock(f->ip);</code>
	<emi>
		00003308  0000040e  LL    0x4 (D 4)
		0000330c  0000101c  LX    0x10 (D 16)
		00003310  0000009d  PSHA
		00003314  ffde9005  JSR   0xffffde90 (TO 0x11a8)
		00003318  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1214 start=3271 end=3273>
	<code>    switch (whence) {</code>
	<emi>
		0000331c  0000300e  LL    0x30 (D 48)
		00003320  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1215 start=3273 end=3280>
	<code>    case SEEK_SET: r = f->off = offset; break;</code>
	<emi>
		00003324  0000040e  LL    0x4 (D 4)
		00003328  00001454  ADDI  0x14 (D 20)
		0000332c  0000003e  LBA 
		00003330  0000280e  LL    0x28 (D 40)
		00003334  0000004a  SX  
		00003338  00001440  SL    0x14 (D 20)
		0000333c  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1216 start=3280 end=3288>
	<code>    case SEEK_CUR: r = f->off += offset; break;</code>
	<emi>
		00003340  0000040e  LL    0x4 (D 4)
		00003344  00001454  ADDI  0x14 (D 20)
		00003348  0000003e  LBA 
		0000334c  0000001c  LX  
		00003350  00002855  ADDL  0x28 (D 40)
		00003354  0000004a  SX  
		00003358  00001440  SL    0x14 (D 20)
		0000335c  00333c03  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1217 start=3288 end=3299>
	<code>    case SEEK_END: r = f->off = f->ip->size - offset; break; // XXX verify</code>
	<emi>
		00003360  0000040e  LL    0x4 (D 4)
		00003364  00001454  ADDI  0x14 (D 20)
		00003368  0000009d  PSHA
		0000336c  00000c0e  LL    0xc (D 12)
		00003370  0000101c  LX    0x10 (D 16)
		00003374  0000141c  LX    0x14 (D 20)
		00003378  00003058  SUBL  0x30 (D 48)
		0000337c  000000a1  POPB
		00003380  0000004a  SX  
		00003384  00001440  SL    0x14 (D 20)
		00003388  00335c03  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1218 start=3299 end=3299>
	<code>    }</code>
</stmt>
<stmt file=os.c line=1219 start=3299 end=3308>
	<code>    iunlock(f->ip);</code>
	<emi>
		0000338c  00338803  JMP   <fwd>
		00003390  0000033b  LBI   0x3 (D 3)
		00003394  00338c90  BGEU  <fwd>
		00003398  00024004  JMPI  0x240 (D 576)
		0000339c  0000040e  LL    0x4 (D 4)
		000033a0  0000101c  LX    0x10 (D 16)
		000033a4  0000009d  PSHA
		000033a8  ffdf9405  JSR   0xffffdf94 (TO 0x1340)
		000033ac  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1220 start=3308 end=3310>
	<code>    return r;</code>
	<emi>
		000033b0  0000140e  LL    0x14 (D 20)
		000033b4  00001802  LEV   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=1221 start=3310 end=3310>
	<code>  case FD_RFS:</code>
</stmt>
<stmt file=os.c line=1222 start=3310 end=3312>
	<code>    h[0] = M_SEEK;</code>
	<emi>
		000033b8  00000423  LI    0x4 (D 4)
		000033bc  00000840  SL    0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1223 start=3312 end=3314>
	<code>    h[1] = offset;</code>
	<emi>
		000033c0  0000280e  LL    0x28 (D 40)
		000033c4  00000c40  SL    0xc (D 12)
	</emi>
</stmt>
<stmt file=os.c line=1224 start=3314 end=3316>
	<code>    h[2] = whence;</code>
	<emi>
		000033c8  0000300e  LL    0x30 (D 48)
		000033cc  00001040  SL    0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1225 start=3316 end=3336>
	<code>    if (socktx(f->off, h, 12) || sockrx(f->off, &r, 4)) return -1;</code>
	<emi>
		000033d0  00000c9e  PSHI  0xc (D 12)
		000033d4  00001007  LEA   0x10 (D 16)
		000033d8  0000009d  PSHA
		000033dc  0000140e  LL    0x14 (D 20)
		000033e0  0000141c  LX    0x14 (D 20)
		000033e4  0000009d  PSHA
		000033e8  fff73405  JSR   0xfffff734 (TO 0x2b20)
		000033ec  00001801  ENT   0x18 (D 24)
		000033f0  00000086  BNZ   <fwd>
		000033f4  0000049e  PSHI  0x4 (D 4)
		000033f8  00001c07  LEA   0x1c (D 28)
		000033fc  0000009d  PSHA
		00003400  0000140e  LL    0x14 (D 20)
		00003404  0000141c  LX    0x14 (D 20)
		00003408  0000009d  PSHA
		0000340c  fff78005  JSR   0xfffff780 (TO 0x2b90)
		00003410  00001801  ENT   0x18 (D 24)
		00003414  00000084  BZ    <fwd>
		00003418  ffffff23  LI    0xffffffff (D -1)
		0000341c  00001802  LEV   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=1226 start=3336 end=3338>
	<code>    return r;</code>
	<emi>
		00003420  0000140e  LL    0x14 (D 20)
		00003424  00001802  LEV   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=1227 start=3338 end=3338>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1228 start=3338 end=3344>
	<code>  return -1;</code>
	<emi>
		00003428  00000003  JMP   <fwd>
		0000342c  0000053b  LBI   0x5 (D 5)
		00003430  00342890  BGEU  <fwd>
		00003434  00024c04  JMPI  0x24c (D 588)
		00003438  ffffff23  LI    0xffffffff (D -1)
		0000343c  00001802  LEV   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=1229 start=3344 end=3344>
	<code>}</code>
</stmt>
<stmt file=os.c line=1230 start=3344 end=3344>
	<code></code>
</stmt>
<stmt file=os.c line=1231 start=3344 end=3345>
	<code>int dup2(int fd, int d)</code>
	<emi>
		00003440  00001802  LEV   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=1232 start=3345 end=3345>
	<code>{</code>
</stmt>
<stmt file=os.c line=1233 start=3345 end=3345>
	<code>  struct file *f;</code>
</stmt>
<stmt file=os.c line=1234 start=3345 end=3357>
	<code>  if (!(f = getf(fd)) || (uint)d >= NOFILE) return -1;</code>
	<emi>
		00003444  fffff801  ENT   0xfffffff8 (D -8)
		00003448  0000100e  LL    0x10 (D 16)
		0000344c  0000009d  PSHA
		00003450  fff62805  JSR   0xfffff628 (TO 0x2a7c)
		00003454  00000801  ENT   0x8 (D 8)
		00003458  00000440  SL    0x4 (D 4)
		0000345c  00000084  BZ    <fwd>
		00003460  0000180e  LL    0x18 (D 24)
		00003464  0000103b  LBI   0x10 (D 16)
		00003468  0000008d  BLTU  <fwd>
		0000346c  ffffff23  LI    0xffffffff (D -1)
		00003470  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1235 start=3357 end=3361>
	<code>  close(d);</code>
	<emi>
		00003474  0000180e  LL    0x18 (D 24)
		00003478  0000009d  PSHA
		0000347c  fff8c005  JSR   0xfffff8c0 (TO 0x2d40)
		00003480  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1236 start=3361 end=3375>
	<code>  u->ofile[d] = filedup(f);</code>
	<emi>
		00003484  00210015  LG    0x2100 (D 8448)
		00003488  00003054  ADDI  0x30 (D 48)
		0000348c  0000009d  PSHA
		00003490  0000200e  LL    0x20 (D 32)
		00003494  0000045a  MULI  0x4 (D 4)
		00003498  000000a1  POPB
		0000349c  00000053  ADD 
		000034a0  0000009d  PSHA
		000034a4  00000c0e  LL    0xc (D 12)
		000034a8  0000009d  PSHA
		000034ac  fff1e405  JSR   0xfffff1e4 (TO 0x2694)
		000034b0  00000801  ENT   0x8 (D 8)
		000034b4  000000a1  POPB
		000034b8  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1237 start=3375 end=3377>
	<code>  return d;</code>
	<emi>
		000034bc  0000180e  LL    0x18 (D 24)
		000034c0  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1238 start=3377 end=3377>
	<code>}</code>
</stmt>
<stmt file=os.c line=1239 start=3377 end=3377>
	<code></code>
</stmt>
<stmt file=os.c line=1240 start=3377 end=3378>
	<code>int link(char *old, char *new)</code>
	<emi>
		000034c4  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1241 start=3378 end=3378>
	<code>{</code>
</stmt>
<stmt file=os.c line=1242 start=3378 end=3378>
	<code>  char name[DIRSIZ];</code>
</stmt>
<stmt file=os.c line=1243 start=3378 end=3378>
	<code>  struct inode *dp, *ip;</code>
</stmt>
<stmt file=os.c line=1244 start=3378 end=3378>
	<code></code>
</stmt>
<stmt file=os.c line=1245 start=3378 end=3397>
	<code>  if (!svalid(old) || !svalid(new) || !(ip = namei(old))) return -1;</code>
	<emi>
		000034c8  fffef801  ENT   0xfffffef8 (D -264)
		000034cc  0001100e  LL    0x110 (D 272)
		000034d0  0000009d  PSHA
		000034d4  fff51405  JSR   0xfffff514 (TO 0x29ec)
		000034d8  00000801  ENT   0x8 (D 8)
		000034dc  00000084  BZ    <fwd>
		000034e0  0001180e  LL    0x118 (D 280)
		000034e4  0000009d  PSHA
		000034e8  fff50005  JSR   0xfffff500 (TO 0x29ec)
		000034ec  00000801  ENT   0x8 (D 8)
		000034f0  0034dc84  BZ    <fwd>
		000034f4  0001100e  LL    0x110 (D 272)
		000034f8  0000009d  PSHA
		000034fc  ffec1405  JSR   0xffffec14 (TO 0x2114)
		00003500  00000801  ENT   0x8 (D 8)
		00003504  00000440  SL    0x4 (D 4)
		00003508  00000086  BNZ   <fwd>
		0000350c  ffffff23  LI    0xffffffff (D -1)
		00003510  00010802  LEV   0x108 (D 264)
	</emi>
</stmt>
<stmt file=os.c line=1246 start=3397 end=3401>
	<code>  ilock(ip);</code>
	<emi>
		00003514  0000040e  LL    0x4 (D 4)
		00003518  0000009d  PSHA
		0000351c  ffdc8805  JSR   0xffffdc88 (TO 0x11a8)
		00003520  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1247 start=3401 end=3406>
	<code>  if ((ip->mode & S_IFMT) == S_IFDIR) {</code>
	<emi>
		00003524  0000040e  LL    0x4 (D 4)
		00003528  00000c1e  LXH   0xc (D 12)
		0000352c  00f00069  ANDI  0xf000 (D 61440)
		00003530  0040003b  LBI   0x4000 (D 16384)
		00003534  0000008a  BNE   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1248 start=3406 end=3410>
	<code>    iunlockput(ip);</code>
	<emi>
		00003538  0000040e  LL    0x4 (D 4)
		0000353c  0000009d  PSHA
		00003540  ffdf8c05  JSR   0xffffdf8c (TO 0x14d0)
		00003544  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1249 start=3410 end=3412>
	<code>    return -1;</code>
	<emi>
		00003548  ffffff23  LI    0xffffffff (D -1)
		0000354c  00010802  LEV   0x108 (D 264)
	</emi>
</stmt>
<stmt file=os.c line=1250 start=3412 end=3412>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1251 start=3412 end=3418>
	<code>  ip->nlink++;</code>
	<emi>
		00003550  0000040e  LL    0x4 (D 4)
		00003554  00001054  ADDI  0x10 (D 16)
		00003558  0000003e  LBA 
		0000355c  0000001c  LX  
		00003560  ffffff57  SUBI  0xffffffff (D -1)
		00003564  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1252 start=3418 end=3422>
	<code>  iupdate(ip);</code>
	<emi>
		00003568  0000040e  LL    0x4 (D 4)
		0000356c  0000009d  PSHA
		00003570  ffdb2005  JSR   0xffffdb20 (TO 0x1094)
		00003574  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1253 start=3422 end=3426>
	<code>  iunlock(ip);</code>
	<emi>
		00003578  0000040e  LL    0x4 (D 4)
		0000357c  0000009d  PSHA
		00003580  ffddbc05  JSR   0xffffddbc (TO 0x1340)
		00003584  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1254 start=3426 end=3426>
	<code></code>
</stmt>
<stmt file=os.c line=1255 start=3426 end=3435>
	<code>  if (!(dp = nameiparent(new, name))) goto bad;</code>
	<emi>
		00003588  00000c07  LEA   0xc (D 12)
		0000358c  0000009d  PSHA
		00003590  0001200e  LL    0x120 (D 288)
		00003594  0000009d  PSHA
		00003598  ffec6005  JSR   0xffffec60 (TO 0x21fc)
		0000359c  00001001  ENT   0x10 (D 16)
		000035a0  00000840  SL    0x8 (D 8)
		000035a4  00000086  BNZ   <fwd>
		000035a8  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1256 start=3435 end=3439>
	<code>  ilock(dp);</code>
	<emi>
		000035ac  0000080e  LL    0x8 (D 8)
		000035b0  0000009d  PSHA
		000035b4  ffdbf005  JSR   0xffffdbf0 (TO 0x11a8)
		000035b8  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1257 start=3439 end=3449>
	<code>  if (dirlink(dp, name, ip->inum)) {</code>
	<emi>
		000035bc  0000040e  LL    0x4 (D 4)
		000035c0  0000001c  LX  
		000035c4  0000009d  PSHA
		000035c8  00001407  LEA   0x14 (D 20)
		000035cc  0000009d  PSHA
		000035d0  0000180e  LL    0x18 (D 24)
		000035d4  0000009d  PSHA
		000035d8  ffe88805  JSR   0xffffe888 (TO 0x1e64)
		000035dc  00001801  ENT   0x18 (D 24)
		000035e0  00000084  BZ    <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1258 start=3449 end=3453>
	<code>    iunlockput(dp);</code>
	<emi>
		000035e4  0000080e  LL    0x8 (D 8)
		000035e8  0000009d  PSHA
		000035ec  ffdee005  JSR   0xffffdee0 (TO 0x14d0)
		000035f0  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1259 start=3453 end=3453>
	<code>bad:</code>
</stmt>
<stmt file=os.c line=1260 start=3453 end=3457>
	<code>    ilock(ip);</code>
	<emi>
		000035f4  0000040e  LL    0x4 (D 4)
		000035f8  0000009d  PSHA
		000035fc  ffdba805  JSR   0xffffdba8 (TO 0x11a8)
		00003600  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1261 start=3457 end=3463>
	<code>    ip->nlink--;</code>
	<emi>
		00003604  0000040e  LL    0x4 (D 4)
		00003608  00001054  ADDI  0x10 (D 16)
		0000360c  0000003e  LBA 
		00003610  0000001c  LX  
		00003614  00000157  SUBI  0x1 (D 1)
		00003618  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1262 start=3463 end=3467>
	<code>    iupdate(ip);</code>
	<emi>
		0000361c  0000040e  LL    0x4 (D 4)
		00003620  0000009d  PSHA
		00003624  ffda6c05  JSR   0xffffda6c (TO 0x1094)
		00003628  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1263 start=3467 end=3471>
	<code>    iunlockput(ip);</code>
	<emi>
		0000362c  0000040e  LL    0x4 (D 4)
		00003630  0000009d  PSHA
		00003634  ffde9805  JSR   0xffffde98 (TO 0x14d0)
		00003638  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1264 start=3471 end=3473>
	<code>    return -1;</code>
	<emi>
		0000363c  ffffff23  LI    0xffffffff (D -1)
		00003640  00010802  LEV   0x108 (D 264)
	</emi>
</stmt>
<stmt file=os.c line=1265 start=3473 end=3473>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1266 start=3473 end=3477>
	<code>  iunlockput(dp);</code>
	<emi>
		00003644  0000080e  LL    0x8 (D 8)
		00003648  0000009d  PSHA
		0000364c  ffde8005  JSR   0xffffde80 (TO 0x14d0)
		00003650  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1267 start=3477 end=3481>
	<code>  iput(ip);</code>
	<emi>
		00003654  0000040e  LL    0x4 (D 4)
		00003658  0000009d  PSHA
		0000365c  ffdd6005  JSR   0xffffdd60 (TO 0x13c0)
		00003660  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1268 start=3481 end=3483>
	<code>  return 0;</code>
	<emi>
		00003664  00000023  LI    0x0 (D 0)
		00003668  00010802  LEV   0x108 (D 264)
	</emi>
</stmt>
<stmt file=os.c line=1269 start=3483 end=3483>
	<code>}</code>
</stmt>
<stmt file=os.c line=1270 start=3483 end=3483>
	<code></code>
</stmt>
<stmt file=os.c line=1271 start=3483 end=3484>
	<code>int unlink(char *path)</code>
	<emi>
		0000366c  00010802  LEV   0x108 (D 264)
	</emi>
</stmt>
<stmt file=os.c line=1272 start=3484 end=3484>
	<code>{</code>
</stmt>
<stmt file=os.c line=1273 start=3484 end=3484>
	<code>  struct inode *ip, *dp;</code>
</stmt>
<stmt file=os.c line=1274 start=3484 end=3484>
	<code>  struct direct de;</code>
</stmt>
<stmt file=os.c line=1275 start=3484 end=3484>
	<code>  char name[DIRSIZ];</code>
</stmt>
<stmt file=os.c line=1276 start=3484 end=3484>
	<code>  uint off;</code>
</stmt>
<stmt file=os.c line=1277 start=3484 end=3484>
	<code>  </code>
</stmt>
<stmt file=os.c line=1278 start=3484 end=3500>
	<code>  if (!svalid(path) || !(dp = nameiparent(path, name))) return -1;</code>
	<emi>
		00003670  fffdf801  ENT   0xfffffdf8 (D -520)
		00003674  0002100e  LL    0x210 (D 528)
		00003678  0000009d  PSHA
		0000367c  fff36c05  JSR   0xfffff36c (TO 0x29ec)
		00003680  00000801  ENT   0x8 (D 8)
		00003684  00000084  BZ    <fwd>
		00003688  00000407  LEA   0x4 (D 4)
		0000368c  0000009d  PSHA
		00003690  0002180e  LL    0x218 (D 536)
		00003694  0000009d  PSHA
		00003698  ffeb6005  JSR   0xffffeb60 (TO 0x21fc)
		0000369c  00001001  ENT   0x10 (D 16)
		000036a0  00020040  SL    0x200 (D 512)
		000036a4  00000086  BNZ   <fwd>
		000036a8  ffffff23  LI    0xffffffff (D -1)
		000036ac  00020802  LEV   0x208 (D 520)
	</emi>
</stmt>
<stmt file=os.c line=1279 start=3500 end=3504>
	<code>  ilock(dp);</code>
	<emi>
		000036b0  0002000e  LL    0x200 (D 512)
		000036b4  0000009d  PSHA
		000036b8  ffdaec05  JSR   0xffffdaec (TO 0x11a8)
		000036bc  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1280 start=3504 end=3504>
	<code></code>
</stmt>
<stmt file=os.c line=1281 start=3504 end=3504>
	<code>  // Cannot unlink "." or "..".</code>
</stmt>
<stmt file=os.c line=1282 start=3504 end=3529>
	<code>  if (!namecmp(name, ".") || !namecmp(name, "..") || !(ip = dirlookup(dp, name, &off))) goto bad;</code>
	<emi>
		000036c0  00026008  LEAG  0x260 (D 608)
		000036c4  0000009d  PSHA
		000036c8  00000c07  LEA   0xc (D 12)
		000036cc  0000009d  PSHA
		000036d0  ffe61805  JSR   0xffffe618 (TO 0x1cec)
		000036d4  00001001  ENT   0x10 (D 16)
		000036d8  00000084  BZ    <fwd>
		000036dc  00026208  LEAG  0x262 (D 610)
		000036e0  0000009d  PSHA
		000036e4  00000c07  LEA   0xc (D 12)
		000036e8  0000009d  PSHA
		000036ec  ffe5fc05  JSR   0xffffe5fc (TO 0x1cec)
		000036f0  00001001  ENT   0x10 (D 16)
		000036f4  0036d884  BZ    <fwd>
		000036f8  00000007  LEA   0x0 (D 0)
		000036fc  0000009d  PSHA
		00003700  00000c07  LEA   0xc (D 12)
		00003704  0000009d  PSHA
		00003708  0002100e  LL    0x210 (D 528)
		0000370c  0000009d  PSHA
		00003710  ffe66805  JSR   0xffffe668 (TO 0x1d7c)
		00003714  00001801  ENT   0x18 (D 24)
		00003718  00020440  SL    0x204 (D 516)
		0000371c  00000086  BNZ   <fwd>
		00003720  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1283 start=3529 end=3533>
	<code>  ilock(ip);</code>
	<emi>
		00003724  0002040e  LL    0x204 (D 516)
		00003728  0000009d  PSHA
		0000372c  ffda7805  JSR   0xffffda78 (TO 0x11a8)
		00003730  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1284 start=3533 end=3540>
	<code>  if (!ip->nlink) panic("unlink: nlink == 0");</code>
	<emi>
		00003734  0002040e  LL    0x204 (D 516)
		00003738  0000101c  LX    0x10 (D 16)
		0000373c  00000086  BNZ   <fwd>
		00003740  00026508  LEAG  0x265 (D 613)
		00003744  0000009d  PSHA
		00003748  ffcde805  JSR   0xffffcde8 (TO 0x534)
		0000374c  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1285 start=3540 end=3550>
	<code>  if ((ip->mode & S_IFMT) == S_IFDIR && !isdirempty(ip)) {</code>
	<emi>
		00003750  0002040e  LL    0x204 (D 516)
		00003754  00000c1e  LXH   0xc (D 12)
		00003758  00f00069  ANDI  0xf000 (D 61440)
		0000375c  0040003b  LBI   0x4000 (D 16384)
		00003760  0000008a  BNE   <fwd>
		00003764  0002040e  LL    0x204 (D 516)
		00003768  0000009d  PSHA
		0000376c  ffe81405  JSR   0xffffe814 (TO 0x1f84)
		00003770  00000801  ENT   0x8 (D 8)
		00003774  00376086  BNZ   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1286 start=3550 end=3554>
	<code>    iunlockput(ip);</code>
	<emi>
		00003778  0002040e  LL    0x204 (D 516)
		0000377c  0000009d  PSHA
		00003780  ffdd4c05  JSR   0xffffdd4c (TO 0x14d0)
		00003784  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1287 start=3554 end=3554>
	<code>bad:</code>
</stmt>
<stmt file=os.c line=1288 start=3554 end=3558>
	<code>    iunlockput(dp);</code>
	<emi>
		00003788  0002000e  LL    0x200 (D 512)
		0000378c  0000009d  PSHA
		00003790  ffdd3c05  JSR   0xffffdd3c (TO 0x14d0)
		00003794  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1289 start=3558 end=3560>
	<code>    return -1;</code>
	<emi>
		00003798  ffffff23  LI    0xffffffff (D -1)
		0000379c  00020802  LEV   0x208 (D 520)
	</emi>
</stmt>
<stmt file=os.c line=1290 start=3560 end=3560>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1291 start=3560 end=3560>
	<code></code>
</stmt>
<stmt file=os.c line=1292 start=3560 end=3566>
	<code>  memset(&de, 0, sizeof(de));</code>
	<emi>
		000037a0  0001009e  PSHI  0x100 (D 256)
		000037a4  0000009e  PSHI  0x0 (D 0)
		000037a8  00011007  LEA   0x110 (D 272)
		000037ac  0000009d  PSHA
		000037b0  ffc86405  JSR   0xffffc864 (TO 0x18)
		000037b4  00001801  ENT   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=1293 start=3566 end=3581>
	<code>  if (writei(dp, (char *)&de, off, sizeof(de)) != sizeof(de)) panic("unlink: writei");</code>
	<emi>
		000037b8  0001009e  PSHI  0x100 (D 256)
		000037bc  0000080e  LL    0x8 (D 8)
		000037c0  0000009d  PSHA
		000037c4  00011007  LEA   0x110 (D 272)
		000037c8  0000009d  PSHA
		000037cc  0002180e  LL    0x218 (D 536)
		000037d0  0000009d  PSHA
		000037d4  ffe30005  JSR   0xffffe300 (TO 0x1ad8)
		000037d8  00002001  ENT   0x20 (D 32)
		000037dc  0001003b  LBI   0x100 (D 256)
		000037e0  00000088  BE    <fwd>
		000037e4  00027808  LEAG  0x278 (D 632)
		000037e8  0000009d  PSHA
		000037ec  ffcd4405  JSR   0xffffcd44 (TO 0x534)
		000037f0  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1294 start=3581 end=3586>
	<code>  if ((ip->mode & S_IFMT) == S_IFDIR) {</code>
	<emi>
		000037f4  0002040e  LL    0x204 (D 516)
		000037f8  00000c1e  LXH   0xc (D 12)
		000037fc  00f00069  ANDI  0xf000 (D 61440)
		00003800  0040003b  LBI   0x4000 (D 16384)
		00003804  0000008a  BNE   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1295 start=3586 end=3592>
	<code>    dp->nlink--;</code>
	<emi>
		00003808  0002000e  LL    0x200 (D 512)
		0000380c  00001054  ADDI  0x10 (D 16)
		00003810  0000003e  LBA 
		00003814  0000001c  LX  
		00003818  00000157  SUBI  0x1 (D 1)
		0000381c  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1296 start=3592 end=3596>
	<code>    iupdate(dp);</code>
	<emi>
		00003820  0002000e  LL    0x200 (D 512)
		00003824  0000009d  PSHA
		00003828  ffd86805  JSR   0xffffd868 (TO 0x1094)
		0000382c  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1297 start=3596 end=3596>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1298 start=3596 end=3596>
	<code>  </code>
</stmt>
<stmt file=os.c line=1299 start=3596 end=3600>
	<code>  iunlockput(dp);</code>
	<emi>
		00003830  0002000e  LL    0x200 (D 512)
		00003834  0000009d  PSHA
		00003838  ffdc9405  JSR   0xffffdc94 (TO 0x14d0)
		0000383c  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1300 start=3600 end=3600>
	<code></code>
</stmt>
<stmt file=os.c line=1301 start=3600 end=3606>
	<code>  ip->nlink--;</code>
	<emi>
		00003840  0002040e  LL    0x204 (D 516)
		00003844  00001054  ADDI  0x10 (D 16)
		00003848  0000003e  LBA 
		0000384c  0000001c  LX  
		00003850  00000157  SUBI  0x1 (D 1)
		00003854  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1302 start=3606 end=3610>
	<code>  iupdate(ip);</code>
	<emi>
		00003858  0002040e  LL    0x204 (D 516)
		0000385c  0000009d  PSHA
		00003860  ffd83005  JSR   0xffffd830 (TO 0x1094)
		00003864  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1303 start=3610 end=3614>
	<code>  iunlockput(ip);</code>
	<emi>
		00003868  0002040e  LL    0x204 (D 516)
		0000386c  0000009d  PSHA
		00003870  ffdc5c05  JSR   0xffffdc5c (TO 0x14d0)
		00003874  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1304 start=3614 end=3616>
	<code>  return 0;</code>
	<emi>
		00003878  00000023  LI    0x0 (D 0)
		0000387c  00020802  LEV   0x208 (D 520)
	</emi>
</stmt>
<stmt file=os.c line=1305 start=3616 end=3616>
	<code>}</code>
</stmt>
<stmt file=os.c line=1306 start=3616 end=3616>
	<code></code>
</stmt>
<stmt file=os.c line=1307 start=3616 end=3639>
	<code>uint htonl(uint a) { return (a >> 24) | ((a >> 8) & 0xff00) | ((a << 8) & 0xff0000) | (a << 24); } // XXX eliminate</code>
	<emi>
		00003880  00020802  LEV   0x208 (D 520)
		00003884  0000080e  LL    0x8 (D 8)
		00003888  00001878  SRUI  0x18 (D 24)
		0000388c  0000009d  PSHA
		00003890  0000100e  LL    0x10 (D 16)
		00003894  00000878  SRUI  0x8 (D 8)
		00003898  00ff0069  ANDI  0xff00 (D 65280)
		0000389c  000000a1  POPB
		000038a0  0000006b  OR  
		000038a4  0000009d  PSHA
		000038a8  0000100e  LL    0x10 (D 16)
		000038ac  00000872  SHLI  0x8 (D 8)
		000038b0  0000003b  LBI   0x0 (D 0)
		000038b4  ff00003c  LBHI  0xffff0000 (D -65536)
		000038b8  00000068  AND 
		000038bc  000000a1  POPB
		000038c0  0000006b  OR  
		000038c4  0000009d  PSHA
		000038c8  0000100e  LL    0x10 (D 16)
		000038cc  00001872  SHLI  0x18 (D 24)
		000038d0  000000a1  POPB
		000038d4  0000006b  OR  
		000038d8  00000002  LEV   0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=1308 start=3639 end=3649>
	<code>ushort htons(ushort a) { return (a >> 8) | (a << 8); } // XXX eliminate</code>
	<emi>
		000038dc  00000002  LEV   0x0 (D 0)
		000038e0  00000810  LLH   0x8 (D 8)
		000038e4  00000872  SHLI  0x8 (D 8)
		000038e8  0000009d  PSHA
		000038ec  00001010  LLH   0x10 (D 16)
		000038f0  00000875  SHRI  0x8 (D 8)
		000038f4  000000a1  POPB
		000038f8  0000006b  OR  
		000038fc  00ffff69  ANDI  0xffff (D 65535)
		00003900  00000002  LEV   0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=1309 start=3649 end=3654>
	<code>int memcmp() { asm(LL,8); asm(LBL, 16); asm(LCL,24); asm(MCMP); } // XXX eliminate</code>
	<emi>
		00003904  00000002  LEV   0x0 (D 0)
		00003908  0000080e  LL    0x8 (D 8)
		0000390c  00001026  LBL   0x10 (D 16)
		00003910  000018ac  LCL   0x18 (D 24)
		00003914  0000000b  MCMP
	</emi>
</stmt>
<stmt file=os.c line=1310 start=3654 end=3655>
	<code>int open(char *path, int oflag) // XXX, int mode)</code>
	<emi>
		00003918  00000002  LEV   0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=1311 start=3655 end=3655>
	<code>{</code>
</stmt>
<stmt file=os.c line=1312 start=3655 end=3655>
	<code>  int fd, r; int h[4];</code>
</stmt>
<stmt file=os.c line=1313 start=3655 end=3655>
	<code>  struct file *f;</code>
</stmt>
<stmt file=os.c line=1314 start=3655 end=3655>
	<code>  struct inode *ip;</code>
</stmt>
<stmt file=os.c line=1315 start=3655 end=3655>
	<code></code>
</stmt>
<stmt file=os.c line=1316 start=3655 end=3663>
	<code>  if (!svalid(path)) return -1;</code>
	<emi>
		0000391c  ffffe001  ENT   0xffffffe0 (D -32)
		00003920  0000280e  LL    0x28 (D 40)
		00003924  0000009d  PSHA
		00003928  fff0c005  JSR   0xfffff0c0 (TO 0x29ec)
		0000392c  00000801  ENT   0x8 (D 8)
		00003930  00000086  BNZ   <fwd>
		00003934  ffffff23  LI    0xffffffff (D -1)
		00003938  00002002  LEV   0x20 (D 32)
	</emi>
</stmt>
<stmt file=os.c line=1317 start=3663 end=3663>
	<code>//  if (!namecmp(path, "rfs.txt")) {</code>
</stmt>
<stmt file=os.c line=1318 start=3663 end=3671>
	<code>  if (!memcmp(path,"rfs/",4)) {</code>
	<emi>
		0000393c  0000049e  PSHI  0x4 (D 4)
		00003940  00028708  LEAG  0x287 (D 647)
		00003944  0000009d  PSHA
		00003948  0000380e  LL    0x38 (D 56)
		0000394c  0000009d  PSHA
		00003950  ffffb405  JSR   0xffffffb4 (TO 0x3908)
		00003954  00001801  ENT   0x18 (D 24)
		00003958  00000086  BNZ   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1319 start=3671 end=3674>
	<code>    path += 4;</code>
	<emi>
		0000395c  0000280e  LL    0x28 (D 40)
		00003960  00000454  ADDI  0x4 (D 4)
		00003964  00002840  SL    0x28 (D 40)
	</emi>
</stmt>
<stmt file=os.c line=1320 start=3674 end=3684>
	<code>    if ((fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) return -1; // XXX reuse?</code>
	<emi>
		00003968  0000009e  PSHI  0x0 (D 0)
		0000396c  0000019e  PSHI  0x1 (D 1)
		00003970  0000029e  PSHI  0x2 (D 2)
		00003974  00000005  JSR   <fwd>
		00003978  00001801  ENT   0x18 (D 24)
		0000397c  00001c40  SL    0x1c (D 28)
		00003980  0000003b  LBI   0x0 (D 0)
		00003984  0000008f  BGE   <fwd>
		00003988  ffffff23  LI    0xffffffff (D -1)
		0000398c  00002002  LEV   0x20 (D 32)
	</emi>
</stmt>
<stmt file=os.c line=1321 start=3684 end=3689>
	<code>    f = getf(fd);</code>
	<emi>
		00003990  00001c0e  LL    0x1c (D 28)
		00003994  0000009d  PSHA
		00003998  fff0e005  JSR   0xfffff0e0 (TO 0x2a7c)
		0000399c  00000801  ENT   0x8 (D 8)
		000039a0  00000440  SL    0x4 (D 4)
	</emi>
</stmt>
<stmt file=os.c line=1322 start=3689 end=3709>
	<code>    if (sockconnect(f->off, AF_INET | (htons(5003) << 16), htonl(0x7f000001))) return -1; // XXX close?</code>
	<emi>
		000039a4  00007f23  LI    0x7f (D 127)
		000039a8  00000124  LHI   0x1 (D 1)
		000039ac  0000009d  PSHA
		000039b0  fffed005  JSR   0xfffffed0 (TO 0x3884)
		000039b4  00000801  ENT   0x8 (D 8)
		000039b8  0000009d  PSHA
		000039bc  00138b9e  PSHI  0x138b (D 5003)
		000039c0  ffff1c05  JSR   0xffffff1c (TO 0x38e0)
		000039c4  00000801  ENT   0x8 (D 8)
		000039c8  00001072  SHLI  0x10 (D 16)
		000039cc  0000026c  ORI   0x2 (D 2)
		000039d0  0000009d  PSHA
		000039d4  0000140e  LL    0x14 (D 20)
		000039d8  0000141c  LX    0x14 (D 20)
		000039dc  0000009d  PSHA
		000039e0  fff0f405  JSR   0xfffff0f4 (TO 0x2ad8)
		000039e4  00001801  ENT   0x18 (D 24)
		000039e8  00000084  BZ    <fwd>
		000039ec  ffffff23  LI    0xffffffff (D -1)
		000039f0  00002002  LEV   0x20 (D 32)
	</emi>
</stmt>
<stmt file=os.c line=1323 start=3709 end=3712>
	<code>    f->type = FD_RFS;</code>
	<emi>
		000039f4  00000423  LI    0x4 (D 4)
		000039f8  00000426  LBL   0x4 (D 4)
		000039fc  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1324 start=3712 end=3714>
	<code>    h[0] = M_OPEN;</code>
	<emi>
		00003a00  00000023  LI    0x0 (D 0)
		00003a04  00000840  SL    0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1325 start=3714 end=3716>
	<code>    h[1] = oflag;</code>
	<emi>
		00003a08  0000300e  LL    0x30 (D 48)
		00003a0c  00000c40  SL    0xc (D 12)
	</emi>
</stmt>
<stmt file=os.c line=1326 start=3716 end=3718>
	<code>    h[2] = 0; //mode;</code>
	<emi>
		00003a10  00000023  LI    0x0 (D 0)
		00003a14  00001040  SL    0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1327 start=3718 end=3724>
	<code>    h[3] = strlen(path) + 1;</code>
	<emi>
		00003a18  0000280e  LL    0x28 (D 40)
		00003a1c  0000009d  PSHA
		00003a20  ffc69405  JSR   0xffffc694 (TO 0xb8)
		00003a24  00000801  ENT   0x8 (D 8)
		00003a28  00000154  ADDI  0x1 (D 1)
		00003a2c  00001440  SL    0x14 (D 20)
	</emi>
</stmt>
<stmt file=os.c line=1328 start=3724 end=3757>
	<code>    if (socktx(f->off, h, 16) || socktx(f->off, path, h[3]) || sockrx(f->off, &r, 4) || r < 0) return -1; // XXX sockclose?</code>
	<emi>
		00003a30  0000109e  PSHI  0x10 (D 16)
		00003a34  00001007  LEA   0x10 (D 16)
		00003a38  0000009d  PSHA
		00003a3c  0000140e  LL    0x14 (D 20)
		00003a40  0000141c  LX    0x14 (D 20)
		00003a44  0000009d  PSHA
		00003a48  fff0d405  JSR   0xfffff0d4 (TO 0x2b20)
		00003a4c  00001801  ENT   0x18 (D 24)
		00003a50  00000086  BNZ   <fwd>
		00003a54  0000140e  LL    0x14 (D 20)
		00003a58  0000009d  PSHA
		00003a5c  0000300e  LL    0x30 (D 48)
		00003a60  0000009d  PSHA
		00003a64  0000140e  LL    0x14 (D 20)
		00003a68  0000141c  LX    0x14 (D 20)
		00003a6c  0000009d  PSHA
		00003a70  fff0ac05  JSR   0xfffff0ac (TO 0x2b20)
		00003a74  00001801  ENT   0x18 (D 24)
		00003a78  003a5086  BNZ   <fwd>
		00003a7c  0000049e  PSHI  0x4 (D 4)
		00003a80  00002007  LEA   0x20 (D 32)
		00003a84  0000009d  PSHA
		00003a88  0000140e  LL    0x14 (D 20)
		00003a8c  0000141c  LX    0x14 (D 20)
		00003a90  0000009d  PSHA
		00003a94  fff0f805  JSR   0xfffff0f8 (TO 0x2b90)
		00003a98  00001801  ENT   0x18 (D 24)
		00003a9c  003a7886  BNZ   <fwd>
		00003aa0  0000180e  LL    0x18 (D 24)
		00003aa4  0000003b  LBI   0x0 (D 0)
		00003aa8  0000008f  BGE   <fwd>
		00003aac  ffffff23  LI    0xffffffff (D -1)
		00003ab0  00002002  LEV   0x20 (D 32)
	</emi>
</stmt>
<stmt file=os.c line=1329 start=3757 end=3759>
	<code>    return fd;</code>
	<emi>
		00003ab4  00001c0e  LL    0x1c (D 28)
		00003ab8  00002002  LEV   0x20 (D 32)
	</emi>
</stmt>
<stmt file=os.c line=1330 start=3759 end=3763>
	<code>  } else if (oflag & O_CREAT) {</code>
	<emi>
		00003abc  00000003  JMP   <fwd>
		00003ac0  0000300e  LL    0x30 (D 48)
		00003ac4  00010069  ANDI  0x100 (D 256)
		00003ac8  00000084  BZ    <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1331 start=3763 end=3773>
	<code>    if (!(ip = create(path, S_IFREG, 0))) return -1;</code>
	<emi>
		00003acc  0000009e  PSHI  0x0 (D 0)
		00003ad0  0080009e  PSHI  0x8000 (D 32768)
		00003ad4  0000380e  LL    0x38 (D 56)
		00003ad8  0000009d  PSHA
		00003adc  ffec9c05  JSR   0xffffec9c (TO 0x277c)
		00003ae0  00001801  ENT   0x18 (D 24)
		00003ae4  00000040  SL    0x0 (D 0)
		00003ae8  00000086  BNZ   <fwd>
		00003aec  ffffff23  LI    0xffffffff (D -1)
		00003af0  00002002  LEV   0x20 (D 32)
	</emi>
</stmt>
<stmt file=os.c line=1332 start=3773 end=3774>
	<code>  } else {</code>
	<emi>
		00003af4  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1333 start=3774 end=3782>
	<code>    if (!(ip = namei(path))) return -1;</code>
	<emi>
		00003af8  0000280e  LL    0x28 (D 40)
		00003afc  0000009d  PSHA
		00003b00  ffe61005  JSR   0xffffe610 (TO 0x2114)
		00003b04  00000801  ENT   0x8 (D 8)
		00003b08  00000040  SL    0x0 (D 0)
		00003b0c  00000086  BNZ   <fwd>
		00003b10  ffffff23  LI    0xffffffff (D -1)
		00003b14  00002002  LEV   0x20 (D 32)
	</emi>
</stmt>
<stmt file=os.c line=1334 start=3782 end=3786>
	<code>    ilock(ip);</code>
	<emi>
		00003b18  0000000e  LL    0x0 (D 0)
		00003b1c  0000009d  PSHA
		00003b20  ffd68405  JSR   0xffffd684 (TO 0x11a8)
		00003b24  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1335 start=3786 end=3794>
	<code>    if ((ip->mode & S_IFMT) == S_IFDIR && oflag != O_RDONLY) {</code>
	<emi>
		00003b28  0000000e  LL    0x0 (D 0)
		00003b2c  00000c1e  LXH   0xc (D 12)
		00003b30  00f00069  ANDI  0xf000 (D 61440)
		00003b34  0040003b  LBI   0x4000 (D 16384)
		00003b38  0000008a  BNE   <fwd>
		00003b3c  0000300e  LL    0x30 (D 48)
		00003b40  0000003b  LBI   0x0 (D 0)
		00003b44  003b3888  BE    <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1336 start=3794 end=3798>
	<code>      iunlockput(ip);</code>
	<emi>
		00003b48  0000000e  LL    0x0 (D 0)
		00003b4c  0000009d  PSHA
		00003b50  ffd97c05  JSR   0xffffd97c (TO 0x14d0)
		00003b54  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1337 start=3798 end=3800>
	<code>      return -1;</code>
	<emi>
		00003b58  ffffff23  LI    0xffffffff (D -1)
		00003b5c  00002002  LEV   0x20 (D 32)
	</emi>
</stmt>
<stmt file=os.c line=1338 start=3800 end=3800>
	<code>    }</code>
</stmt>
<stmt file=os.c line=1339 start=3800 end=3800>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1340 start=3800 end=3800>
	<code></code>
</stmt>
<stmt file=os.c line=1341 start=3800 end=3810>
	<code>  if (!(f = filealloc()) || (fd = fdalloc(f)) < 0) {</code>
	<emi>
		00003b60  ffeaa805  JSR   0xffffeaa8 (TO 0x260c)
		00003b64  00000440  SL    0x4 (D 4)
		00003b68  00000084  BZ    <fwd>
		00003b6c  0000040e  LL    0x4 (D 4)
		00003b70  0000009d  PSHA
		00003b74  ffeb7c05  JSR   0xffffeb7c (TO 0x26f4)
		00003b78  00000801  ENT   0x8 (D 8)
		00003b7c  00001c40  SL    0x1c (D 28)
		00003b80  0000003b  LBI   0x0 (D 0)
		00003b84  0000008f  BGE   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1342 start=3810 end=3816>
	<code>    if (f) fileclose(f);</code>
	<emi>
		00003b88  0000040e  LL    0x4 (D 4)
		00003b8c  00000084  BZ    <fwd>
		00003b90  0000040e  LL    0x4 (D 4)
		00003b94  0000009d  PSHA
		00003b98  fff09805  JSR   0xfffff098 (TO 0x2c34)
		00003b9c  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1343 start=3816 end=3820>
	<code>    iunlockput(ip);</code>
	<emi>
		00003ba0  0000000e  LL    0x0 (D 0)
		00003ba4  0000009d  PSHA
		00003ba8  ffd92405  JSR   0xffffd924 (TO 0x14d0)
		00003bac  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1344 start=3820 end=3822>
	<code>    return -1;</code>
	<emi>
		00003bb0  ffffff23  LI    0xffffffff (D -1)
		00003bb4  00002002  LEV   0x20 (D 32)
	</emi>
</stmt>
<stmt file=os.c line=1345 start=3822 end=3822>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1346 start=3822 end=3822>
	<code></code>
</stmt>
<stmt file=os.c line=1347 start=3822 end=3825>
	<code>  if (oflag & O_TRUNC)</code>
	<emi>
		00003bb8  0000300e  LL    0x30 (D 48)
		00003bbc  00020069  ANDI  0x200 (D 512)
		00003bc0  00000084  BZ    <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1348 start=3825 end=3829>
	<code>    itrunc(ip);</code>
	<emi>
		00003bc4  0000000e  LL    0x0 (D 0)
		00003bc8  0000009d  PSHA
		00003bcc  ffdaa805  JSR   0xffffdaa8 (TO 0x1678)
		00003bd0  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1349 start=3829 end=3829>
	<code></code>
</stmt>
<stmt file=os.c line=1350 start=3829 end=3833>
	<code>  iunlock(ip);</code>
	<emi>
		00003bd4  0000000e  LL    0x0 (D 0)
		00003bd8  0000009d  PSHA
		00003bdc  ffd76005  JSR   0xffffd760 (TO 0x1340)
		00003be0  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1351 start=3833 end=3833>
	<code></code>
</stmt>
<stmt file=os.c line=1352 start=3833 end=3836>
	<code>  f->type = FD_INODE;</code>
	<emi>
		00003be4  00000223  LI    0x2 (D 2)
		00003be8  00000426  LBL   0x4 (D 4)
		00003bec  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1353 start=3836 end=3841>
	<code>  f->ip = ip;</code>
	<emi>
		00003bf0  0000040e  LL    0x4 (D 4)
		00003bf4  00001054  ADDI  0x10 (D 16)
		00003bf8  0000003e  LBA 
		00003bfc  0000000e  LL    0x0 (D 0)
		00003c00  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1354 start=3841 end=3846>
	<code>  f->off = 0;</code>
	<emi>
		00003c04  0000040e  LL    0x4 (D 4)
		00003c08  00001454  ADDI  0x14 (D 20)
		00003c0c  0000003e  LBA 
		00003c10  00000023  LI    0x0 (D 0)
		00003c14  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1355 start=3846 end=3855>
	<code>  f->readable = !(oflag & O_WRONLY);</code>
	<emi>
		00003c18  0000040e  LL    0x4 (D 4)
		00003c1c  00000854  ADDI  0x8 (D 8)
		00003c20  0000009d  PSHA
		00003c24  0000380e  LL    0x38 (D 56)
		00003c28  00000169  ANDI  0x1 (D 1)
		00003c2c  0000003b  LBI   0x0 (D 0)
		00003c30  0000007a  EQ  
		00003c34  000000a1  POPB
		00003c38  0000004c  SXB 
	</emi>
</stmt>
<stmt file=os.c line=1356 start=3855 end=3869>
	<code>  f->writable = (oflag & O_WRONLY) || (oflag & O_RDWR);</code>
	<emi>
		00003c3c  0000040e  LL    0x4 (D 4)
		00003c40  00000954  ADDI  0x9 (D 9)
		00003c44  0000009d  PSHA
		00003c48  0000380e  LL    0x38 (D 56)
		00003c4c  00000169  ANDI  0x1 (D 1)
		00003c50  00000086  BNZ   <fwd>
		00003c54  0000380e  LL    0x38 (D 56)
		00003c58  00000269  ANDI  0x2 (D 2)
		00003c5c  003c5086  BNZ   <fwd>
		00003c60  00000023  LI    0x0 (D 0)
		00003c64  00000003  JMP   <fwd>
		00003c68  00000123  LI    0x1 (D 1)
		00003c6c  000000a1  POPB
		00003c70  0000004c  SXB 
	</emi>
</stmt>
<stmt file=os.c line=1357 start=3869 end=3871>
	<code>  return fd;</code>
	<emi>
		00003c74  00001c0e  LL    0x1c (D 28)
		00003c78  00002002  LEV   0x20 (D 32)
	</emi>
</stmt>
<stmt file=os.c line=1358 start=3871 end=3871>
	<code>}</code>
</stmt>
<stmt file=os.c line=1359 start=3871 end=3871>
	<code></code>
</stmt>
<stmt file=os.c line=1360 start=3871 end=3872>
	<code>int mkdir(char *path)</code>
	<emi>
		00003c7c  00002002  LEV   0x20 (D 32)
	</emi>
</stmt>
<stmt file=os.c line=1361 start=3872 end=3872>
	<code>{</code>
</stmt>
<stmt file=os.c line=1362 start=3872 end=3872>
	<code>  struct inode *ip;</code>
</stmt>
<stmt file=os.c line=1363 start=3872 end=3888>
	<code>  if (!svalid(path) || !(ip = create(path, S_IFDIR, 0))) return -1;</code>
	<emi>
		00003c80  fffff801  ENT   0xfffffff8 (D -8)
		00003c84  0000100e  LL    0x10 (D 16)
		00003c88  0000009d  PSHA
		00003c8c  ffed5c05  JSR   0xffffed5c (TO 0x29ec)
		00003c90  00000801  ENT   0x8 (D 8)
		00003c94  00000084  BZ    <fwd>
		00003c98  0000009e  PSHI  0x0 (D 0)
		00003c9c  0040009e  PSHI  0x4000 (D 16384)
		00003ca0  0000200e  LL    0x20 (D 32)
		00003ca4  0000009d  PSHA
		00003ca8  ffead005  JSR   0xffffead0 (TO 0x277c)
		00003cac  00001801  ENT   0x18 (D 24)
		00003cb0  00000440  SL    0x4 (D 4)
		00003cb4  00000086  BNZ   <fwd>
		00003cb8  ffffff23  LI    0xffffffff (D -1)
		00003cbc  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1364 start=3888 end=3892>
	<code>  iunlockput(ip);</code>
	<emi>
		00003cc0  0000040e  LL    0x4 (D 4)
		00003cc4  0000009d  PSHA
		00003cc8  ffd80405  JSR   0xffffd804 (TO 0x14d0)
		00003ccc  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1365 start=3892 end=3894>
	<code>  return 0;</code>
	<emi>
		00003cd0  00000023  LI    0x0 (D 0)
		00003cd4  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1366 start=3894 end=3894>
	<code>}</code>
</stmt>
<stmt file=os.c line=1367 start=3894 end=3894>
	<code></code>
</stmt>
<stmt file=os.c line=1368 start=3894 end=3895>
	<code>int mknod(char *path, int mode, int dev)</code>
	<emi>
		00003cd8  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1369 start=3895 end=3895>
	<code>{</code>
</stmt>
<stmt file=os.c line=1370 start=3895 end=3895>
	<code>  struct inode *ip;    </code>
</stmt>
<stmt file=os.c line=1371 start=3895 end=3913>
	<code>  if (!svalid(path) || !(ip = create(path, mode, dev))) return -1;</code>
	<emi>
		00003cdc  fffff801  ENT   0xfffffff8 (D -8)
		00003ce0  0000100e  LL    0x10 (D 16)
		00003ce4  0000009d  PSHA
		00003ce8  ffed0005  JSR   0xffffed00 (TO 0x29ec)
		00003cec  00000801  ENT   0x8 (D 8)
		00003cf0  00000084  BZ    <fwd>
		00003cf4  0000200e  LL    0x20 (D 32)
		00003cf8  0000009d  PSHA
		00003cfc  0000200e  LL    0x20 (D 32)
		00003d00  0000009d  PSHA
		00003d04  0000200e  LL    0x20 (D 32)
		00003d08  0000009d  PSHA
		00003d0c  ffea6c05  JSR   0xffffea6c (TO 0x277c)
		00003d10  00001801  ENT   0x18 (D 24)
		00003d14  00000440  SL    0x4 (D 4)
		00003d18  00000086  BNZ   <fwd>
		00003d1c  ffffff23  LI    0xffffffff (D -1)
		00003d20  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1372 start=3913 end=3917>
	<code>  iunlockput(ip);</code>
	<emi>
		00003d24  0000040e  LL    0x4 (D 4)
		00003d28  0000009d  PSHA
		00003d2c  ffd7a005  JSR   0xffffd7a0 (TO 0x14d0)
		00003d30  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1373 start=3917 end=3919>
	<code>  return 0;</code>
	<emi>
		00003d34  00000023  LI    0x0 (D 0)
		00003d38  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1374 start=3919 end=3919>
	<code>}</code>
</stmt>
<stmt file=os.c line=1375 start=3919 end=3919>
	<code></code>
</stmt>
<stmt file=os.c line=1376 start=3919 end=3920>
	<code>int chdir(char *path)</code>
	<emi>
		00003d3c  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1377 start=3920 end=3920>
	<code>{</code>
</stmt>
<stmt file=os.c line=1378 start=3920 end=3920>
	<code>  struct inode *ip;</code>
</stmt>
<stmt file=os.c line=1379 start=3920 end=3920>
	<code></code>
</stmt>
<stmt file=os.c line=1380 start=3920 end=3934>
	<code>  if (!svalid(path) || !(ip = namei(path))) return -1;</code>
	<emi>
		00003d40  fffff801  ENT   0xfffffff8 (D -8)
		00003d44  0000100e  LL    0x10 (D 16)
		00003d48  0000009d  PSHA
		00003d4c  ffec9c05  JSR   0xffffec9c (TO 0x29ec)
		00003d50  00000801  ENT   0x8 (D 8)
		00003d54  00000084  BZ    <fwd>
		00003d58  0000100e  LL    0x10 (D 16)
		00003d5c  0000009d  PSHA
		00003d60  ffe3b005  JSR   0xffffe3b0 (TO 0x2114)
		00003d64  00000801  ENT   0x8 (D 8)
		00003d68  00000440  SL    0x4 (D 4)
		00003d6c  00000086  BNZ   <fwd>
		00003d70  ffffff23  LI    0xffffffff (D -1)
		00003d74  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1381 start=3934 end=3938>
	<code>  ilock(ip);</code>
	<emi>
		00003d78  0000040e  LL    0x4 (D 4)
		00003d7c  0000009d  PSHA
		00003d80  ffd42405  JSR   0xffffd424 (TO 0x11a8)
		00003d84  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1382 start=3938 end=3943>
	<code>  if ((ip->mode & S_IFMT) != S_IFDIR) {</code>
	<emi>
		00003d88  0000040e  LL    0x4 (D 4)
		00003d8c  00000c1e  LXH   0xc (D 12)
		00003d90  00f00069  ANDI  0xf000 (D 61440)
		00003d94  0040003b  LBI   0x4000 (D 16384)
		00003d98  00000088  BE    <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1383 start=3943 end=3947>
	<code>    iunlockput(ip);</code>
	<emi>
		00003d9c  0000040e  LL    0x4 (D 4)
		00003da0  0000009d  PSHA
		00003da4  ffd72805  JSR   0xffffd728 (TO 0x14d0)
		00003da8  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1384 start=3947 end=3949>
	<code>    return -1;</code>
	<emi>
		00003dac  ffffff23  LI    0xffffffff (D -1)
		00003db0  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1385 start=3949 end=3949>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1386 start=3949 end=3953>
	<code>  iunlock(ip);</code>
	<emi>
		00003db4  0000040e  LL    0x4 (D 4)
		00003db8  0000009d  PSHA
		00003dbc  ffd58005  JSR   0xffffd580 (TO 0x1340)
		00003dc0  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1387 start=3953 end=3958>
	<code>  iput(u->cwd);</code>
	<emi>
		00003dc4  00210015  LG    0x2100 (D 8448)
		00003dc8  0000701c  LX    0x70 (D 112)
		00003dcc  0000009d  PSHA
		00003dd0  ffd5ec05  JSR   0xffffd5ec (TO 0x13c0)
		00003dd4  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1388 start=3958 end=3963>
	<code>  u->cwd = ip;</code>
	<emi>
		00003dd8  00210015  LG    0x2100 (D 8448)
		00003ddc  00007054  ADDI  0x70 (D 112)
		00003de0  0000003e  LBA 
		00003de4  0000040e  LL    0x4 (D 4)
		00003de8  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1389 start=3963 end=3965>
	<code>  return 0;</code>
	<emi>
		00003dec  00000023  LI    0x0 (D 0)
		00003df0  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1390 start=3965 end=3965>
	<code>}</code>
</stmt>
<stmt file=os.c line=1391 start=3965 end=3965>
	<code></code>
</stmt>
<stmt file=os.c line=1392 start=3965 end=3966>
	<code>int pipe(int *fd)</code>
	<emi>
		00003df4  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1393 start=3966 end=3966>
	<code>{</code>
</stmt>
<stmt file=os.c line=1394 start=3966 end=3966>
	<code>  struct pipe *p;</code>
</stmt>
<stmt file=os.c line=1395 start=3966 end=3966>
	<code>  struct file *rf, *wf;</code>
</stmt>
<stmt file=os.c line=1396 start=3966 end=3966>
	<code>  int fd0, fd1;</code>
</stmt>
<stmt file=os.c line=1397 start=3966 end=3966>
	<code></code>
</stmt>
<stmt file=os.c line=1398 start=3966 end=3978>
	<code>  if (!mvalid(fd, 8) || !(rf = filealloc())) return -1;</code>
	<emi>
		00003df8  ffffe801  ENT   0xffffffe8 (D -24)
		00003dfc  0000089e  PSHI  0x8 (D 8)
		00003e00  0000280e  LL    0x28 (D 40)
		00003e04  0000009d  PSHA
		00003e08  ffec3005  JSR   0xffffec30 (TO 0x2a3c)
		00003e0c  00001001  ENT   0x10 (D 16)
		00003e10  00000084  BZ    <fwd>
		00003e14  ffe7f405  JSR   0xffffe7f4 (TO 0x260c)
		00003e18  00001040  SL    0x10 (D 16)
		00003e1c  00000086  BNZ   <fwd>
		00003e20  ffffff23  LI    0xffffffff (D -1)
		00003e24  00001802  LEV   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=1399 start=3978 end=3987>
	<code>  if (!(wf = filealloc())) { fileclose(rf); return -1; }</code>
	<emi>
		00003e28  ffe7e005  JSR   0xffffe7e0 (TO 0x260c)
		00003e2c  00000c40  SL    0xc (D 12)
		00003e30  00000086  BNZ   <fwd>
		00003e34  0000100e  LL    0x10 (D 16)
		00003e38  0000009d  PSHA
		00003e3c  ffedf405  JSR   0xffffedf4 (TO 0x2c34)
		00003e40  00000801  ENT   0x8 (D 8)
		00003e44  ffffff23  LI    0xffffffff (D -1)
		00003e48  00001802  LEV   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=1400 start=3987 end=3989>
	<code>  p = (struct pipe *)kalloc();</code>
	<emi>
		00003e4c  ffc39c05  JSR   0xffffc39c (TO 0x1ec)
		00003e50  00001440  SL    0x14 (D 20)
	</emi>
</stmt>
<stmt file=os.c line=1401 start=3989 end=3994>
	<code>  p->readopen = 1;</code>
	<emi>
		00003e54  0000140e  LL    0x14 (D 20)
		00003e58  000fa854  ADDI  0xfa8 (D 4008)
		00003e5c  0000003e  LBA 
		00003e60  00000123  LI    0x1 (D 1)
		00003e64  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1402 start=3994 end=3999>
	<code>  p->writeopen = 1;</code>
	<emi>
		00003e68  0000140e  LL    0x14 (D 20)
		00003e6c  000fac54  ADDI  0xfac (D 4012)
		00003e70  0000003e  LBA 
		00003e74  00000123  LI    0x1 (D 1)
		00003e78  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1403 start=3999 end=4004>
	<code>  p->nwrite = 0;</code>
	<emi>
		00003e7c  0000140e  LL    0x14 (D 20)
		00003e80  000fa454  ADDI  0xfa4 (D 4004)
		00003e84  0000003e  LBA 
		00003e88  00000023  LI    0x0 (D 0)
		00003e8c  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1404 start=4004 end=4009>
	<code>  p->nread = 0;</code>
	<emi>
		00003e90  0000140e  LL    0x14 (D 20)
		00003e94  000fa054  ADDI  0xfa0 (D 4000)
		00003e98  0000003e  LBA 
		00003e9c  00000023  LI    0x0 (D 0)
		00003ea0  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1405 start=4009 end=4012>
	<code>  rf->type = FD_PIPE;</code>
	<emi>
		00003ea4  00000123  LI    0x1 (D 1)
		00003ea8  00001026  LBL   0x10 (D 16)
		00003eac  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1406 start=4012 end=4017>
	<code>  rf->readable = 1;</code>
	<emi>
		00003eb0  0000100e  LL    0x10 (D 16)
		00003eb4  00000854  ADDI  0x8 (D 8)
		00003eb8  0000003e  LBA 
		00003ebc  00000123  LI    0x1 (D 1)
		00003ec0  0000004c  SXB 
	</emi>
</stmt>
<stmt file=os.c line=1407 start=4017 end=4022>
	<code>  rf->writable = 0;</code>
	<emi>
		00003ec4  0000100e  LL    0x10 (D 16)
		00003ec8  00000954  ADDI  0x9 (D 9)
		00003ecc  0000003e  LBA 
		00003ed0  00000023  LI    0x0 (D 0)
		00003ed4  0000004c  SXB 
	</emi>
</stmt>
<stmt file=os.c line=1408 start=4022 end=4027>
	<code>  rf->pipe = p;</code>
	<emi>
		00003ed8  0000100e  LL    0x10 (D 16)
		00003edc  00000c54  ADDI  0xc (D 12)
		00003ee0  0000003e  LBA 
		00003ee4  0000140e  LL    0x14 (D 20)
		00003ee8  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1409 start=4027 end=4030>
	<code>  wf->type = FD_PIPE;</code>
	<emi>
		00003eec  00000123  LI    0x1 (D 1)
		00003ef0  00000c26  LBL   0xc (D 12)
		00003ef4  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1410 start=4030 end=4035>
	<code>  wf->readable = 0;</code>
	<emi>
		00003ef8  00000c0e  LL    0xc (D 12)
		00003efc  00000854  ADDI  0x8 (D 8)
		00003f00  0000003e  LBA 
		00003f04  00000023  LI    0x0 (D 0)
		00003f08  0000004c  SXB 
	</emi>
</stmt>
<stmt file=os.c line=1411 start=4035 end=4040>
	<code>  wf->writable = 1;</code>
	<emi>
		00003f0c  00000c0e  LL    0xc (D 12)
		00003f10  00000954  ADDI  0x9 (D 9)
		00003f14  0000003e  LBA 
		00003f18  00000123  LI    0x1 (D 1)
		00003f1c  0000004c  SXB 
	</emi>
</stmt>
<stmt file=os.c line=1412 start=4040 end=4045>
	<code>  wf->pipe = p;</code>
	<emi>
		00003f20  00000c0e  LL    0xc (D 12)
		00003f24  00000c54  ADDI  0xc (D 12)
		00003f28  0000003e  LBA 
		00003f2c  0000140e  LL    0x14 (D 20)
		00003f30  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1413 start=4045 end=4045>
	<code></code>
</stmt>
<stmt file=os.c line=1414 start=4045 end=4059>
	<code>  if ((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0) {</code>
	<emi>
		00003f34  0000100e  LL    0x10 (D 16)
		00003f38  0000009d  PSHA
		00003f3c  ffe7b405  JSR   0xffffe7b4 (TO 0x26f4)
		00003f40  00000801  ENT   0x8 (D 8)
		00003f44  00000840  SL    0x8 (D 8)
		00003f48  0000003b  LBI   0x0 (D 0)
		00003f4c  0000008c  BLT   <fwd>
		00003f50  00000c0e  LL    0xc (D 12)
		00003f54  0000009d  PSHA
		00003f58  ffe79805  JSR   0xffffe798 (TO 0x26f4)
		00003f5c  00000801  ENT   0x8 (D 8)
		00003f60  00000440  SL    0x4 (D 4)
		00003f64  0000003b  LBI   0x0 (D 0)
		00003f68  0000008f  BGE   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1415 start=4059 end=4072>
	<code>    if (fd0 >= 0) u->ofile[fd0] = 0;</code>
	<emi>
		00003f6c  0000080e  LL    0x8 (D 8)
		00003f70  0000003b  LBI   0x0 (D 0)
		00003f74  0000008c  BLT   <fwd>
		00003f78  00210015  LG    0x2100 (D 8448)
		00003f7c  00003054  ADDI  0x30 (D 48)
		00003f80  0000009d  PSHA
		00003f84  0000100e  LL    0x10 (D 16)
		00003f88  0000045a  MULI  0x4 (D 4)
		00003f8c  000000a1  POPB
		00003f90  00000053  ADD 
		00003f94  0000003e  LBA 
		00003f98  00000023  LI    0x0 (D 0)
		00003f9c  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1416 start=4072 end=4076>
	<code>    fileclose(rf);</code>
	<emi>
		00003fa0  0000100e  LL    0x10 (D 16)
		00003fa4  0000009d  PSHA
		00003fa8  ffec8805  JSR   0xffffec88 (TO 0x2c34)
		00003fac  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1417 start=4076 end=4080>
	<code>    fileclose(wf);</code>
	<emi>
		00003fb0  00000c0e  LL    0xc (D 12)
		00003fb4  0000009d  PSHA
		00003fb8  ffec7805  JSR   0xffffec78 (TO 0x2c34)
		00003fbc  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1418 start=4080 end=4082>
	<code>    return -1;</code>
	<emi>
		00003fc0  ffffff23  LI    0xffffffff (D -1)
		00003fc4  00001802  LEV   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=1419 start=4082 end=4082>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1420 start=4082 end=4085>
	<code>  fd[0] = fd0;</code>
	<emi>
		00003fc8  0000080e  LL    0x8 (D 8)
		00003fcc  00002026  LBL   0x20 (D 32)
		00003fd0  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1421 start=4085 end=4090>
	<code>  fd[1] = fd1;</code>
	<emi>
		00003fd4  0000200e  LL    0x20 (D 32)
		00003fd8  00000454  ADDI  0x4 (D 4)
		00003fdc  0000003e  LBA 
		00003fe0  0000040e  LL    0x4 (D 4)
		00003fe4  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1422 start=4090 end=4092>
	<code>  return 0;</code>
	<emi>
		00003fe8  00000023  LI    0x0 (D 0)
		00003fec  00001802  LEV   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=1423 start=4092 end=4092>
	<code>}</code>
</stmt>
<stmt file=os.c line=1424 start=4092 end=4093>
	<code>uint *walkpdir(uint *pd, uint va);</code>
	<emi>
		00003ff0  00001802  LEV   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=1425 start=4093 end=4093>
	<code></code>
</stmt>
<stmt file=os.c line=1426 start=4093 end=4093>
	<code>int exec(char *path, char **argv)</code>
</stmt>
<stmt file=os.c line=1427 start=4093 end=4093>
	<code>{</code>
</stmt>
<stmt file=os.c line=1428 start=4093 end=4093>
	<code>  char *s, *last;</code>
</stmt>
<stmt file=os.c line=1429 start=4093 end=4093>
	<code>  uint argc, sz, sp, *stack, *pd, *oldpd, *pte;</code>
</stmt>
<stmt file=os.c line=1430 start=4093 end=4093>
	<code>  struct { uint magic, bss, entry, flags; } hdr;</code>
</stmt>
<stmt file=os.c line=1431 start=4093 end=4093>
	<code>  struct inode *ip;</code>
</stmt>
<stmt file=os.c line=1432 start=4093 end=4093>
	<code>  char cpath[16];  // XXX length, safety!</code>
</stmt>
<stmt file=os.c line=1433 start=4093 end=4093>
	<code>  int i, n, c;</code>
</stmt>
<stmt file=os.c line=1434 start=4093 end=4093>
	<code></code>
</stmt>
<stmt file=os.c line=1435 start=4093 end=4101>
	<code>  if (!svalid(path)) return -1;</code>
	<emi>
		00003ff4  ffffa801  ENT   0xffffffa8 (D -88)
		00003ff8  0000600e  LL    0x60 (D 96)
		00003ffc  0000009d  PSHA
		00004000  ffe9e805  JSR   0xffffe9e8 (TO 0x29ec)
		00004004  00000801  ENT   0x8 (D 8)
		00004008  00000086  BNZ   <fwd>
		0000400c  ffffff23  LI    0xffffffff (D -1)
		00004010  00005802  LEV   0x58 (D 88)
	</emi>
</stmt>
<stmt file=os.c line=1436 start=4101 end=4103>
	<code>  for (argc = 0; ; argc++) {</code>
	<emi>
		00004014  00000023  LI    0x0 (D 0)
		00004018  00004c40  SL    0x4c (D 76)
	</emi>
</stmt>
<stmt file=os.c line=1437 start=4103 end=4116>
	<code>    if (argc >= MAXARG || !mvalid(argv + argc, 4)) return -1;</code>
	<emi>
		0000401c  00004c0e  LL    0x4c (D 76)
		00004020  0001003b  LBI   0x100 (D 256)
		00004024  00000090  BGEU  <fwd>
		00004028  0000049e  PSHI  0x4 (D 4)
		0000402c  0000540e  LL    0x54 (D 84)
		00004030  0000045a  MULI  0x4 (D 4)
		00004034  00007055  ADDL  0x70 (D 112)
		00004038  0000009d  PSHA
		0000403c  ffe9fc05  JSR   0xffffe9fc (TO 0x2a3c)
		00004040  00001001  ENT   0x10 (D 16)
		00004044  00000086  BNZ   <fwd>
		00004048  ffffff23  LI    0xffffffff (D -1)
		0000404c  00005802  LEV   0x58 (D 88)
	</emi>
</stmt>
<stmt file=os.c line=1438 start=4116 end=4122>
	<code>    if (!argv[argc]) break;</code>
	<emi>
		00004050  00004c0e  LL    0x4c (D 76)
		00004054  0000045a  MULI  0x4 (D 4)
		00004058  00006855  ADDL  0x68 (D 104)
		0000405c  0000001c  LX  
		00004060  00000086  BNZ   <fwd>
		00004064  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1439 start=4122 end=4132>
	<code>    if (!svalid(argv[argc])) return -1;</code>
	<emi>
		00004068  00004c0e  LL    0x4c (D 76)
		0000406c  0000045a  MULI  0x4 (D 4)
		00004070  00006855  ADDL  0x68 (D 104)
		00004074  0000001c  LX  
		00004078  0000009d  PSHA
		0000407c  ffe96c05  JSR   0xffffe96c (TO 0x29ec)
		00004080  00000801  ENT   0x8 (D 8)
		00004084  00000086  BNZ   <fwd>
		00004088  ffffff23  LI    0xffffffff (D -1)
		0000408c  00005802  LEV   0x58 (D 88)
	</emi>
</stmt>
<stmt file=os.c line=1440 start=4132 end=4132>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1441 start=4132 end=4132>
	<code></code>
</stmt>
<stmt file=os.c line=1442 start=4132 end=4145>
	<code>  if (c = !(ip = namei(path))) {  </code>
	<emi>
		00004090  00004c0e  LL    0x4c (D 76)
		00004094  ffffff57  SUBI  0xffffffff (D -1)
		00004098  00004c40  SL    0x4c (D 76)
		0000409c  ffff7c03  JMP   0xffffff7c (TO 0x401c)
		000040a0  0000600e  LL    0x60 (D 96)
		000040a4  0000009d  PSHA
		000040a8  ffe06805  JSR   0xffffe068 (TO 0x2114)
		000040ac  00000801  ENT   0x8 (D 8)
		000040b0  00002040  SL    0x20 (D 32)
		000040b4  0000003b  LBI   0x0 (D 0)
		000040b8  0000007a  EQ  
		000040bc  00000440  SL    0x4 (D 4)
		000040c0  00000084  BZ    <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1443 start=4145 end=4157>
	<code>    memcpy(cpath, path, i = strlen(path));</code>
	<emi>
		000040c4  0000600e  LL    0x60 (D 96)
		000040c8  0000009d  PSHA
		000040cc  ffbfe805  JSR   0xffffbfe8 (TO 0xb8)
		000040d0  00000801  ENT   0x8 (D 8)
		000040d4  00000c40  SL    0xc (D 12)
		000040d8  0000009d  PSHA
		000040dc  0000680e  LL    0x68 (D 104)
		000040e0  0000009d  PSHA
		000040e4  00002007  LEA   0x20 (D 32)
		000040e8  0000009d  PSHA
		000040ec  ffbf1005  JSR   0xffffbf10 (TO 0x0)
		000040f0  00001801  ENT   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=1444 start=4157 end=4162>
	<code>    cpath[i] = '.';</code>
	<emi>
		000040f4  00001007  LEA   0x10 (D 16)
		000040f8  00000c55  ADDL  0xc (D 12)
		000040fc  0000003e  LBA 
		00004100  00002e23  LI    0x2e (D 46)
		00004104  0000004c  SXB 
	</emi>
</stmt>
<stmt file=os.c line=1445 start=4162 end=4171>
	<code>    cpath[i+1] = 'c';</code>
	<emi>
		00004108  00001007  LEA   0x10 (D 16)
		0000410c  0000009d  PSHA
		00004110  0000140e  LL    0x14 (D 20)
		00004114  00000154  ADDI  0x1 (D 1)
		00004118  000000a1  POPB
		0000411c  00000053  ADD 
		00004120  0000003e  LBA 
		00004124  00006323  LI    0x63 (D 99)
		00004128  0000004c  SXB 
	</emi>
</stmt>
<stmt file=os.c line=1446 start=4171 end=4180>
	<code>    cpath[i+2] = 0;</code>
	<emi>
		0000412c  00001007  LEA   0x10 (D 16)
		00004130  0000009d  PSHA
		00004134  0000140e  LL    0x14 (D 20)
		00004138  00000254  ADDI  0x2 (D 2)
		0000413c  000000a1  POPB
		00004140  00000053  ADD 
		00004144  0000003e  LBA 
		00004148  00000023  LI    0x0 (D 0)
		0000414c  0000004c  SXB 
	</emi>
</stmt>
<stmt file=os.c line=1447 start=4180 end=4187>
	<code>    if (!namei(cpath)) return -1;</code>
	<emi>
		00004150  00001007  LEA   0x10 (D 16)
		00004154  0000009d  PSHA
		00004158  ffdfb805  JSR   0xffffdfb8 (TO 0x2114)
		0000415c  00000801  ENT   0x8 (D 8)
		00004160  00000086  BNZ   <fwd>
		00004164  ffffff23  LI    0xffffffff (D -1)
		00004168  00005802  LEV   0x58 (D 88)
	</emi>
</stmt>
<stmt file=os.c line=1448 start=4187 end=4196>
	<code>    if (!(ip = namei(path = "/bin/c"))) return -1;</code>
	<emi>
		0000416c  00028c08  LEAG  0x28c (D 652)
		00004170  00006040  SL    0x60 (D 96)
		00004174  0000009d  PSHA
		00004178  ffdf9805  JSR   0xffffdf98 (TO 0x2114)
		0000417c  00000801  ENT   0x8 (D 8)
		00004180  00002040  SL    0x20 (D 32)
		00004184  00000086  BNZ   <fwd>
		00004188  ffffff23  LI    0xffffffff (D -1)
		0000418c  00005802  LEV   0x58 (D 88)
	</emi>
</stmt>
<stmt file=os.c line=1449 start=4196 end=4199>
	<code>    argv++;</code>
	<emi>
		00004190  0000680e  LL    0x68 (D 104)
		00004194  fffffc57  SUBI  0xfffffffc (D -4)
		00004198  00006840  SL    0x68 (D 104)
	</emi>
</stmt>
<stmt file=os.c line=1450 start=4199 end=4202>
	<code>    argc++;</code>
	<emi>
		0000419c  00004c0e  LL    0x4c (D 76)
		000041a0  ffffff57  SUBI  0xffffffff (D -1)
		000041a4  00004c40  SL    0x4c (D 76)
	</emi>
</stmt>
<stmt file=os.c line=1451 start=4202 end=4202>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1452 start=4202 end=4206>
	<code>  ilock(ip);</code>
	<emi>
		000041a8  0000200e  LL    0x20 (D 32)
		000041ac  0000009d  PSHA
		000041b0  ffcff405  JSR   0xffffcff4 (TO 0x11a8)
		000041b4  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1453 start=4206 end=4208>
	<code>  pd = 0;</code>
	<emi>
		000041b8  00000023  LI    0x0 (D 0)
		000041bc  00003c40  SL    0x3c (D 60)
	</emi>
</stmt>
<stmt file=os.c line=1454 start=4208 end=4208>
	<code></code>
</stmt>
<stmt file=os.c line=1455 start=4208 end=4208>
	<code>  // Check header</code>
</stmt>
<stmt file=os.c line=1456 start=4208 end=4219>
	<code>  if (readi(ip, (char *)&hdr, 0, sizeof(hdr)) < sizeof(hdr)) goto bad;</code>
	<emi>
		000041c0  0000109e  PSHI  0x10 (D 16)
		000041c4  0000009e  PSHI  0x0 (D 0)
		000041c8  00003407  LEA   0x34 (D 52)
		000041cc  0000009d  PSHA
		000041d0  0000380e  LL    0x38 (D 56)
		000041d4  0000009d  PSHA
		000041d8  ffd72c05  JSR   0xffffd72c (TO 0x1908)
		000041dc  00002001  ENT   0x20 (D 32)
		000041e0  0000103b  LBI   0x10 (D 16)
		000041e4  0000008f  BGE   <fwd>
		000041e8  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1457 start=4219 end=4224>
	<code>  if (hdr.magic != 0xC0DEF00D) goto bad; // XXX some more hdr checking?</code>
	<emi>
		000041ec  0000240e  LL    0x24 (D 36)
		000041f0  ffffc03b  LBI   0xffffffc0 (D -64)
		000041f4  def00d3c  LBHI  0xffdef00d (D -2166771)
		000041f8  00000088  BE    <fwd>
		000041fc  0041e803  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1458 start=4224 end=4224>
	<code></code>
</stmt>
<stmt file=os.c line=1459 start=4224 end=4232>
	<code>  pd = memcpy(kalloc(), kpdir, PAGE);</code>
	<emi>
		00004200  0010009e  PSHI  0x1000 (D 4096)
		00004204  00216815  LG    0x2168 (D 8552)
		00004208  0000009d  PSHA
		0000420c  ffbfdc05  JSR   0xffffbfdc (TO 0x1ec)
		00004210  0000009d  PSHA
		00004214  ffbde805  JSR   0xffffbde8 (TO 0x0)
		00004218  00001801  ENT   0x18 (D 24)
		0000421c  00003c40  SL    0x3c (D 60)
	</emi>
</stmt>
<stmt file=os.c line=1460 start=4232 end=4232>
	<code></code>
</stmt>
<stmt file=os.c line=1461 start=4232 end=4232>
	<code>  // XXX stack should go after heap</code>
</stmt>
<stmt file=os.c line=1462 start=4232 end=4232>
	<code></code>
</stmt>
<stmt file=os.c line=1463 start=4232 end=4232>
	<code>  // load text and data segment   XXX map the whole file copy on write</code>
</stmt>
<stmt file=os.c line=1464 start=4232 end=4244>
	<code>  if (!(sz = allocuvm(pd, 0, ip->size, 1))) goto bad;</code>
	<emi>
		00004220  0000019e  PSHI  0x1 (D 1)
		00004224  0000280e  LL    0x28 (D 40)
		00004228  0000141c  LX    0x14 (D 20)
		0000422c  0000009d  PSHA
		00004230  0000009e  PSHI  0x0 (D 0)
		00004234  0000540e  LL    0x54 (D 84)
		00004238  0000009d  PSHA
		0000423c  00000005  JSR   <fwd>
		00004240  00002001  ENT   0x20 (D 32)
		00004244  00004840  SL    0x48 (D 72)
		00004248  00000086  BNZ   <fwd>
		0000424c  0041fc03  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1465 start=4244 end=4244>
	<code></code>
</stmt>
<stmt file=os.c line=1466 start=4244 end=4247>
	<code>  for (i = 0; i < sz; i += PAGE) {</code>
	<emi>
		00004250  00000023  LI    0x0 (D 0)
		00004254  00000c40  SL    0xc (D 12)
		00004258  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1467 start=4247 end=4259>
	<code>    if (!(pte = walkpdir(pd, i))) panic("exit() address should exist");</code>
	<emi>
		0000425c  00000c0e  LL    0xc (D 12)
		00004260  0000009d  PSHA
		00004264  0000440e  LL    0x44 (D 68)
		00004268  0000009d  PSHA
		0000426c  00000005  JSR   <fwd>
		00004270  00001001  ENT   0x10 (D 16)
		00004274  00003440  SL    0x34 (D 52)
		00004278  00000086  BNZ   <fwd>
		0000427c  00029308  LEAG  0x293 (D 659)
		00004280  0000009d  PSHA
		00004284  ffc2ac05  JSR   0xffffc2ac (TO 0x534)
		00004288  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1468 start=4259 end=4268>
	<code>    n = (sz - i < PAGE) ? sz - i : PAGE;</code>
	<emi>
		0000428c  0000480e  LL    0x48 (D 72)
		00004290  00000c58  SUBL  0xc (D 12)
		00004294  0010003b  LBI   0x1000 (D 4096)
		00004298  00000090  BGEU  <fwd>
		0000429c  0000480e  LL    0x48 (D 72)
		000042a0  00000c58  SUBL  0xc (D 12)
		000042a4  00000003  JMP   <fwd>
		000042a8  00100023  LI    0x1000 (D 4096)
		000042ac  00000840  SL    0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1469 start=4268 end=4286>
	<code>    if (readi(ip, P2V+(*pte & -PAGE), i, n) != n) goto bad;</code>
	<emi>
		000042b0  0000080e  LL    0x8 (D 8)
		000042b4  0000009d  PSHA
		000042b8  0000140e  LL    0x14 (D 20)
		000042bc  0000009d  PSHA
		000042c0  0000440e  LL    0x44 (D 68)
		000042c4  0000001c  LX  
		000042c8  fff00069  ANDI  0xfffff000 (D -4096)
		000042cc  ffffc03b  LBI   0xffffffc0 (D -64)
		000042d0  0000003c  LBHI  0x0 (D 0)
		000042d4  00000053  ADD 
		000042d8  0000009d  PSHA
		000042dc  0000380e  LL    0x38 (D 56)
		000042e0  0000009d  PSHA
		000042e4  ffd62005  JSR   0xffffd620 (TO 0x1908)
		000042e8  00002001  ENT   0x20 (D 32)
		000042ec  00000826  LBL   0x8 (D 8)
		000042f0  00000088  BE    <fwd>
		000042f4  00424c03  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1470 start=4286 end=4286>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1471 start=4286 end=4286>
	<code>  </code>
</stmt>
<stmt file=os.c line=1472 start=4286 end=4296>
	<code>  iunlockput(ip);</code>
	<emi>
		000042f8  00000c0e  LL    0xc (D 12)
		000042fc  00100054  ADDI  0x1000 (D 4096)
		00004300  00000c40  SL    0xc (D 12)
		00004304  00000c0e  LL    0xc (D 12)
		00004308  00004826  LBL   0x48 (D 72)
		0000430c  0000008d  BLTU  <fwd>
		00004310  0000200e  LL    0x20 (D 32)
		00004314  0000009d  PSHA
		00004318  ffd1b405  JSR   0xffffd1b4 (TO 0x14d0)
		0000431c  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1473 start=4296 end=4298>
	<code>  ip = 0;</code>
	<emi>
		00004320  00000023  LI    0x0 (D 0)
		00004324  00002040  SL    0x20 (D 32)
	</emi>
</stmt>
<stmt file=os.c line=1474 start=4298 end=4298>
	<code>  </code>
</stmt>
<stmt file=os.c line=1475 start=4298 end=4298>
	<code>  // allocate bss and stack segment</code>
</stmt>
<stmt file=os.c line=1476 start=4298 end=4314>
	<code>  if (!(sz = allocuvm(pd, sz, sz + hdr.bss + STACKSZ, 0))) goto bad;</code>
	<emi>
		00004328  0000009e  PSHI  0x0 (D 0)
		0000432c  0000500e  LL    0x50 (D 80)
		00004330  00003055  ADDL  0x30 (D 48)
		00004334  0000003b  LBI   0x0 (D 0)
		00004338  8000003c  LBHI  0xff800000 (D -8388608)
		0000433c  00000053  ADD 
		00004340  0000009d  PSHA
		00004344  0000580e  LL    0x58 (D 88)
		00004348  0000009d  PSHA
		0000434c  0000540e  LL    0x54 (D 84)
		00004350  0000009d  PSHA
		00004354  00423c05  JSR   <fwd>
		00004358  00002001  ENT   0x20 (D 32)
		0000435c  00004840  SL    0x48 (D 72)
		00004360  00000086  BNZ   <fwd>
		00004364  0042f403  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1477 start=4314 end=4314>
	<code></code>
</stmt>
<stmt file=os.c line=1478 start=4314 end=4314>
	<code>  // initialize the top page of the stack</code>
</stmt>
<stmt file=os.c line=1479 start=4314 end=4317>
	<code>  sz &= -PAGE;</code>
	<emi>
		00004368  0000480e  LL    0x48 (D 72)
		0000436c  fff00069  ANDI  0xfffff000 (D -4096)
		00004370  00004840  SL    0x48 (D 72)
	</emi>
</stmt>
<stmt file=os.c line=1480 start=4317 end=4335>
	<code>  mappage(pd, sz, V2P+(sp = memset(kalloc(), 0, PAGE)), PTE_P | PTE_W | PTE_U);</code>
	<emi>
		00004374  0000079e  PSHI  0x7 (D 7)
		00004378  0010009e  PSHI  0x1000 (D 4096)
		0000437c  0000009e  PSHI  0x0 (D 0)
		00004380  ffbe6805  JSR   0xffffbe68 (TO 0x1ec)
		00004384  0000009d  PSHA
		00004388  ffbc8c05  JSR   0xffffbc8c (TO 0x18)
		0000438c  00001801  ENT   0x18 (D 24)
		00004390  00004c40  SL    0x4c (D 76)
		00004394  0000403b  LBI   0x40 (D 64)
		00004398  0000003c  LBHI  0x0 (D 0)
		0000439c  00000053  ADD 
		000043a0  0000009d  PSHA
		000043a4  0000580e  LL    0x58 (D 88)
		000043a8  0000009d  PSHA
		000043ac  0000540e  LL    0x54 (D 84)
		000043b0  0000009d  PSHA
		000043b4  00000005  JSR   <fwd>
		000043b8  00002001  ENT   0x20 (D 32)
	</emi>
</stmt>
<stmt file=os.c line=1481 start=4335 end=4335>
	<code></code>
</stmt>
<stmt file=os.c line=1482 start=4335 end=4335>
	<code>  // prepare stack arguments</code>
</stmt>
<stmt file=os.c line=1483 start=4335 end=4344>
	<code>  stack = sp += PAGE - (argc+1)*4;</code>
	<emi>
		000043bc  00004c0e  LL    0x4c (D 76)
		000043c0  00000154  ADDI  0x1 (D 1)
		000043c4  0000045a  MULI  0x4 (D 4)
		000043c8  0000003e  LBA 
		000043cc  00100023  LI    0x1000 (D 4096)
		000043d0  00000056  SUB 
		000043d4  00004455  ADDL  0x44 (D 68)
		000043d8  00004440  SL    0x44 (D 68)
		000043dc  00004040  SL    0x40 (D 64)
	</emi>
</stmt>
<stmt file=os.c line=1484 start=4344 end=4347>
	<code>  for (i=0; i<argc; i++) {</code>
	<emi>
		000043e0  00000023  LI    0x0 (D 0)
		000043e4  00000c40  SL    0xc (D 12)
		000043e8  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1485 start=4347 end=4363>
	<code>    s = (!c || i > 1) ? *argv++ : (i ? cpath : path);</code>
	<emi>
		000043ec  0000040e  LL    0x4 (D 4)
		000043f0  00000084  BZ    <fwd>
		000043f4  00000123  LI    0x1 (D 1)
		000043f8  00000c26  LBL   0xc (D 12)
		000043fc  0000008f  BGE   <fwd>
		00004400  0000680e  LL    0x68 (D 104)
		00004404  fffffc57  SUBI  0xfffffffc (D -4)
		00004408  00006840  SL    0x68 (D 104)
		0000440c  fffffc1c  LX    0xfffffffc (D -4)
		00004410  00000003  JMP   <fwd>
		00004414  00000c0e  LL    0xc (D 12)
		00004418  00000084  BZ    <fwd>
		0000441c  00001007  LEA   0x10 (D 16)
		00004420  00000003  JMP   <fwd>
		00004424  0000600e  LL    0x60 (D 96)
		00004428  00005440  SL    0x54 (D 84)
	</emi>
</stmt>
<stmt file=os.c line=1486 start=4363 end=4369>
	<code>    n = strlen(s) + 1;</code>
	<emi>
		0000442c  0000540e  LL    0x54 (D 84)
		00004430  0000009d  PSHA
		00004434  ffbc8005  JSR   0xffffbc80 (TO 0xb8)
		00004438  00000801  ENT   0x8 (D 8)
		0000443c  00000154  ADDI  0x1 (D 1)
		00004440  00000840  SL    0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1487 start=4369 end=4374>
	<code>    if ((sp & (PAGE - 1)) < n) goto bad;</code>
	<emi>
		00004444  0000440e  LL    0x44 (D 68)
		00004448  000fff69  ANDI  0xfff (D 4095)
		0000444c  00000826  LBL   0x8 (D 8)
		00004450  00000090  BGEU  <fwd>
		00004454  00436403  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1488 start=4374 end=4377>
	<code>    sp -= n;</code>
	<emi>
		00004458  0000440e  LL    0x44 (D 68)
		0000445c  00000858  SUBL  0x8 (D 8)
		00004460  00004440  SL    0x44 (D 68)
	</emi>
</stmt>
<stmt file=os.c line=1489 start=4377 end=4385>
	<code>    memcpy(sp, s, n);</code>
	<emi>
		00004464  0000080e  LL    0x8 (D 8)
		00004468  0000009d  PSHA
		0000446c  00005c0e  LL    0x5c (D 92)
		00004470  0000009d  PSHA
		00004474  0000540e  LL    0x54 (D 84)
		00004478  0000009d  PSHA
		0000447c  ffbb8005  JSR   0xffffbb80 (TO 0x0)
		00004480  00001801  ENT   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=1490 start=4385 end=4394>
	<code>    stack[i] = sz + (sp & (PAGE - 1));</code>
	<emi>
		00004484  00000c0e  LL    0xc (D 12)
		00004488  0000045a  MULI  0x4 (D 4)
		0000448c  00004055  ADDL  0x40 (D 64)
		00004490  0000009d  PSHA
		00004494  00004c0e  LL    0x4c (D 76)
		00004498  000fff69  ANDI  0xfff (D 4095)
		0000449c  00005055  ADDL  0x50 (D 80)
		000044a0  000000a1  POPB
		000044a4  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1491 start=4394 end=4394>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1492 start=4394 end=4406>
	<code>  stack[argc] = 0;</code>
	<emi>
		000044a8  00000c0e  LL    0xc (D 12)
		000044ac  ffffff57  SUBI  0xffffffff (D -1)
		000044b0  00000c40  SL    0xc (D 12)
		000044b4  00000c0e  LL    0xc (D 12)
		000044b8  00004c26  LBL   0x4c (D 76)
		000044bc  0000008d  BLTU  <fwd>
		000044c0  00004c0e  LL    0x4c (D 76)
		000044c4  0000045a  MULI  0x4 (D 4)
		000044c8  00004055  ADDL  0x40 (D 64)
		000044cc  0000003e  LBA 
		000044d0  00000023  LI    0x0 (D 0)
		000044d4  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1493 start=4406 end=4410>
	<code>  if ((sp & (PAGE - 1)) < 40) { // XXX 40? stick into above loop?</code>
	<emi>
		000044d8  0000440e  LL    0x44 (D 68)
		000044dc  000fff69  ANDI  0xfff (D 4095)
		000044e0  0000283b  LBI   0x28 (D 40)
		000044e4  00000090  BGEU  <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1494 start=4410 end=4410>
	<code>bad:</code>
</stmt>
<stmt file=os.c line=1495 start=4410 end=4416>
	<code>    if (pd) freevm(pd);</code>
	<emi>
		000044e8  00003c0e  LL    0x3c (D 60)
		000044ec  00000084  BZ    <fwd>
		000044f0  00003c0e  LL    0x3c (D 60)
		000044f4  0000009d  PSHA
		000044f8  00000005  JSR   <fwd>
		000044fc  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1496 start=4416 end=4422>
	<code>    if (ip) iunlockput(ip);</code>
	<emi>
		00004500  0000200e  LL    0x20 (D 32)
		00004504  00000084  BZ    <fwd>
		00004508  0000200e  LL    0x20 (D 32)
		0000450c  0000009d  PSHA
		00004510  ffcfbc05  JSR   0xffffcfbc (TO 0x14d0)
		00004514  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1497 start=4422 end=4424>
	<code>    return -1;</code>
	<emi>
		00004518  ffffff23  LI    0xffffffff (D -1)
		0000451c  00005802  LEV   0x58 (D 88)
	</emi>
</stmt>
<stmt file=os.c line=1498 start=4424 end=4424>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1499 start=4424 end=4429>
	<code>  stack = sp = (sp - 28) & -8;</code>
	<emi>
		00004520  0000440e  LL    0x44 (D 68)
		00004524  ffffe454  ADDI  0xffffffe4 (D -28)
		00004528  fffff869  ANDI  0xfffffff8 (D -8)
		0000452c  00004440  SL    0x44 (D 68)
		00004530  00004040  SL    0x40 (D 64)
	</emi>
</stmt>
<stmt file=os.c line=1500 start=4429 end=4435>
	<code>  stack[0] = sz + ((sp + 24) & (PAGE - 1)); // return address</code>
	<emi>
		00004534  0000440e  LL    0x44 (D 68)
		00004538  00001854  ADDI  0x18 (D 24)
		0000453c  000fff69  ANDI  0xfff (D 4095)
		00004540  00004855  ADDL  0x48 (D 72)
		00004544  00004026  LBL   0x40 (D 64)
		00004548  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1501 start=4435 end=4440>
	<code>  stack[2] = argc;</code>
	<emi>
		0000454c  0000400e  LL    0x40 (D 64)
		00004550  00000854  ADDI  0x8 (D 8)
		00004554  0000003e  LBA 
		00004558  00004c0e  LL    0x4c (D 76)
		0000455c  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1502 start=4440 end=4453>
	<code>  stack[4] = sz + PAGE - (argc+1)*4; // argv</code>
	<emi>
		00004560  0000400e  LL    0x40 (D 64)
		00004564  00001054  ADDI  0x10 (D 16)
		00004568  0000009d  PSHA
		0000456c  0000540e  LL    0x54 (D 84)
		00004570  00000154  ADDI  0x1 (D 1)
		00004574  0000045a  MULI  0x4 (D 4)
		00004578  0000009d  PSHA
		0000457c  0000580e  LL    0x58 (D 88)
		00004580  00100054  ADDI  0x1000 (D 4096)
		00004584  000000a1  POPB
		00004588  00000056  SUB 
		0000458c  000000a1  POPB
		00004590  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1503 start=4453 end=4458>
	<code>  stack[6] = TRAP | (S_exit<<8); // call exit if main returns</code>
	<emi>
		00004594  0000400e  LL    0x40 (D 64)
		00004598  00001854  ADDI  0x18 (D 24)
		0000459c  0000003e  LBA 
		000045a0  0002a923  LI    0x2a9 (D 681)
		000045a4  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1504 start=4458 end=4458>
	<code></code>
</stmt>
<stmt file=os.c line=1505 start=4458 end=4458>
	<code>  // save program name for debugging XXX</code>
</stmt>
<stmt file=os.c line=1506 start=4458 end=4461>
	<code>  for (last=s=path; *s; s++)</code>
	<emi>
		000045a8  0000600e  LL    0x60 (D 96)
		000045ac  00005440  SL    0x54 (D 84)
		000045b0  00005040  SL    0x50 (D 80)
	</emi>
</stmt>
<stmt file=os.c line=1507 start=4461 end=4469>
	<code>    if (*s == '/') last = s+1;</code>
	<emi>
		000045b4  00000003  JMP   <fwd>
		000045b8  0000540e  LL    0x54 (D 84)
		000045bc  0000001f  LXC 
		000045c0  00002f3b  LBI   0x2f (D 47)
		000045c4  0000008a  BNE   <fwd>
		000045c8  0000540e  LL    0x54 (D 84)
		000045cc  00000154  ADDI  0x1 (D 1)
		000045d0  00005040  SL    0x50 (D 80)
	</emi>
</stmt>
<stmt file=os.c line=1508 start=4469 end=4483>
	<code>  safestrcpy(u->name, last, sizeof(u->name));</code>
	<emi>
		000045d4  0000540e  LL    0x54 (D 84)
		000045d8  ffffff57  SUBI  0xffffffff (D -1)
		000045dc  00005440  SL    0x54 (D 84)
		000045e0  0000540e  LL    0x54 (D 84)
		000045e4  0000001f  LXC 
		000045e8  00000086  BNZ   <fwd>
		000045ec  0000109e  PSHI  0x10 (D 16)
		000045f0  0000580e  LL    0x58 (D 88)
		000045f4  0000009d  PSHA
		000045f8  00210015  LG    0x2100 (D 8448)
		000045fc  00007454  ADDI  0x74 (D 116)
		00004600  0000009d  PSHA
		00004604  ffbb7005  JSR   0xffffbb70 (TO 0x178)
		00004608  00001801  ENT   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=1509 start=4483 end=4483>
	<code>  </code>
</stmt>
<stmt file=os.c line=1510 start=4483 end=4483>
	<code>  // commit to the user image</code>
</stmt>
<stmt file=os.c line=1511 start=4483 end=4486>
	<code>  oldpd = u->pdir;</code>
	<emi>
		0000460c  00210015  LG    0x2100 (D 8448)
		00004610  00000c1c  LX    0xc (D 12)
		00004614  00003840  SL    0x38 (D 56)
	</emi>
</stmt>
<stmt file=os.c line=1512 start=4486 end=4491>
	<code>  u->pdir = pd;</code>
	<emi>
		00004618  00210015  LG    0x2100 (D 8448)
		0000461c  00000c54  ADDI  0xc (D 12)
		00004620  0000003e  LBA 
		00004624  00003c0e  LL    0x3c (D 60)
		00004628  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1513 start=4491 end=4498>
	<code>  u->sz = sz + PAGE;</code>
	<emi>
		0000462c  00210015  LG    0x2100 (D 8448)
		00004630  00000854  ADDI  0x8 (D 8)
		00004634  0000009d  PSHA
		00004638  0000500e  LL    0x50 (D 80)
		0000463c  00100054  ADDI  0x1000 (D 4096)
		00004640  000000a1  POPB
		00004644  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1514 start=4498 end=4504>
	<code>  u->tf->fc = USER;</code>
	<emi>
		00004648  00210015  LG    0x2100 (D 8448)
		0000464c  0000201c  LX    0x20 (D 32)
		00004650  00003054  ADDI  0x30 (D 48)
		00004654  0000003e  LBA 
		00004658  00001023  LI    0x10 (D 16)
		0000465c  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1515 start=4504 end=4512>
	<code>  u->tf->pc = hdr.entry + sizeof(hdr);</code>
	<emi>
		00004660  00210015  LG    0x2100 (D 8448)
		00004664  0000201c  LX    0x20 (D 32)
		00004668  00003854  ADDI  0x38 (D 56)
		0000466c  0000009d  PSHA
		00004670  0000340e  LL    0x34 (D 52)
		00004674  00001054  ADDI  0x10 (D 16)
		00004678  000000a1  POPB
		0000467c  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1516 start=4512 end=4520>
	<code>  u->tf->sp = sz + (sp & (PAGE - 1));</code>
	<emi>
		00004680  00210015  LG    0x2100 (D 8448)
		00004684  0000201c  LX    0x20 (D 32)
		00004688  0000009d  PSHA
		0000468c  00004c0e  LL    0x4c (D 76)
		00004690  000fff69  ANDI  0xfff (D 4095)
		00004694  00005055  ADDL  0x50 (D 80)
		00004698  000000a1  POPB
		0000469c  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1517 start=4520 end=4528>
	<code>  pdir(V2P+(uint)(u->pdir));</code>
	<emi>
		000046a0  00210015  LG    0x2100 (D 8448)
		000046a4  00000c1c  LX    0xc (D 12)
		000046a8  0000403b  LBI   0x40 (D 64)
		000046ac  0000003c  LBHI  0x0 (D 0)
		000046b0  00000053  ADD 
		000046b4  0000009d  PSHA
		000046b8  ffb9cc05  JSR   0xffffb9cc (TO 0x88)
		000046bc  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1518 start=4528 end=4532>
	<code>  freevm(oldpd);</code>
	<emi>
		000046c0  0000380e  LL    0x38 (D 56)
		000046c4  0000009d  PSHA
		000046c8  0044f805  JSR   <fwd>
		000046cc  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1519 start=4532 end=4534>
	<code>  return 0;</code>
	<emi>
		000046d0  00000023  LI    0x0 (D 0)
		000046d4  00005802  LEV   0x58 (D 88)
	</emi>
</stmt>
<stmt file=os.c line=1520 start=4534 end=4534>
	<code>}</code>
</stmt>
<stmt file=os.c line=1521 start=4534 end=4534>
	<code></code>
</stmt>
<stmt file=os.c line=1522 start=4534 end=4535>
	<code>struct proc *allocproc();</code>
	<emi>
		000046d8  00005802  LEV   0x58 (D 88)
	</emi>
</stmt>
<stmt file=os.c line=1523 start=4535 end=4535>
	<code>uint *copyuvm(uint *pd, uint sz);</code>
</stmt>
<stmt file=os.c line=1524 start=4535 end=4535>
	<code></code>
</stmt>
<stmt file=os.c line=1525 start=4535 end=4535>
	<code>int fork()</code>
</stmt>
<stmt file=os.c line=1526 start=4535 end=4535>
	<code>{</code>
</stmt>
<stmt file=os.c line=1527 start=4535 end=4535>
	<code>  int i, pid;</code>
</stmt>
<stmt file=os.c line=1528 start=4535 end=4535>
	<code>  struct proc *np;</code>
</stmt>
<stmt file=os.c line=1529 start=4535 end=4535>
	<code></code>
</stmt>
<stmt file=os.c line=1530 start=4535 end=4541>
	<code>  if (!(np = allocproc())) return -1;</code>
	<emi>
		000046dc  fffff001  ENT   0xfffffff0 (D -16)
		000046e0  00000005  JSR   <fwd>
		000046e4  00000440  SL    0x4 (D 4)
		000046e8  00000086  BNZ   <fwd>
		000046ec  ffffff23  LI    0xffffffff (D -1)
		000046f0  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1531 start=4541 end=4554>
	<code>  np->pdir = copyuvm(u->pdir, u->sz); // copy process state</code>
	<emi>
		000046f4  0000040e  LL    0x4 (D 4)
		000046f8  00000c54  ADDI  0xc (D 12)
		000046fc  0000009d  PSHA
		00004700  00210015  LG    0x2100 (D 8448)
		00004704  0000081c  LX    0x8 (D 8)
		00004708  0000009d  PSHA
		0000470c  00210015  LG    0x2100 (D 8448)
		00004710  00000c1c  LX    0xc (D 12)
		00004714  0000009d  PSHA
		00004718  00000005  JSR   <fwd>
		0000471c  00001001  ENT   0x10 (D 16)
		00004720  000000a1  POPB
		00004724  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1532 start=4554 end=4561>
	<code>  np->sz = u->sz;</code>
	<emi>
		00004728  0000040e  LL    0x4 (D 4)
		0000472c  00000854  ADDI  0x8 (D 8)
		00004730  0000009d  PSHA
		00004734  00210015  LG    0x2100 (D 8448)
		00004738  0000081c  LX    0x8 (D 8)
		0000473c  000000a1  POPB
		00004740  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1533 start=4561 end=4566>
	<code>  np->parent = u;</code>
	<emi>
		00004744  0000040e  LL    0x4 (D 4)
		00004748  00001c54  ADDI  0x1c (D 28)
		0000474c  0000003e  LBA 
		00004750  00210015  LG    0x2100 (D 8448)
		00004754  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1534 start=4566 end=4575>
	<code>  memcpy(np->tf, u->tf, sizeof(struct trapframe));</code>
	<emi>
		00004758  0000409e  PSHI  0x40 (D 64)
		0000475c  00210015  LG    0x2100 (D 8448)
		00004760  0000201c  LX    0x20 (D 32)
		00004764  0000009d  PSHA
		00004768  0000140e  LL    0x14 (D 20)
		0000476c  0000201c  LX    0x20 (D 32)
		00004770  0000009d  PSHA
		00004774  ffb88805  JSR   0xffffb888 (TO 0x0)
		00004778  00001801  ENT   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=1535 start=4575 end=4581>
	<code>  np->tf->a = 0; // child returns 0</code>
	<emi>
		0000477c  0000040e  LL    0x4 (D 4)
		00004780  0000201c  LX    0x20 (D 32)
		00004784  00002854  ADDI  0x28 (D 40)
		00004788  0000003e  LBA 
		0000478c  00000023  LI    0x0 (D 0)
		00004790  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1536 start=4581 end=4583>
	<code>  for (i = 0; i < NOFILE; i++)</code>
	<emi>
		00004794  00000023  LI    0x0 (D 0)
		00004798  00000c40  SL    0xc (D 12)
	</emi>
</stmt>
<stmt file=os.c line=1537 start=4583 end=4614>
	<code>    if (u->ofile[i]) np->ofile[i] = filedup(u->ofile[i]);</code>
	<emi>
		0000479c  00000003  JMP   <fwd>
		000047a0  00210015  LG    0x2100 (D 8448)
		000047a4  00003054  ADDI  0x30 (D 48)
		000047a8  0000009d  PSHA
		000047ac  0000140e  LL    0x14 (D 20)
		000047b0  0000045a  MULI  0x4 (D 4)
		000047b4  000000a1  POPB
		000047b8  00000053  ADD 
		000047bc  0000001c  LX  
		000047c0  00000084  BZ    <fwd>
		000047c4  0000040e  LL    0x4 (D 4)
		000047c8  00003054  ADDI  0x30 (D 48)
		000047cc  0000009d  PSHA
		000047d0  0000140e  LL    0x14 (D 20)
		000047d4  0000045a  MULI  0x4 (D 4)
		000047d8  000000a1  POPB
		000047dc  00000053  ADD 
		000047e0  0000009d  PSHA
		000047e4  00210015  LG    0x2100 (D 8448)
		000047e8  00003054  ADDI  0x30 (D 48)
		000047ec  0000009d  PSHA
		000047f0  00001c0e  LL    0x1c (D 28)
		000047f4  0000045a  MULI  0x4 (D 4)
		000047f8  000000a1  POPB
		000047fc  00000053  ADD 
		00004800  0000001c  LX  
		00004804  0000009d  PSHA
		00004808  ffde8805  JSR   0xffffde88 (TO 0x2694)
		0000480c  00000801  ENT   0x8 (D 8)
		00004810  000000a1  POPB
		00004814  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1538 start=4614 end=4630>
	<code>  idup(np->cwd = u->cwd);</code>
	<emi>
		00004818  00000c0e  LL    0xc (D 12)
		0000481c  ffffff57  SUBI  0xffffffff (D -1)
		00004820  00000c40  SL    0xc (D 12)
		00004824  00000c0e  LL    0xc (D 12)
		00004828  0000103b  LBI   0x10 (D 16)
		0000482c  0000008c  BLT   <fwd>
		00004830  0000040e  LL    0x4 (D 4)
		00004834  00007054  ADDI  0x70 (D 112)
		00004838  0000009d  PSHA
		0000483c  00210015  LG    0x2100 (D 8448)
		00004840  0000701c  LX    0x70 (D 112)
		00004844  000000a1  POPB
		00004848  0000004a  SX  
		0000484c  0000009d  PSHA
		00004850  ffc91c05  JSR   0xffffc91c (TO 0x1170)
		00004854  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1539 start=4630 end=4633>
	<code>  pid = np->pid;</code>
	<emi>
		00004858  0000040e  LL    0x4 (D 4)
		0000485c  0000181c  LX    0x18 (D 24)
		00004860  00000840  SL    0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1540 start=4633 end=4642>
	<code>  safestrcpy(np->name, u->name, sizeof(u->name));</code>
	<emi>
		00004864  0000109e  PSHI  0x10 (D 16)
		00004868  00210015  LG    0x2100 (D 8448)
		0000486c  00007454  ADDI  0x74 (D 116)
		00004870  0000009d  PSHA
		00004874  0000140e  LL    0x14 (D 20)
		00004878  00007454  ADDI  0x74 (D 116)
		0000487c  0000009d  PSHA
		00004880  ffb8f405  JSR   0xffffb8f4 (TO 0x178)
		00004884  00001801  ENT   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=1541 start=4642 end=4647>
	<code>  np->state = RUNNABLE;</code>
	<emi>
		00004888  0000040e  LL    0x4 (D 4)
		0000488c  00001454  ADDI  0x14 (D 20)
		00004890  0000003e  LBA 
		00004894  00000323  LI    0x3 (D 3)
		00004898  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1542 start=4647 end=4649>
	<code>  return pid;</code>
	<emi>
		0000489c  0000080e  LL    0x8 (D 8)
		000048a0  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1543 start=4649 end=4649>
	<code>}</code>
</stmt>
<stmt file=os.c line=1544 start=4649 end=4649>
	<code></code>
</stmt>
<stmt file=os.c line=1545 start=4649 end=4649>
	<code>// Exit the current process.  Does not return.  An exited process remains in the zombie state</code>
</stmt>
<stmt file=os.c line=1546 start=4649 end=4649>
	<code>// until its parent calls wait() to find out it exited.  Special treatment for process 0 and 1.</code>
</stmt>
<stmt file=os.c line=1547 start=4649 end=4650>
	<code>exit(int rc)</code>
	<emi>
		000048a4  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1548 start=4650 end=4650>
	<code>{</code>
</stmt>
<stmt file=os.c line=1549 start=4650 end=4650>
	<code>  struct proc *p; int fd;</code>
</stmt>
<stmt file=os.c line=1550 start=4650 end=4650>
	<code></code>
</stmt>
<stmt file=os.c line=1551 start=4650 end=4650>
	<code>//  printf("exit(%d)\n",rc); // XXX do something with return code</code>
</stmt>
<stmt file=os.c line=1552 start=4650 end=4657>
	<code>  if (u->pid == 0) { for (;;) asm(IDLE); } // spin in the arms of the kernel (cant be paged out)</code>
	<emi>
		000048a8  fffff801  ENT   0xfffffff8 (D -8)
		000048ac  00210015  LG    0x2100 (D 8448)
		000048b0  0000181c  LX    0x18 (D 24)
		000048b4  0000003b  LBI   0x0 (D 0)
		000048b8  0000008a  BNE   <fwd>
		000048bc  000000d0  IDLE
		000048c0  fffff803  JMP   0xfffffff8 (TO 0x48bc)
	</emi>
</stmt>
<stmt file=os.c line=1553 start=4657 end=4666>
	<code>  else if (u->pid == 1) panic("exit() init exiting"); // XXX reboot after all processes go away?</code>
	<emi>
		000048c4  00000003  JMP   <fwd>
		000048c8  00210015  LG    0x2100 (D 8448)
		000048cc  0000181c  LX    0x18 (D 24)
		000048d0  0000013b  LBI   0x1 (D 1)
		000048d4  0000008a  BNE   <fwd>
		000048d8  0002af08  LEAG  0x2af (D 687)
		000048dc  0000009d  PSHA
		000048e0  ffbc5005  JSR   0xffffbc50 (TO 0x534)
		000048e4  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1554 start=4666 end=4666>
	<code></code>
</stmt>
<stmt file=os.c line=1555 start=4666 end=4666>
	<code>  // close all open files</code>
</stmt>
<stmt file=os.c line=1556 start=4666 end=4669>
	<code>  for (fd = 0; fd < NOFILE; fd++) {</code>
	<emi>
		000048e8  00000023  LI    0x0 (D 0)
		000048ec  00000040  SL    0x0 (D 0)
		000048f0  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1557 start=4669 end=4678>
	<code>    if (u->ofile[fd]) {</code>
	<emi>
		000048f4  00210015  LG    0x2100 (D 8448)
		000048f8  00003054  ADDI  0x30 (D 48)
		000048fc  0000009d  PSHA
		00004900  0000080e  LL    0x8 (D 8)
		00004904  0000045a  MULI  0x4 (D 4)
		00004908  000000a1  POPB
		0000490c  00000053  ADD 
		00004910  0000001c  LX  
		00004914  00000084  BZ    <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1558 start=4678 end=4689>
	<code>      fileclose(u->ofile[fd]);</code>
	<emi>
		00004918  00210015  LG    0x2100 (D 8448)
		0000491c  00003054  ADDI  0x30 (D 48)
		00004920  0000009d  PSHA
		00004924  0000080e  LL    0x8 (D 8)
		00004928  0000045a  MULI  0x4 (D 4)
		0000492c  000000a1  POPB
		00004930  00000053  ADD 
		00004934  0000001c  LX  
		00004938  0000009d  PSHA
		0000493c  ffe2f405  JSR   0xffffe2f4 (TO 0x2c34)
		00004940  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1559 start=4689 end=4699>
	<code>      u->ofile[fd] = 0;</code>
	<emi>
		00004944  00210015  LG    0x2100 (D 8448)
		00004948  00003054  ADDI  0x30 (D 48)
		0000494c  0000009d  PSHA
		00004950  0000080e  LL    0x8 (D 8)
		00004954  0000045a  MULI  0x4 (D 4)
		00004958  000000a1  POPB
		0000495c  00000053  ADD 
		00004960  0000003e  LBA 
		00004964  00000023  LI    0x0 (D 0)
		00004968  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1560 start=4699 end=4699>
	<code>    }</code>
</stmt>
<stmt file=os.c line=1561 start=4699 end=4699>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1562 start=4699 end=4710>
	<code>  iput(u->cwd);</code>
	<emi>
		0000496c  0000000e  LL    0x0 (D 0)
		00004970  ffffff57  SUBI  0xffffffff (D -1)
		00004974  00000040  SL    0x0 (D 0)
		00004978  0000000e  LL    0x0 (D 0)
		0000497c  0000103b  LBI   0x10 (D 16)
		00004980  0000008c  BLT   <fwd>
		00004984  00210015  LG    0x2100 (D 8448)
		00004988  0000701c  LX    0x70 (D 112)
		0000498c  0000009d  PSHA
		00004990  ffca2c05  JSR   0xffffca2c (TO 0x13c0)
		00004994  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1563 start=4710 end=4715>
	<code>  u->cwd = 0;</code>
	<emi>
		00004998  00210015  LG    0x2100 (D 8448)
		0000499c  00007054  ADDI  0x70 (D 112)
		000049a0  0000003e  LBA 
		000049a4  00000023  LI    0x0 (D 0)
		000049a8  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1564 start=4715 end=4715>
	<code></code>
</stmt>
<stmt file=os.c line=1565 start=4715 end=4716>
	<code>  asm(CLI);</code>
	<emi>
		000049ac  00000096  CLI 
	</emi>
</stmt>
<stmt file=os.c line=1566 start=4716 end=4716>
	<code></code>
</stmt>
<stmt file=os.c line=1567 start=4716 end=4716>
	<code>  // parent might be sleeping in wait()</code>
</stmt>
<stmt file=os.c line=1568 start=4716 end=4721>
	<code>  wakeup(u->parent);</code>
	<emi>
		000049b0  00210015  LG    0x2100 (D 8448)
		000049b4  00001c1c  LX    0x1c (D 28)
		000049b8  0000009d  PSHA
		000049bc  0025e805  JSR   <fwd>
		000049c0  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1569 start=4721 end=4721>
	<code></code>
</stmt>
<stmt file=os.c line=1570 start=4721 end=4721>
	<code>  // pass abandoned children to init</code>
</stmt>
<stmt file=os.c line=1571 start=4721 end=4724>
	<code>  for (p = proc; p < &proc[NPROC]; p++) {</code>
	<emi>
		000049c4  00000008  LEAG  0x0 (D 0)
		000049c8  00000440  SL    0x4 (D 4)
		000049cc  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1572 start=4724 end=4728>
	<code>    if (p->parent == u) {</code>
	<emi>
		000049d0  0000040e  LL    0x4 (D 4)
		000049d4  00001c1c  LX    0x1c (D 28)
		000049d8  0021002d  LBG   0x2100 (D 8448)
		000049dc  0000008a  BNE   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1573 start=4728 end=4733>
	<code>      p->parent = init;</code>
	<emi>
		000049e0  0000040e  LL    0x4 (D 4)
		000049e4  00001c54  ADDI  0x1c (D 28)
		000049e8  0000003e  LBA 
		000049ec  00210415  LG    0x2104 (D 8452)
		000049f0  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1574 start=4733 end=4741>
	<code>      if (p->state == ZOMBIE) wakeup(init);</code>
	<emi>
		000049f4  0000040e  LL    0x4 (D 4)
		000049f8  0000141c  LX    0x14 (D 20)
		000049fc  0000053b  LBI   0x5 (D 5)
		00004a00  0000008a  BNE   <fwd>
		00004a04  00210415  LG    0x2104 (D 8452)
		00004a08  0000009d  PSHA
		00004a0c  0049bc05  JSR   <fwd>
		00004a10  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1575 start=4741 end=4741>
	<code>    }</code>
</stmt>
<stmt file=os.c line=1576 start=4741 end=4741>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1577 start=4741 end=4741>
	<code></code>
</stmt>
<stmt file=os.c line=1578 start=4741 end=4741>
	<code>  // jump into the scheduler, never to return</code>
</stmt>
<stmt file=os.c line=1579 start=4741 end=4753>
	<code>  u->state = ZOMBIE;</code>
	<emi>
		00004a14  0000040e  LL    0x4 (D 4)
		00004a18  ffff7c57  SUBI  0xffffff7c (D -132)
		00004a1c  00000440  SL    0x4 (D 4)
		00004a20  00210008  LEAG  0x2100 (D 8448)
		00004a24  0000003e  LBA 
		00004a28  0000040e  LL    0x4 (D 4)
		00004a2c  0000008d  BLTU  <fwd>
		00004a30  00210015  LG    0x2100 (D 8448)
		00004a34  00001454  ADDI  0x14 (D 20)
		00004a38  0000003e  LBA 
		00004a3c  00000523  LI    0x5 (D 5)
		00004a40  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1580 start=4753 end=4754>
	<code>  sched();</code>
	<emi>
		00004a44  00000005  JSR   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1581 start=4754 end=4758>
	<code>  panic("zombie exit");</code>
	<emi>
		00004a48  0002c308  LEAG  0x2c3 (D 707)
		00004a4c  0000009d  PSHA
		00004a50  ffbae005  JSR   0xffffbae0 (TO 0x534)
		00004a54  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1582 start=4758 end=4758>
	<code>}</code>
</stmt>
<stmt file=os.c line=1583 start=4758 end=4758>
	<code></code>
</stmt>
<stmt file=os.c line=1584 start=4758 end=4758>
	<code>// Kill the process with the given pid.  Process won't exit until it returns to user space (see trap()).</code>
</stmt>
<stmt file=os.c line=1585 start=4758 end=4759>
	<code>int kill(int pid)</code>
	<emi>
		00004a58  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1586 start=4759 end=4759>
	<code>{</code>
</stmt>
<stmt file=os.c line=1587 start=4759 end=4759>
	<code>  struct proc *p; int e = splhi();</code>
</stmt>
<stmt file=os.c line=1588 start=4759 end=4759>
	<code></code>
</stmt>
<stmt file=os.c line=1589 start=4759 end=4765>
	<code>  for (p = proc; p < &proc[NPROC]; p++) {</code>
	<emi>
		00004a5c  fffff801  ENT   0xfffffff8 (D -8)
		00004a60  ffb63c05  JSR   0xffffb63c (TO 0xa0)
		00004a64  00000040  SL    0x0 (D 0)
		00004a68  00000008  LEAG  0x0 (D 0)
		00004a6c  00000440  SL    0x4 (D 4)
		00004a70  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1590 start=4765 end=4769>
	<code>    if (p->pid == pid) {</code>
	<emi>
		00004a74  0000040e  LL    0x4 (D 4)
		00004a78  0000181c  LX    0x18 (D 24)
		00004a7c  00001026  LBL   0x10 (D 16)
		00004a80  0000008a  BNE   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1591 start=4769 end=4774>
	<code>      p->killed = 1;</code>
	<emi>
		00004a84  0000040e  LL    0x4 (D 4)
		00004a88  00002c54  ADDI  0x2c (D 44)
		00004a8c  0000003e  LBA 
		00004a90  00000123  LI    0x1 (D 1)
		00004a94  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1592 start=4774 end=4774>
	<code>      // wake process from sleep if necessary</code>
</stmt>
<stmt file=os.c line=1593 start=4774 end=4783>
	<code>      if (p->state == SLEEPING) p->state = RUNNABLE;</code>
	<emi>
		00004a98  0000040e  LL    0x4 (D 4)
		00004a9c  0000141c  LX    0x14 (D 20)
		00004aa0  0000023b  LBI   0x2 (D 2)
		00004aa4  0000008a  BNE   <fwd>
		00004aa8  0000040e  LL    0x4 (D 4)
		00004aac  00001454  ADDI  0x14 (D 20)
		00004ab0  0000003e  LBA 
		00004ab4  00000323  LI    0x3 (D 3)
		00004ab8  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1594 start=4783 end=4787>
	<code>      splx(e);</code>
	<emi>
		00004abc  0000000e  LL    0x0 (D 0)
		00004ac0  0000009d  PSHA
		00004ac4  ffb5e005  JSR   0xffffb5e0 (TO 0xa8)
		00004ac8  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1595 start=4787 end=4789>
	<code>      return 0;</code>
	<emi>
		00004acc  00000023  LI    0x0 (D 0)
		00004ad0  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1596 start=4789 end=4789>
	<code>    }</code>
</stmt>
<stmt file=os.c line=1597 start=4789 end=4789>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1598 start=4789 end=4800>
	<code>  splx(e);</code>
	<emi>
		00004ad4  0000040e  LL    0x4 (D 4)
		00004ad8  ffff7c57  SUBI  0xffffff7c (D -132)
		00004adc  00000440  SL    0x4 (D 4)
		00004ae0  00210008  LEAG  0x2100 (D 8448)
		00004ae4  0000003e  LBA 
		00004ae8  0000040e  LL    0x4 (D 4)
		00004aec  0000008d  BLTU  <fwd>
		00004af0  0000000e  LL    0x0 (D 0)
		00004af4  0000009d  PSHA
		00004af8  ffb5ac05  JSR   0xffffb5ac (TO 0xa8)
		00004afc  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1599 start=4800 end=4802>
	<code>  return -1;</code>
	<emi>
		00004b00  ffffff23  LI    0xffffffff (D -1)
		00004b04  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1600 start=4802 end=4802>
	<code>}</code>
</stmt>
<stmt file=os.c line=1601 start=4802 end=4802>
	<code></code>
</stmt>
<stmt file=os.c line=1602 start=4802 end=4802>
	<code>// Wait for a child process to exit and return its pid.  Return -1 if this process has no children.</code>
</stmt>
<stmt file=os.c line=1603 start=4802 end=4803>
	<code>int wait()</code>
	<emi>
		00004b08  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1604 start=4803 end=4803>
	<code>{</code>
</stmt>
<stmt file=os.c line=1605 start=4803 end=4803>
	<code>  struct proc *p;</code>
</stmt>
<stmt file=os.c line=1606 start=4803 end=4803>
	<code>  int havekids, pid, e = splhi();</code>
</stmt>
<stmt file=os.c line=1607 start=4803 end=4803>
	<code></code>
</stmt>
<stmt file=os.c line=1608 start=4803 end=4806>
	<code>  for (;;) { // scan through table looking for zombie children</code>
	<emi>
		00004b0c  fffff001  ENT   0xfffffff0 (D -16)
		00004b10  ffb58c05  JSR   0xffffb58c (TO 0xa0)
		00004b14  00000040  SL    0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=1609 start=4806 end=4808>
	<code>    havekids = 0;</code>
	<emi>
		00004b18  00000023  LI    0x0 (D 0)
		00004b1c  00000840  SL    0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1610 start=4808 end=4811>
	<code>    for (p = proc; p < &proc[NPROC]; p++) {</code>
	<emi>
		00004b20  00000008  LEAG  0x0 (D 0)
		00004b24  00000c40  SL    0xc (D 12)
		00004b28  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1611 start=4811 end=4816>
	<code>      if (p->parent != u) continue;</code>
	<emi>
		00004b2c  00000c0e  LL    0xc (D 12)
		00004b30  00001c1c  LX    0x1c (D 28)
		00004b34  0021002d  LBG   0x2100 (D 8448)
		00004b38  00000088  BE    <fwd>
		00004b3c  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1612 start=4816 end=4818>
	<code>      havekids = 1;</code>
	<emi>
		00004b40  00000123  LI    0x1 (D 1)
		00004b44  00000840  SL    0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1613 start=4818 end=4822>
	<code>      if (p->state == ZOMBIE) {</code>
	<emi>
		00004b48  00000c0e  LL    0xc (D 12)
		00004b4c  0000141c  LX    0x14 (D 20)
		00004b50  0000053b  LBI   0x5 (D 5)
		00004b54  0000008a  BNE   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1614 start=4822 end=4825>
	<code>        pid = p->pid;</code>
	<emi>
		00004b58  00000c0e  LL    0xc (D 12)
		00004b5c  0000181c  LX    0x18 (D 24)
		00004b60  00000440  SL    0x4 (D 4)
	</emi>
</stmt>
<stmt file=os.c line=1615 start=4825 end=4830>
	<code>        kfree(p->kstack);</code>
	<emi>
		00004b64  00000c0e  LL    0xc (D 12)
		00004b68  0000101c  LX    0x10 (D 16)
		00004b6c  0000009d  PSHA
		00004b70  ffb70405  JSR   0xffffb704 (TO 0x278)
		00004b74  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1616 start=4830 end=4835>
	<code>        p->kstack = 0;</code>
	<emi>
		00004b78  00000c0e  LL    0xc (D 12)
		00004b7c  00001054  ADDI  0x10 (D 16)
		00004b80  0000003e  LBA 
		00004b84  00000023  LI    0x0 (D 0)
		00004b88  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1617 start=4835 end=4840>
	<code>        freevm(p->pdir);</code>
	<emi>
		00004b8c  00000c0e  LL    0xc (D 12)
		00004b90  00000c1c  LX    0xc (D 12)
		00004b94  0000009d  PSHA
		00004b98  0046c805  JSR   <fwd>
		00004b9c  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1618 start=4840 end=4845>
	<code>        p->state = UNUSED;</code>
	<emi>
		00004ba0  00000c0e  LL    0xc (D 12)
		00004ba4  00001454  ADDI  0x14 (D 20)
		00004ba8  0000003e  LBA 
		00004bac  00000023  LI    0x0 (D 0)
		00004bb0  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1619 start=4845 end=4850>
	<code>        p->pid = 0;</code>
	<emi>
		00004bb4  00000c0e  LL    0xc (D 12)
		00004bb8  00001854  ADDI  0x18 (D 24)
		00004bbc  0000003e  LBA 
		00004bc0  00000023  LI    0x0 (D 0)
		00004bc4  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1620 start=4850 end=4855>
	<code>        p->parent = 0;</code>
	<emi>
		00004bc8  00000c0e  LL    0xc (D 12)
		00004bcc  00001c54  ADDI  0x1c (D 28)
		00004bd0  0000003e  LBA 
		00004bd4  00000023  LI    0x0 (D 0)
		00004bd8  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1621 start=4855 end=4860>
	<code>        p->name[0] = 0;</code>
	<emi>
		00004bdc  00000c0e  LL    0xc (D 12)
		00004be0  00007454  ADDI  0x74 (D 116)
		00004be4  0000003e  LBA 
		00004be8  00000023  LI    0x0 (D 0)
		00004bec  0000004c  SXB 
	</emi>
</stmt>
<stmt file=os.c line=1622 start=4860 end=4865>
	<code>        p->killed = 0;</code>
	<emi>
		00004bf0  00000c0e  LL    0xc (D 12)
		00004bf4  00002c54  ADDI  0x2c (D 44)
		00004bf8  0000003e  LBA 
		00004bfc  00000023  LI    0x0 (D 0)
		00004c00  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1623 start=4865 end=4869>
	<code>        splx(e);</code>
	<emi>
		00004c04  0000000e  LL    0x0 (D 0)
		00004c08  0000009d  PSHA
		00004c0c  ffb49805  JSR   0xffffb498 (TO 0xa8)
		00004c10  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1624 start=4869 end=4871>
	<code>        return pid;</code>
	<emi>
		00004c14  0000040e  LL    0x4 (D 4)
		00004c18  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1625 start=4871 end=4871>
	<code>      }</code>
</stmt>
<stmt file=os.c line=1626 start=4871 end=4871>
	<code>    }</code>
</stmt>
<stmt file=os.c line=1627 start=4871 end=4871>
	<code></code>
</stmt>
<stmt file=os.c line=1628 start=4871 end=4871>
	<code>    // no point waiting if we don't have any children</code>
</stmt>
<stmt file=os.c line=1629 start=4871 end=4883>
	<code>    if (!havekids || u->killed) {</code>
	<emi>
		00004c1c  00000c0e  LL    0xc (D 12)
		00004c20  ffff7c57  SUBI  0xffffff7c (D -132)
		00004c24  00000c40  SL    0xc (D 12)
		00004c28  00210008  LEAG  0x2100 (D 8448)
		00004c2c  0000003e  LBA 
		00004c30  00000c0e  LL    0xc (D 12)
		00004c34  0000008d  BLTU  <fwd>
		00004c38  0000080e  LL    0x8 (D 8)
		00004c3c  00000084  BZ    <fwd>
		00004c40  00210015  LG    0x2100 (D 8448)
		00004c44  00002c1c  LX    0x2c (D 44)
		00004c48  00000084  BZ    <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1630 start=4883 end=4887>
	<code>      splx(e);</code>
	<emi>
		00004c4c  0000000e  LL    0x0 (D 0)
		00004c50  0000009d  PSHA
		00004c54  ffb45005  JSR   0xffffb450 (TO 0xa8)
		00004c58  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1631 start=4887 end=4889>
	<code>      return -1;</code>
	<emi>
		00004c5c  ffffff23  LI    0xffffffff (D -1)
		00004c60  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1632 start=4889 end=4889>
	<code>    }</code>
</stmt>
<stmt file=os.c line=1633 start=4889 end=4889>
	<code></code>
</stmt>
<stmt file=os.c line=1634 start=4889 end=4889>
	<code>    // wait for children to exit.  (See wakeup call in exit.)</code>
</stmt>
<stmt file=os.c line=1635 start=4889 end=4893>
	<code>    sleep(u);  // XXX DOC: wait-sleep</code>
	<emi>
		00004c64  00210015  LG    0x2100 (D 8448)
		00004c68  0000009d  PSHA
		00004c6c  00252c05  JSR   <fwd>
		00004c70  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1636 start=4893 end=4893>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1637 start=4893 end=4894>
	<code>}</code>
	<emi>
		00004c74  fffea003  JMP   0xfffffea0 (TO 0x4b18)
	</emi>
</stmt>
<stmt file=os.c line=1638 start=4894 end=4894>
	<code></code>
</stmt>
<stmt file=os.c line=1639 start=4894 end=4894>
	<code>// grow process by n bytes             XXX need to verify that u->sz is always at a 4 byte alignment  !!!!!</code>
</stmt>
<stmt file=os.c line=1640 start=4894 end=4895>
	<code>int sbrk(int n)</code>
	<emi>
		00004c78  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1641 start=4895 end=4895>
	<code>{</code>
</stmt>
<stmt file=os.c line=1642 start=4895 end=4895>
	<code>  uint osz, sz;</code>
</stmt>
<stmt file=os.c line=1643 start=4895 end=4901>
	<code>  if (!n) return u->sz;</code>
	<emi>
		00004c7c  fffff801  ENT   0xfffffff8 (D -8)
		00004c80  0000100e  LL    0x10 (D 16)
		00004c84  00000086  BNZ   <fwd>
		00004c88  00210015  LG    0x2100 (D 8448)
		00004c8c  0000081c  LX    0x8 (D 8)
		00004c90  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1644 start=4901 end=4905>
	<code>  osz = sz = u->sz;</code>
	<emi>
		00004c94  00210015  LG    0x2100 (D 8448)
		00004c98  0000081c  LX    0x8 (D 8)
		00004c9c  00000040  SL    0x0 (D 0)
		00004ca0  00000440  SL    0x4 (D 4)
	</emi>
</stmt>
<stmt file=os.c line=1645 start=4905 end=4908>
	<code>  if (n > 0) {</code>
	<emi>
		00004ca4  00000023  LI    0x0 (D 0)
		00004ca8  00001026  LBL   0x10 (D 16)
		00004cac  0000008f  BGE   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1646 start=4908 end=4908>
	<code>//    printf("growproc(%d)\n",n);</code>
</stmt>
<stmt file=os.c line=1647 start=4908 end=4921>
	<code>    if (!(sz = allocuvm(u->pdir, sz, sz + n, 0))) {</code>
	<emi>
		00004cb0  0000009e  PSHI  0x0 (D 0)
		00004cb4  0000080e  LL    0x8 (D 8)
		00004cb8  00001855  ADDL  0x18 (D 24)
		00004cbc  0000009d  PSHA
		00004cc0  0000100e  LL    0x10 (D 16)
		00004cc4  0000009d  PSHA
		00004cc8  00210015  LG    0x2100 (D 8448)
		00004ccc  00000c1c  LX    0xc (D 12)
		00004cd0  0000009d  PSHA
		00004cd4  00435405  JSR   <fwd>
		00004cd8  00002001  ENT   0x20 (D 32)
		00004cdc  00000040  SL    0x0 (D 0)
		00004ce0  00000086  BNZ   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1648 start=4921 end=4925>
	<code>      printf("bad growproc!!\n"); //XXX</code>
	<emi>
		00004ce4  0002cf08  LEAG  0x2cf (D 719)
		00004ce8  0000009d  PSHA
		00004cec  ffb6c805  JSR   0xffffb6c8 (TO 0x3b8)
		00004cf0  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1649 start=4925 end=4927>
	<code>      return -1;</code>
	<emi>
		00004cf4  ffffff23  LI    0xffffffff (D -1)
		00004cf8  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1650 start=4927 end=4927>
	<code>    }</code>
</stmt>
<stmt file=os.c line=1651 start=4927 end=4928>
	<code>  } else {</code>
	<emi>
		00004cfc  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1652 start=4928 end=4928>
	<code>//    printf("shrinkproc(%d)\n",n);</code>
</stmt>
<stmt file=os.c line=1653 start=4928 end=4928>
	<code>//    if (sz + n < KRESERVED)</code>
</stmt>
<stmt file=os.c line=1654 start=4928 end=4933>
	<code>    if ((uint)(-n) > sz) { //XXX</code>
	<emi>
		00004d00  0000100e  LL    0x10 (D 16)
		00004d04  ffffff5a  MULI  0xffffffff (D -1)
		00004d08  0000003e  LBA 
		00004d0c  0000000e  LL    0x0 (D 0)
		00004d10  00000090  BGEU  <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1655 start=4933 end=4937>
	<code>      printf("bad shrinkproc!!\n"); //XXX</code>
	<emi>
		00004d14  0002df08  LEAG  0x2df (D 735)
		00004d18  0000009d  PSHA
		00004d1c  ffb69805  JSR   0xffffb698 (TO 0x3b8)
		00004d20  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1656 start=4937 end=4939>
	<code>      return -1;</code>
	<emi>
		00004d24  ffffff23  LI    0xffffffff (D -1)
		00004d28  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1657 start=4939 end=4939>
	<code>    }</code>
</stmt>
<stmt file=os.c line=1658 start=4939 end=4953>
	<code>    if (!(sz = deallocuvm(u->pdir, sz, sz + n))) return -1;</code>
	<emi>
		00004d2c  0000000e  LL    0x0 (D 0)
		00004d30  00001055  ADDL  0x10 (D 16)
		00004d34  0000009d  PSHA
		00004d38  0000080e  LL    0x8 (D 8)
		00004d3c  0000009d  PSHA
		00004d40  00210015  LG    0x2100 (D 8448)
		00004d44  00000c1c  LX    0xc (D 12)
		00004d48  0000009d  PSHA
		00004d4c  00000005  JSR   <fwd>
		00004d50  00001801  ENT   0x18 (D 24)
		00004d54  00000040  SL    0x0 (D 0)
		00004d58  00000086  BNZ   <fwd>
		00004d5c  ffffff23  LI    0xffffffff (D -1)
		00004d60  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1659 start=4953 end=4961>
	<code>    pdir(V2P+(uint)(u->pdir));</code>
	<emi>
		00004d64  00210015  LG    0x2100 (D 8448)
		00004d68  00000c1c  LX    0xc (D 12)
		00004d6c  0000403b  LBI   0x40 (D 64)
		00004d70  0000003c  LBHI  0x0 (D 0)
		00004d74  00000053  ADD 
		00004d78  0000009d  PSHA
		00004d7c  ffb30805  JSR   0xffffb308 (TO 0x88)
		00004d80  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1660 start=4961 end=4961>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1661 start=4961 end=4966>
	<code>  u->sz = sz;</code>
	<emi>
		00004d84  00210015  LG    0x2100 (D 8448)
		00004d88  00000854  ADDI  0x8 (D 8)
		00004d8c  0000003e  LBA 
		00004d90  0000000e  LL    0x0 (D 0)
		00004d94  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1662 start=4966 end=4966>
	<code>//  pdir(V2P+(u->pdir));</code>
</stmt>
<stmt file=os.c line=1663 start=4966 end=4968>
	<code>  return osz;</code>
	<emi>
		00004d98  0000040e  LL    0x4 (D 4)
		00004d9c  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1664 start=4968 end=4968>
	<code>}</code>
</stmt>
<stmt file=os.c line=1665 start=4968 end=4968>
	<code></code>
</stmt>
<stmt file=os.c line=1666 start=4968 end=4969>
	<code>int ssleep(int n)</code>
	<emi>
		00004da0  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1667 start=4969 end=4969>
	<code>{</code>
</stmt>
<stmt file=os.c line=1668 start=4969 end=4969>
	<code>  uint ticks0; int e = splhi();</code>
</stmt>
<stmt file=os.c line=1669 start=4969 end=4969>
	<code></code>
</stmt>
<stmt file=os.c line=1670 start=4969 end=4974>
	<code>  ticks0 = ticks;</code>
	<emi>
		00004da4  fffff801  ENT   0xfffffff8 (D -8)
		00004da8  ffb2f405  JSR   0xffffb2f4 (TO 0xa0)
		00004dac  00000040  SL    0x0 (D 0)
		00004db0  00216c15  LG    0x216c (D 8556)
		00004db4  00000440  SL    0x4 (D 4)
	</emi>
</stmt>
<stmt file=os.c line=1671 start=4974 end=4975>
	<code>  while (ticks - ticks0 < n) {</code>
	<emi>
		00004db8  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1672 start=4975 end=4978>
	<code>    if (u->killed) {</code>
	<emi>
		00004dbc  00210015  LG    0x2100 (D 8448)
		00004dc0  00002c1c  LX    0x2c (D 44)
		00004dc4  00000084  BZ    <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1673 start=4978 end=4982>
	<code>      splx(e);</code>
	<emi>
		00004dc8  0000000e  LL    0x0 (D 0)
		00004dcc  0000009d  PSHA
		00004dd0  ffb2d405  JSR   0xffffb2d4 (TO 0xa8)
		00004dd4  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1674 start=4982 end=4984>
	<code>      return -1;</code>
	<emi>
		00004dd8  ffffff23  LI    0xffffffff (D -1)
		00004ddc  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1675 start=4984 end=4984>
	<code>    }</code>
</stmt>
<stmt file=os.c line=1676 start=4984 end=4988>
	<code>    sleep(&ticks);</code>
	<emi>
		00004de0  00216c08  LEAG  0x216c (D 8556)
		00004de4  0000009d  PSHA
		00004de8  004c6c05  JSR   <fwd>
		00004dec  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1677 start=4988 end=4988>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1678 start=4988 end=4996>
	<code>  splx(e);</code>
	<emi>
		00004df0  00216c15  LG    0x216c (D 8556)
		00004df4  00000458  SUBL  0x4 (D 4)
		00004df8  00001026  LBL   0x10 (D 16)
		00004dfc  0000008d  BLTU  <fwd>
		00004e00  0000000e  LL    0x0 (D 0)
		00004e04  0000009d  PSHA
		00004e08  ffb29c05  JSR   0xffffb29c (TO 0xa8)
		00004e0c  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1679 start=4996 end=4998>
	<code>  return 0;</code>
	<emi>
		00004e10  00000023  LI    0x0 (D 0)
		00004e14  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1680 start=4998 end=4998>
	<code>}</code>
</stmt>
<stmt file=os.c line=1681 start=4998 end=4998>
	<code></code>
</stmt>
<stmt file=os.c line=1682 start=4998 end=4998>
	<code>// XXX HACK CODE (and all wrong) to bootstrap initial network functionality</code>
</stmt>
<stmt file=os.c line=1683 start=4998 end=4999>
	<code>enum { POLLIN = 1, POLLOUT = 2, POLLNVAL = 4 };</code>
	<emi>
		00004e18  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1684 start=4999 end=4999>
	<code>struct pollfd { int fd; short events, revents; };</code>
</stmt>
<stmt file=os.c line=1685 start=4999 end=4999>
	<code></code>
</stmt>
<stmt file=os.c line=1686 start=4999 end=4999>
	<code>int socket(int family, int type, int protocol)</code>
</stmt>
<stmt file=os.c line=1687 start=4999 end=4999>
	<code>{</code>
</stmt>
<stmt file=os.c line=1688 start=4999 end=4999>
	<code>  int fd, sd;</code>
</stmt>
<stmt file=os.c line=1689 start=4999 end=4999>
	<code>  struct file *f;</code>
</stmt>
<stmt file=os.c line=1690 start=4999 end=4999>
	<code></code>
</stmt>
<stmt file=os.c line=1691 start=4999 end=4999>
	<code>//  printf("socket(family=%d, type=%d, protocol=%d)\n", family, type, protocol);</code>
</stmt>
<stmt file=os.c line=1692 start=4999 end=5011>
	<code>  if (family != 2 || type != 1 || protocol != 0) return -1;</code>
	<emi>
		00004e1c  fffff001  ENT   0xfffffff0 (D -16)
		00004e20  0000180e  LL    0x18 (D 24)
		00004e24  0000023b  LBI   0x2 (D 2)
		00004e28  0000008a  BNE   <fwd>
		00004e2c  0000200e  LL    0x20 (D 32)
		00004e30  0000013b  LBI   0x1 (D 1)
		00004e34  004e288a  BNE   <fwd>
		00004e38  0000280e  LL    0x28 (D 40)
		00004e3c  0000003b  LBI   0x0 (D 0)
		00004e40  00000088  BE    <fwd>
		00004e44  ffffff23  LI    0xffffffff (D -1)
		00004e48  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1693 start=5011 end=5011>
	<code></code>
</stmt>
<stmt file=os.c line=1694 start=5011 end=5021>
	<code>  if (!(f = filealloc()) || (fd = fdalloc(f)) < 0) {</code>
	<emi>
		00004e4c  ffd7bc05  JSR   0xffffd7bc (TO 0x260c)
		00004e50  00000440  SL    0x4 (D 4)
		00004e54  00000084  BZ    <fwd>
		00004e58  0000040e  LL    0x4 (D 4)
		00004e5c  0000009d  PSHA
		00004e60  ffd89005  JSR   0xffffd890 (TO 0x26f4)
		00004e64  00000801  ENT   0x8 (D 8)
		00004e68  00000c40  SL    0xc (D 12)
		00004e6c  0000003b  LBI   0x0 (D 0)
		00004e70  0000008f  BGE   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1695 start=5021 end=5027>
	<code>    if (f) fileclose(f);</code>
	<emi>
		00004e74  0000040e  LL    0x4 (D 4)
		00004e78  00000084  BZ    <fwd>
		00004e7c  0000040e  LL    0x4 (D 4)
		00004e80  0000009d  PSHA
		00004e84  ffddac05  JSR   0xffffddac (TO 0x2c34)
		00004e88  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1696 start=5027 end=5029>
	<code>    return -1;</code>
	<emi>
		00004e8c  ffffff23  LI    0xffffffff (D -1)
		00004e90  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1697 start=5029 end=5029>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1698 start=5029 end=5029>
	<code></code>
</stmt>
<stmt file=os.c line=1699 start=5029 end=5056>
	<code>  if ((sd = sockopen(family, type, protocol)) < 0) { u->ofile[fd] = 0; fileclose(f); return sd; }</code>
	<emi>
		00004e94  0000280e  LL    0x28 (D 40)
		00004e98  0000009d  PSHA
		00004e9c  0000280e  LL    0x28 (D 40)
		00004ea0  0000009d  PSHA
		00004ea4  0000280e  LL    0x28 (D 40)
		00004ea8  0000009d  PSHA
		00004eac  ffdc0805  JSR   0xffffdc08 (TO 0x2ab8)
		00004eb0  00001801  ENT   0x18 (D 24)
		00004eb4  00000840  SL    0x8 (D 8)
		00004eb8  0000003b  LBI   0x0 (D 0)
		00004ebc  0000008f  BGE   <fwd>
		00004ec0  00210015  LG    0x2100 (D 8448)
		00004ec4  00003054  ADDI  0x30 (D 48)
		00004ec8  0000009d  PSHA
		00004ecc  0000140e  LL    0x14 (D 20)
		00004ed0  0000045a  MULI  0x4 (D 4)
		00004ed4  000000a1  POPB
		00004ed8  00000053  ADD 
		00004edc  0000003e  LBA 
		00004ee0  00000023  LI    0x0 (D 0)
		00004ee4  0000004a  SX  
		00004ee8  0000040e  LL    0x4 (D 4)
		00004eec  0000009d  PSHA
		00004ef0  ffdd4005  JSR   0xffffdd40 (TO 0x2c34)
		00004ef4  00000801  ENT   0x8 (D 8)
		00004ef8  0000080e  LL    0x8 (D 8)
		00004efc  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1700 start=5056 end=5056>
	<code></code>
</stmt>
<stmt file=os.c line=1701 start=5056 end=5059>
	<code>  f->type = FD_SOCKET;</code>
	<emi>
		00004f00  00000323  LI    0x3 (D 3)
		00004f04  00000426  LBL   0x4 (D 4)
		00004f08  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1702 start=5059 end=5071>
	<code>  f->readable = f->writable = 1;</code>
	<emi>
		00004f0c  0000040e  LL    0x4 (D 4)
		00004f10  00000854  ADDI  0x8 (D 8)
		00004f14  0000009d  PSHA
		00004f18  00000c0e  LL    0xc (D 12)
		00004f1c  00000954  ADDI  0x9 (D 9)
		00004f20  0000003e  LBA 
		00004f24  00000123  LI    0x1 (D 1)
		00004f28  0000004c  SXB 
		00004f2c  00001872  SHLI  0x18 (D 24)
		00004f30  00001875  SHRI  0x18 (D 24)
		00004f34  000000a1  POPB
		00004f38  0000004c  SXB 
	</emi>
</stmt>
<stmt file=os.c line=1703 start=5071 end=5076>
	<code>  f->off = sd;</code>
	<emi>
		00004f3c  0000040e  LL    0x4 (D 4)
		00004f40  00001454  ADDI  0x14 (D 20)
		00004f44  0000003e  LBA 
		00004f48  0000080e  LL    0x8 (D 8)
		00004f4c  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1704 start=5076 end=5078>
	<code>  return fd;</code>
	<emi>
		00004f50  00000c0e  LL    0xc (D 12)
		00004f54  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1705 start=5078 end=5078>
	<code>}</code>
</stmt>
<stmt file=os.c line=1706 start=5078 end=5078>
	<code></code>
</stmt>
<stmt file=os.c line=1707 start=5078 end=5079>
	<code>int poll(struct pollfd *pfd, uint n, int msec)</code>
	<emi>
		00004f58  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1708 start=5079 end=5079>
	<code>{</code>
</stmt>
<stmt file=os.c line=1709 start=5079 end=5079>
	<code>  int r, ev; struct file *f; struct pollfd *p, *pn;</code>
</stmt>
<stmt file=os.c line=1710 start=5079 end=5092>
	<code>  if (n && !mvalid(pfd, n * sizeof(struct pollfd))) return -1;</code>
	<emi>
		00004f5c  ffffe801  ENT   0xffffffe8 (D -24)
		00004f60  0000280e  LL    0x28 (D 40)
		00004f64  00000084  BZ    <fwd>
		00004f68  0000280e  LL    0x28 (D 40)
		00004f6c  0000085a  MULI  0x8 (D 8)
		00004f70  0000009d  PSHA
		00004f74  0000280e  LL    0x28 (D 40)
		00004f78  0000009d  PSHA
		00004f7c  ffdabc05  JSR   0xffffdabc (TO 0x2a3c)
		00004f80  00001001  ENT   0x10 (D 16)
		00004f84  004f6486  BNZ   <fwd>
		00004f88  ffffff23  LI    0xffffffff (D -1)
		00004f8c  00001802  LEV   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=1711 start=5092 end=5096>
	<code>  pn = &pfd[n];</code>
	<emi>
		00004f90  0000280e  LL    0x28 (D 40)
		00004f94  0000085a  MULI  0x8 (D 8)
		00004f98  00002055  ADDL  0x20 (D 32)
		00004f9c  00000440  SL    0x4 (D 4)
	</emi>
</stmt>
<stmt file=os.c line=1712 start=5096 end=5096>
	<code>  for (;;)</code>
</stmt>
<stmt file=os.c line=1713 start=5096 end=5096>
	<code>  {</code>
</stmt>
<stmt file=os.c line=1714 start=5096 end=5098>
	<code>    r = 0;</code>
	<emi>
		00004fa0  00000023  LI    0x0 (D 0)
		00004fa4  00001440  SL    0x14 (D 20)
	</emi>
</stmt>
<stmt file=os.c line=1715 start=5098 end=5100>
	<code>    for (p = pfd; p != pn; p++)</code>
	<emi>
		00004fa8  0000200e  LL    0x20 (D 32)
		00004fac  00000840  SL    0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1716 start=5100 end=5101>
	<code>    {</code>
	<emi>
		00004fb0  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1717 start=5101 end=5106>
	<code>      if (p->fd < 0) continue;</code>
	<emi>
		00004fb4  0000080e  LL    0x8 (D 8)
		00004fb8  0000001c  LX  
		00004fbc  0000003b  LBI   0x0 (D 0)
		00004fc0  0000008f  BGE   <fwd>
		00004fc4  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1718 start=5106 end=5108>
	<code>      ev = 0;</code>
	<emi>
		00004fc8  00000023  LI    0x0 (D 0)
		00004fcc  00001040  SL    0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1719 start=5108 end=5117>
	<code>      if (!(f = getf(p->fd))) ev = POLLNVAL;</code>
	<emi>
		00004fd0  0000080e  LL    0x8 (D 8)
		00004fd4  0000001c  LX  
		00004fd8  0000009d  PSHA
		00004fdc  ffda9c05  JSR   0xffffda9c (TO 0x2a7c)
		00004fe0  00000801  ENT   0x8 (D 8)
		00004fe4  00000c40  SL    0xc (D 12)
		00004fe8  00000086  BNZ   <fwd>
		00004fec  00000423  LI    0x4 (D 4)
		00004ff0  00001040  SL    0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1720 start=5117 end=5122>
	<code>      else if (p->events & POLLIN) {</code>
	<emi>
		00004ff4  00000003  JMP   <fwd>
		00004ff8  0000080e  LL    0x8 (D 8)
		00004ffc  0000041d  LXS   0x4 (D 4)
		00005000  00000169  ANDI  0x1 (D 1)
		00005004  00000084  BZ    <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1721 start=5122 end=5125>
	<code>        switch (f->type) {</code>
	<emi>
		00005008  00000c0e  LL    0xc (D 12)
		0000500c  0000001c  LX  
		00005010  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1722 start=5125 end=5141>
	<code>        case FD_PIPE: if (f->pipe->nwrite != f->pipe->nread || !f->pipe->writeopen) ev = POLLIN; break;</code>
	<emi>
		00005014  00000c0e  LL    0xc (D 12)
		00005018  00000c1c  LX    0xc (D 12)
		0000501c  000fa01c  LX    0xfa0 (D 4000)
		00005020  0000009d  PSHA
		00005024  0000140e  LL    0x14 (D 20)
		00005028  00000c1c  LX    0xc (D 12)
		0000502c  000fa41c  LX    0xfa4 (D 4004)
		00005030  000000a1  POPB
		00005034  0000008a  BNE   <fwd>
		00005038  00000c0e  LL    0xc (D 12)
		0000503c  00000c1c  LX    0xc (D 12)
		00005040  000fac1c  LX    0xfac (D 4012)
		00005044  00000086  BNZ   <fwd>
		00005048  00000123  LI    0x1 (D 1)
		0000504c  00001040  SL    0x10 (D 16)
		00005050  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1723 start=5141 end=5150>
	<code>        case FD_SOCKET: if (sockpoll(f->off)) ev = POLLIN; break;</code>
	<emi>
		00005054  00000c0e  LL    0xc (D 12)
		00005058  0000141c  LX    0x14 (D 20)
		0000505c  0000009d  PSHA
		00005060  ffdab005  JSR   0xffffdab0 (TO 0x2b14)
		00005064  00000801  ENT   0x8 (D 8)
		00005068  00000084  BZ    <fwd>
		0000506c  00000123  LI    0x1 (D 1)
		00005070  00001040  SL    0x10 (D 16)
		00005074  00505003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1724 start=5150 end=5150>
	<code>        case FD_INODE:</code>
</stmt>
<stmt file=os.c line=1725 start=5150 end=5161>
	<code>          if ((f->ip->mode & S_IFMT) == S_IFCHR && f->ip->dir[0] == CONSOLE) {</code>
	<emi>
		00005078  00000c0e  LL    0xc (D 12)
		0000507c  0000101c  LX    0x10 (D 16)
		00005080  00000c1e  LXH   0xc (D 12)
		00005084  00f00069  ANDI  0xf000 (D 61440)
		00005088  0020003b  LBI   0x2000 (D 8192)
		0000508c  0000008a  BNE   <fwd>
		00005090  00000c0e  LL    0xc (D 12)
		00005094  0000101c  LX    0x10 (D 16)
		00005098  0000181c  LX    0x18 (D 24)
		0000509c  0000013b  LBI   0x1 (D 1)
		000050a0  00508c8a  BNE   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1726 start=5161 end=5166>
	<code>            ilock(f->ip);</code>
	<emi>
		000050a4  00000c0e  LL    0xc (D 12)
		000050a8  0000101c  LX    0x10 (D 16)
		000050ac  0000009d  PSHA
		000050b0  ffc0f405  JSR   0xffffc0f4 (TO 0x11a8)
		000050b4  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1727 start=5166 end=5171>
	<code>            if (input.r != input.w) ev = POLLIN;</code>
	<emi>
		000050b8  0021f415  LG    0x21f4 (D 8692)
		000050bc  0021f82d  LBG   0x21f8 (D 8696)
		000050c0  00000088  BE    <fwd>
		000050c4  00000123  LI    0x1 (D 1)
		000050c8  00001040  SL    0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1728 start=5171 end=5176>
	<code>            iunlock(f->ip);</code>
	<emi>
		000050cc  00000c0e  LL    0xc (D 12)
		000050d0  0000101c  LX    0x10 (D 16)
		000050d4  0000009d  PSHA
		000050d8  ffc26405  JSR   0xffffc264 (TO 0x1340)
		000050dc  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1729 start=5176 end=5176>
	<code>          }</code>
</stmt>
<stmt file=os.c line=1730 start=5176 end=5176>
	<code>        }</code>
</stmt>
<stmt file=os.c line=1731 start=5176 end=5180>
	<code>      }</code>
	<emi>
		000050e0  00507403  JMP   <fwd>
		000050e4  0000043b  LBI   0x4 (D 4)
		000050e8  0050e090  BGEU  <fwd>
		000050ec  0002f404  JMPI  0x2f4 (D 756)
	</emi>
</stmt>
<stmt file=os.c line=1732 start=5180 end=5193>
	<code>      if (p->revents = ev) { msec = 0; r++; }</code>
	<emi>
		000050f0  0000080e  LL    0x8 (D 8)
		000050f4  00000654  ADDI  0x6 (D 6)
		000050f8  0000003e  LBA 
		000050fc  0000100e  LL    0x10 (D 16)
		00005100  0000004b  SXH 
		00005104  00001072  SHLI  0x10 (D 16)
		00005108  00001075  SHRI  0x10 (D 16)
		0000510c  00000084  BZ    <fwd>
		00005110  00000023  LI    0x0 (D 0)
		00005114  00003040  SL    0x30 (D 48)
		00005118  0000140e  LL    0x14 (D 20)
		0000511c  ffffff57  SUBI  0xffffffff (D -1)
		00005120  00001440  SL    0x14 (D 20)
	</emi>
</stmt>
<stmt file=os.c line=1733 start=5193 end=5193>
	<code>    }</code>
</stmt>
<stmt file=os.c line=1734 start=5193 end=5202>
	<code>    if (!msec) break;</code>
	<emi>
		00005124  0000080e  LL    0x8 (D 8)
		00005128  fffff857  SUBI  0xfffffff8 (D -8)
		0000512c  00000840  SL    0x8 (D 8)
		00005130  0000080e  LL    0x8 (D 8)
		00005134  00000426  LBL   0x4 (D 4)
		00005138  0000008a  BNE   <fwd>
		0000513c  0000300e  LL    0x30 (D 48)
		00005140  00000086  BNZ   <fwd>
		00005144  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1735 start=5202 end=5205>
	<code>    ssleep(1);</code>
	<emi>
		00005148  0000019e  PSHI  0x1 (D 1)
		0000514c  fffc5405  JSR   0xfffffc54 (TO 0x4da4)
		00005150  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1736 start=5205 end=5211>
	<code>    if (msec > 100) msec -= 100; // XXX this wrongly assumes one tick equals 100ms</code>
	<emi>
		00005154  00006423  LI    0x64 (D 100)
		00005158  00003026  LBL   0x30 (D 48)
		0000515c  0000008f  BGE   <fwd>
		00005160  0000300e  LL    0x30 (D 48)
		00005164  00006457  SUBI  0x64 (D 100)
		00005168  00003040  SL    0x30 (D 48)
	</emi>
</stmt>
<stmt file=os.c line=1737 start=5211 end=5217>
	<code>    else if (msec > 0) msec = 0;</code>
	<emi>
		0000516c  00000003  JMP   <fwd>
		00005170  00000023  LI    0x0 (D 0)
		00005174  00003026  LBL   0x30 (D 48)
		00005178  0000008f  BGE   <fwd>
		0000517c  00000023  LI    0x0 (D 0)
		00005180  00003040  SL    0x30 (D 48)
	</emi>
</stmt>
<stmt file=os.c line=1738 start=5217 end=5217>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1739 start=5217 end=5220>
	<code>  return r;</code>
	<emi>
		00005184  fffe1803  JMP   0xfffffe18 (TO 0x4fa0)
		00005188  0000140e  LL    0x14 (D 20)
		0000518c  00001802  LEV   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=1740 start=5220 end=5220>
	<code>}</code>
</stmt>
<stmt file=os.c line=1741 start=5220 end=5220>
	<code>// XXX int connect(struct file *s, struct sockaddr *name, uint namelen)</code>
</stmt>
<stmt file=os.c line=1742 start=5220 end=5221>
	<code>int connect(int fd, uint *addr, int addrlen)</code>
	<emi>
		00005190  00001802  LEV   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=1743 start=5221 end=5221>
	<code>{</code>
</stmt>
<stmt file=os.c line=1744 start=5221 end=5221>
	<code>  struct file *f;</code>
</stmt>
<stmt file=os.c line=1745 start=5221 end=5240>
	<code>  if (!(f = getf(fd)) || addrlen < 8 || !mvalid(addr, addrlen)) return -1;</code>
	<emi>
		00005194  fffff801  ENT   0xfffffff8 (D -8)
		00005198  0000100e  LL    0x10 (D 16)
		0000519c  0000009d  PSHA
		000051a0  ffd8d805  JSR   0xffffd8d8 (TO 0x2a7c)
		000051a4  00000801  ENT   0x8 (D 8)
		000051a8  00000440  SL    0x4 (D 4)
		000051ac  00000084  BZ    <fwd>
		000051b0  0000200e  LL    0x20 (D 32)
		000051b4  0000083b  LBI   0x8 (D 8)
		000051b8  0051ac8c  BLT   <fwd>
		000051bc  0000200e  LL    0x20 (D 32)
		000051c0  0000009d  PSHA
		000051c4  0000200e  LL    0x20 (D 32)
		000051c8  0000009d  PSHA
		000051cc  ffd86c05  JSR   0xffffd86c (TO 0x2a3c)
		000051d0  00001001  ENT   0x10 (D 16)
		000051d4  00000086  BNZ   <fwd>
		000051d8  ffffff23  LI    0xffffffff (D -1)
		000051dc  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1746 start=5240 end=5252>
	<code>  return sockconnect(f->off, addr[0], addr[1]);</code>
	<emi>
		000051e0  0000180e  LL    0x18 (D 24)
		000051e4  0000041c  LX    0x4 (D 4)
		000051e8  0000009d  PSHA
		000051ec  0000200e  LL    0x20 (D 32)
		000051f0  0000001c  LX  
		000051f4  0000009d  PSHA
		000051f8  0000140e  LL    0x14 (D 20)
		000051fc  0000141c  LX    0x14 (D 20)
		00005200  0000009d  PSHA
		00005204  ffd8d005  JSR   0xffffd8d0 (TO 0x2ad8)
		00005208  00001801  ENT   0x18 (D 24)
		0000520c  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1747 start=5252 end=5252>
	<code>}</code>
</stmt>
<stmt file=os.c line=1748 start=5252 end=5252>
	<code></code>
</stmt>
<stmt file=os.c line=1749 start=5252 end=5257>
	<code>int sockbind(int fd, uint family_port, uint addr) { asm(LL,8); asm(LBL,16); asm(LCL,24); asm(NET7); }</code>
	<emi>
		00005210  00000802  LEV   0x8 (D 8)
		00005214  0000080e  LL    0x8 (D 8)
		00005218  00001026  LBL   0x10 (D 16)
		0000521c  000018ac  LCL   0x18 (D 24)
		00005220  000000b9  NET7
	</emi>
</stmt>
<stmt file=os.c line=1750 start=5257 end=5258>
	<code>int bind(int fd, uint *addr, int addrlen)</code>
	<emi>
		00005224  00000002  LEV   0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=1751 start=5258 end=5258>
	<code>{</code>
</stmt>
<stmt file=os.c line=1752 start=5258 end=5258>
	<code>  struct file *f;</code>
</stmt>
<stmt file=os.c line=1753 start=5258 end=5277>
	<code>  if (!(f = getf(fd)) || addrlen < 8 || !mvalid(addr, addrlen)) return -1;</code>
	<emi>
		00005228  fffff801  ENT   0xfffffff8 (D -8)
		0000522c  0000100e  LL    0x10 (D 16)
		00005230  0000009d  PSHA
		00005234  ffd84405  JSR   0xffffd844 (TO 0x2a7c)
		00005238  00000801  ENT   0x8 (D 8)
		0000523c  00000440  SL    0x4 (D 4)
		00005240  00000084  BZ    <fwd>
		00005244  0000200e  LL    0x20 (D 32)
		00005248  0000083b  LBI   0x8 (D 8)
		0000524c  0052408c  BLT   <fwd>
		00005250  0000200e  LL    0x20 (D 32)
		00005254  0000009d  PSHA
		00005258  0000200e  LL    0x20 (D 32)
		0000525c  0000009d  PSHA
		00005260  ffd7d805  JSR   0xffffd7d8 (TO 0x2a3c)
		00005264  00001001  ENT   0x10 (D 16)
		00005268  00000086  BNZ   <fwd>
		0000526c  ffffff23  LI    0xffffffff (D -1)
		00005270  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1754 start=5277 end=5289>
	<code>  return sockbind(f->off, addr[0], addr[1]);</code>
	<emi>
		00005274  0000180e  LL    0x18 (D 24)
		00005278  0000041c  LX    0x4 (D 4)
		0000527c  0000009d  PSHA
		00005280  0000200e  LL    0x20 (D 32)
		00005284  0000001c  LX  
		00005288  0000009d  PSHA
		0000528c  0000140e  LL    0x14 (D 20)
		00005290  0000141c  LX    0x14 (D 20)
		00005294  0000009d  PSHA
		00005298  ffff7805  JSR   0xffffff78 (TO 0x5214)
		0000529c  00001801  ENT   0x18 (D 24)
		000052a0  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1755 start=5289 end=5289>
	<code>}</code>
</stmt>
<stmt file=os.c line=1756 start=5289 end=5293>
	<code>int socklisten() { asm(LL,8); asm(LBL,16); asm(NET8); }</code>
	<emi>
		000052a4  00000802  LEV   0x8 (D 8)
		000052a8  0000080e  LL    0x8 (D 8)
		000052ac  00001026  LBL   0x10 (D 16)
		000052b0  000000ba  NET8
	</emi>
</stmt>
<stmt file=os.c line=1757 start=5293 end=5294>
	<code>int listen(int fd, int len)</code>
	<emi>
		000052b4  00000002  LEV   0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=1758 start=5294 end=5294>
	<code>{</code>
</stmt>
<stmt file=os.c line=1759 start=5294 end=5294>
	<code>  struct file *f;</code>
</stmt>
<stmt file=os.c line=1760 start=5294 end=5303>
	<code>  if (!(f = getf(fd))) return -1;</code>
	<emi>
		000052b8  fffff801  ENT   0xfffffff8 (D -8)
		000052bc  0000100e  LL    0x10 (D 16)
		000052c0  0000009d  PSHA
		000052c4  ffd7b405  JSR   0xffffd7b4 (TO 0x2a7c)
		000052c8  00000801  ENT   0x8 (D 8)
		000052cc  00000440  SL    0x4 (D 4)
		000052d0  00000086  BNZ   <fwd>
		000052d4  ffffff23  LI    0xffffffff (D -1)
		000052d8  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1761 start=5303 end=5311>
	<code>  return socklisten(f->off, len);</code>
	<emi>
		000052dc  0000180e  LL    0x18 (D 24)
		000052e0  0000009d  PSHA
		000052e4  00000c0e  LL    0xc (D 12)
		000052e8  0000141c  LX    0x14 (D 20)
		000052ec  0000009d  PSHA
		000052f0  ffffb405  JSR   0xffffffb4 (TO 0x52a8)
		000052f4  00001001  ENT   0x10 (D 16)
		000052f8  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1762 start=5311 end=5311>
	<code>}</code>
</stmt>
<stmt file=os.c line=1763 start=5311 end=5316>
	<code>int sockaccept() { asm(LL,8); asm(LBL,16); asm(LCL,24); asm(NET9); }</code>
	<emi>
		000052fc  00000802  LEV   0x8 (D 8)
		00005300  0000080e  LL    0x8 (D 8)
		00005304  00001026  LBL   0x10 (D 16)
		00005308  000018ac  LCL   0x18 (D 24)
		0000530c  000000bb  NET9
	</emi>
</stmt>
<stmt file=os.c line=1764 start=5316 end=5317>
	<code>int accept(int fd, uint *addr, int *addrlen) // XXXX params!!!! accept(int,*|0,*|0)</code>
	<emi>
		00005310  00000002  LEV   0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=1765 start=5317 end=5317>
	<code>{</code>
</stmt>
<stmt file=os.c line=1766 start=5317 end=5317>
	<code>  int sd;</code>
</stmt>
<stmt file=os.c line=1767 start=5317 end=5317>
	<code>  struct file *f;</code>
</stmt>
<stmt file=os.c line=1768 start=5317 end=5326>
	<code>  if (!(f = getf(fd))) return -1;</code>
	<emi>
		00005314  fffff801  ENT   0xfffffff8 (D -8)
		00005318  0000100e  LL    0x10 (D 16)
		0000531c  0000009d  PSHA
		00005320  ffd75805  JSR   0xffffd758 (TO 0x2a7c)
		00005324  00000801  ENT   0x8 (D 8)
		00005328  00000040  SL    0x0 (D 0)
		0000532c  00000086  BNZ   <fwd>
		00005330  ffffff23  LI    0xffffffff (D -1)
		00005334  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1769 start=5326 end=5326>
	<code>  </code>
</stmt>
<stmt file=os.c line=1770 start=5326 end=5330>
	<code>  while (!sockpoll(f->off)) ssleep(1); // XXX</code>
	<emi>
		00005338  00000003  JMP   <fwd>
		0000533c  0000019e  PSHI  0x1 (D 1)
		00005340  fffa6005  JSR   0xfffffa60 (TO 0x4da4)
		00005344  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1771 start=5330 end=5330>
	<code></code>
</stmt>
<stmt file=os.c line=1772 start=5330 end=5348>
	<code>  if ((sd = sockaccept(f->off, 0, 0)) < 0) return sd; // XXX null params for now</code>
	<emi>
		00005348  0000000e  LL    0x0 (D 0)
		0000534c  0000141c  LX    0x14 (D 20)
		00005350  0000009d  PSHA
		00005354  ffd7bc05  JSR   0xffffd7bc (TO 0x2b14)
		00005358  00000801  ENT   0x8 (D 8)
		0000535c  00000084  BZ    <fwd>
		00005360  0000009e  PSHI  0x0 (D 0)
		00005364  0000009e  PSHI  0x0 (D 0)
		00005368  0000100e  LL    0x10 (D 16)
		0000536c  0000141c  LX    0x14 (D 20)
		00005370  0000009d  PSHA
		00005374  ffff8805  JSR   0xffffff88 (TO 0x5300)
		00005378  00001801  ENT   0x18 (D 24)
		0000537c  00000440  SL    0x4 (D 4)
		00005380  0000003b  LBI   0x0 (D 0)
		00005384  0000008f  BGE   <fwd>
		00005388  0000040e  LL    0x4 (D 4)
		0000538c  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1773 start=5348 end=5348>
	<code>  </code>
</stmt>
<stmt file=os.c line=1774 start=5348 end=5358>
	<code>  if (!(f = filealloc()) || (fd = fdalloc(f)) < 0) { // XXX do this before sockaccept?</code>
	<emi>
		00005390  ffd27805  JSR   0xffffd278 (TO 0x260c)
		00005394  00000040  SL    0x0 (D 0)
		00005398  00000084  BZ    <fwd>
		0000539c  0000000e  LL    0x0 (D 0)
		000053a0  0000009d  PSHA
		000053a4  ffd34c05  JSR   0xffffd34c (TO 0x26f4)
		000053a8  00000801  ENT   0x8 (D 8)
		000053ac  00001040  SL    0x10 (D 16)
		000053b0  0000003b  LBI   0x0 (D 0)
		000053b4  0000008f  BGE   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1775 start=5358 end=5364>
	<code>    if (f) fileclose(f);</code>
	<emi>
		000053b8  0000000e  LL    0x0 (D 0)
		000053bc  00000084  BZ    <fwd>
		000053c0  0000000e  LL    0x0 (D 0)
		000053c4  0000009d  PSHA
		000053c8  ffd86805  JSR   0xffffd868 (TO 0x2c34)
		000053cc  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1776 start=5364 end=5366>
	<code>    return -1;</code>
	<emi>
		000053d0  ffffff23  LI    0xffffffff (D -1)
		000053d4  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1777 start=5366 end=5366>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1778 start=5366 end=5366>
	<code></code>
</stmt>
<stmt file=os.c line=1779 start=5366 end=5369>
	<code>  f->type = FD_SOCKET;</code>
	<emi>
		000053d8  00000323  LI    0x3 (D 3)
		000053dc  00000026  LBL   0x0 (D 0)
		000053e0  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1780 start=5369 end=5381>
	<code>  f->readable = f->writable = 1;</code>
	<emi>
		000053e4  0000000e  LL    0x0 (D 0)
		000053e8  00000854  ADDI  0x8 (D 8)
		000053ec  0000009d  PSHA
		000053f0  0000080e  LL    0x8 (D 8)
		000053f4  00000954  ADDI  0x9 (D 9)
		000053f8  0000003e  LBA 
		000053fc  00000123  LI    0x1 (D 1)
		00005400  0000004c  SXB 
		00005404  00001872  SHLI  0x18 (D 24)
		00005408  00001875  SHRI  0x18 (D 24)
		0000540c  000000a1  POPB
		00005410  0000004c  SXB 
	</emi>
</stmt>
<stmt file=os.c line=1781 start=5381 end=5386>
	<code>  f->off = sd;</code>
	<emi>
		00005414  0000000e  LL    0x0 (D 0)
		00005418  00001454  ADDI  0x14 (D 20)
		0000541c  0000003e  LBA 
		00005420  0000040e  LL    0x4 (D 4)
		00005424  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1782 start=5386 end=5388>
	<code>  return fd;</code>
	<emi>
		00005428  0000100e  LL    0x10 (D 16)
		0000542c  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1783 start=5388 end=5388>
	<code>}</code>
</stmt>
<stmt file=os.c line=1784 start=5388 end=5388>
	<code></code>
</stmt>
<stmt file=os.c line=1785 start=5388 end=5388>
	<code>// *** end of syscalls ***</code>
</stmt>
<stmt file=os.c line=1786 start=5388 end=5388>
	<code></code>
</stmt>
<stmt file=os.c line=1787 start=5388 end=5388>
	<code>// sleep on channel</code>
</stmt>
<stmt file=os.c line=1788 start=5388 end=5389>
	<code>sleep(void *chan)</code>
	<emi>
		00005430  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1789 start=5389 end=5389>
	<code>{</code>
</stmt>
<stmt file=os.c line=1790 start=5389 end=5394>
	<code>  u->chan = chan;</code>
	<emi>
		00005434  00210015  LG    0x2100 (D 8448)
		00005438  00002854  ADDI  0x28 (D 40)
		0000543c  0000003e  LBA 
		00005440  0000080e  LL    0x8 (D 8)
		00005444  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1791 start=5394 end=5399>
	<code>  u->state = SLEEPING;</code>
	<emi>
		00005448  00210015  LG    0x2100 (D 8448)
		0000544c  00001454  ADDI  0x14 (D 20)
		00005450  0000003e  LBA 
		00005454  00000223  LI    0x2 (D 2)
		00005458  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1792 start=5399 end=5400>
	<code>  sched();</code>
	<emi>
		0000545c  004a4405  JSR   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1793 start=5400 end=5400>
	<code>  // tidy up</code>
</stmt>
<stmt file=os.c line=1794 start=5400 end=5405>
	<code>  u->chan = 0;</code>
	<emi>
		00005460  00210015  LG    0x2100 (D 8448)
		00005464  00002854  ADDI  0x28 (D 40)
		00005468  0000003e  LBA 
		0000546c  00000023  LI    0x0 (D 0)
		00005470  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1795 start=5405 end=5405>
	<code>}</code>
</stmt>
<stmt file=os.c line=1796 start=5405 end=5405>
	<code></code>
</stmt>
<stmt file=os.c line=1797 start=5405 end=5405>
	<code>// wake up all processes sleeping on chan</code>
</stmt>
<stmt file=os.c line=1798 start=5405 end=5406>
	<code>wakeup(void *chan)</code>
	<emi>
		00005474  00000002  LEV   0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=1799 start=5406 end=5406>
	<code>{</code>
</stmt>
<stmt file=os.c line=1800 start=5406 end=5406>
	<code>  struct proc *p;</code>
</stmt>
<stmt file=os.c line=1801 start=5406 end=5409>
	<code>  for (p = proc; p < &proc[NPROC]; p++)</code>
	<emi>
		00005478  fffff801  ENT   0xfffffff8 (D -8)
		0000547c  00000008  LEAG  0x0 (D 0)
		00005480  00000440  SL    0x4 (D 4)
	</emi>
</stmt>
<stmt file=os.c line=1802 start=5409 end=5423>
	<code>    if (p->state == SLEEPING && p->chan == chan) p->state = RUNNABLE;</code>
	<emi>
		00005484  00000003  JMP   <fwd>
		00005488  0000040e  LL    0x4 (D 4)
		0000548c  0000141c  LX    0x14 (D 20)
		00005490  0000023b  LBI   0x2 (D 2)
		00005494  0000008a  BNE   <fwd>
		00005498  0000040e  LL    0x4 (D 4)
		0000549c  0000281c  LX    0x28 (D 40)
		000054a0  00001026  LBL   0x10 (D 16)
		000054a4  0054948a  BNE   <fwd>
		000054a8  0000040e  LL    0x4 (D 4)
		000054ac  00001454  ADDI  0x14 (D 20)
		000054b0  0000003e  LBA 
		000054b4  00000323  LI    0x3 (D 3)
		000054b8  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1803 start=5423 end=5430>
	<code>}</code>
	<emi>
		000054bc  0000040e  LL    0x4 (D 4)
		000054c0  ffff7c57  SUBI  0xffffff7c (D -132)
		000054c4  00000440  SL    0x4 (D 4)
		000054c8  00210008  LEAG  0x2100 (D 8448)
		000054cc  0000003e  LBA 
		000054d0  0000040e  LL    0x4 (D 4)
		000054d4  0000008d  BLTU  <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1804 start=5430 end=5430>
	<code></code>
</stmt>
<stmt file=os.c line=1805 start=5430 end=5430>
	<code>// a forked child's very first scheduling will swtch here</code>
</stmt>
<stmt file=os.c line=1806 start=5430 end=5431>
	<code>forkret()</code>
	<emi>
		000054d8  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1807 start=5431 end=5431>
	<code>{</code>
</stmt>
<stmt file=os.c line=1808 start=5431 end=5433>
	<code>  asm(POPA); asm(SUSP);</code>
	<emi>
		000054dc  000000a3  POPA
		000054e0  000000ab  SUSP
	</emi>
</stmt>
<stmt file=os.c line=1809 start=5433 end=5434>
	<code>  asm(POPG);</code>
	<emi>
		000054e4  000000b2  POPG
	</emi>
</stmt>
<stmt file=os.c line=1810 start=5434 end=5435>
	<code>  asm(POPF);</code>
	<emi>
		000054e8  000000a2  POPF
	</emi>
</stmt>
<stmt file=os.c line=1811 start=5435 end=5436>
	<code>  asm(POPC);</code>
	<emi>
		000054ec  000000af  POPC
	</emi>
</stmt>
<stmt file=os.c line=1812 start=5436 end=5437>
	<code>  asm(POPB);</code>
	<emi>
		000054f0  000000a1  POPB
	</emi>
</stmt>
<stmt file=os.c line=1813 start=5437 end=5438>
	<code>  asm(POPA);</code>
	<emi>
		000054f4  000000a3  POPA
	</emi>
</stmt>
<stmt file=os.c line=1814 start=5438 end=5439>
	<code>  asm(RTI);</code>
	<emi>
		000054f8  00000098  RTI 
	</emi>
</stmt>
<stmt file=os.c line=1815 start=5439 end=5439>
	<code>}</code>
</stmt>
<stmt file=os.c line=1816 start=5439 end=5439>
	<code></code>
</stmt>
<stmt file=os.c line=1817 start=5439 end=5439>
	<code>// Look in the process table for an UNUSED proc.  If found, change state to EMBRYO and initialize</code>
</stmt>
<stmt file=os.c line=1818 start=5439 end=5439>
	<code>// state required to run in the kernel.  Otherwise return 0.</code>
</stmt>
<stmt file=os.c line=1819 start=5439 end=5440>
	<code>struct proc *allocproc()</code>
	<emi>
		000054fc  00000002  LEV   0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=1820 start=5440 end=5440>
	<code>{</code>
</stmt>
<stmt file=os.c line=1821 start=5440 end=5440>
	<code>  struct proc *p; char *sp; int e = splhi();</code>
</stmt>
<stmt file=os.c line=1822 start=5440 end=5440>
	<code></code>
</stmt>
<stmt file=os.c line=1823 start=5440 end=5445>
	<code>  for (p = proc; p < &proc[NPROC]; p++)</code>
	<emi>
		00005500  fffff001  ENT   0xfffffff0 (D -16)
		00005504  ffab9805  JSR   0xffffab98 (TO 0xa0)
		00005508  00000440  SL    0x4 (D 4)
		0000550c  00000008  LEAG  0x0 (D 0)
		00005510  00000c40  SL    0xc (D 12)
	</emi>
</stmt>
<stmt file=os.c line=1824 start=5445 end=5451>
	<code>    if (p->state == UNUSED) goto found;</code>
	<emi>
		00005514  00000003  JMP   <fwd>
		00005518  00000c0e  LL    0xc (D 12)
		0000551c  0000141c  LX    0x14 (D 20)
		00005520  0000003b  LBI   0x0 (D 0)
		00005524  0000008a  BNE   <fwd>
		00005528  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1825 start=5451 end=5462>
	<code>  splx(e);</code>
	<emi>
		0000552c  00000c0e  LL    0xc (D 12)
		00005530  ffff7c57  SUBI  0xffffff7c (D -132)
		00005534  00000c40  SL    0xc (D 12)
		00005538  00210008  LEAG  0x2100 (D 8448)
		0000553c  0000003e  LBA 
		00005540  00000c0e  LL    0xc (D 12)
		00005544  0000008d  BLTU  <fwd>
		00005548  0000040e  LL    0x4 (D 4)
		0000554c  0000009d  PSHA
		00005550  ffab5405  JSR   0xffffab54 (TO 0xa8)
		00005554  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1826 start=5462 end=5464>
	<code>  return 0;</code>
	<emi>
		00005558  00000023  LI    0x0 (D 0)
		0000555c  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1827 start=5464 end=5464>
	<code></code>
</stmt>
<stmt file=os.c line=1828 start=5464 end=5464>
	<code>found:</code>
</stmt>
<stmt file=os.c line=1829 start=5464 end=5469>
	<code>  p->state = EMBRYO;</code>
	<emi>
		00005560  00000c0e  LL    0xc (D 12)
		00005564  00001454  ADDI  0x14 (D 20)
		00005568  0000003e  LBA 
		0000556c  00000123  LI    0x1 (D 1)
		00005570  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1830 start=5469 end=5478>
	<code>  p->pid = nextpid++;</code>
	<emi>
		00005574  00000c0e  LL    0xc (D 12)
		00005578  00001854  ADDI  0x18 (D 24)
		0000557c  0000009d  PSHA
		00005580  0337e815  LG    0x337e8 (D 210920)
		00005584  ffffff57  SUBI  0xffffffff (D -1)
		00005588  0337e845  SG    0x337e8 (D 210920)
		0000558c  ffffff54  ADDI  0xffffffff (D -1)
		00005590  000000a1  POPB
		00005594  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1831 start=5478 end=5482>
	<code>  splx(e);</code>
	<emi>
		00005598  0000040e  LL    0x4 (D 4)
		0000559c  0000009d  PSHA
		000055a0  ffab0405  JSR   0xffffab04 (TO 0xa8)
		000055a4  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1832 start=5482 end=5482>
	<code></code>
</stmt>
<stmt file=os.c line=1833 start=5482 end=5482>
	<code>  // allocate kernel stack leaving room for trap frame</code>
</stmt>
<stmt file=os.c line=1834 start=5482 end=5491>
	<code>  sp = (p->kstack = kalloc()) + PAGE - sizeof(struct trapframe);</code>
	<emi>
		000055a8  00000c0e  LL    0xc (D 12)
		000055ac  00001054  ADDI  0x10 (D 16)
		000055b0  0000009d  PSHA
		000055b4  ffac3405  JSR   0xffffac34 (TO 0x1ec)
		000055b8  000000a1  POPB
		000055bc  0000004a  SX  
		000055c0  00100054  ADDI  0x1000 (D 4096)
		000055c4  ffffc054  ADDI  0xffffffc0 (D -64)
		000055c8  00000840  SL    0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1835 start=5491 end=5496>
	<code>  p->tf = (struct trapframe *)sp;</code>
	<emi>
		000055cc  00000c0e  LL    0xc (D 12)
		000055d0  00002054  ADDI  0x20 (D 32)
		000055d4  0000003e  LBA 
		000055d8  0000080e  LL    0x8 (D 8)
		000055dc  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1836 start=5496 end=5496>
	<code>  </code>
</stmt>
<stmt file=os.c line=1837 start=5496 end=5496>
	<code>  // set up new context to start executing at forkret</code>
</stmt>
<stmt file=os.c line=1838 start=5496 end=5499>
	<code>  sp -= 8;</code>
	<emi>
		000055e0  0000080e  LL    0x8 (D 8)
		000055e4  00000857  SUBI  0x8 (D 8)
		000055e8  00000840  SL    0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1839 start=5499 end=5502>
	<code>  *(uint *)sp = (uint)forkret;</code>
	<emi>
		000055ec  fffeec08  LEAG  0xfffffeec (D -276)
		000055f0  00000826  LBL   0x8 (D 8)
		000055f4  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1840 start=5502 end=5502>
	<code></code>
</stmt>
<stmt file=os.c line=1841 start=5502 end=5507>
	<code>  p->context = sp;</code>
	<emi>
		000055f8  00000c0e  LL    0xc (D 12)
		000055fc  00002454  ADDI  0x24 (D 36)
		00005600  0000003e  LBA 
		00005604  0000080e  LL    0x8 (D 8)
		00005608  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1842 start=5507 end=5509>
	<code>  return p;</code>
	<emi>
		0000560c  00000c0e  LL    0xc (D 12)
		00005610  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1843 start=5509 end=5509>
	<code>}</code>
</stmt>
<stmt file=os.c line=1844 start=5509 end=5509>
	<code></code>
</stmt>
<stmt file=os.c line=1845 start=5509 end=5509>
	<code>// hand-craft the first process</code>
</stmt>
<stmt file=os.c line=1846 start=5509 end=5510>
	<code>init_start()</code>
	<emi>
		00005614  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1847 start=5510 end=5510>
	<code>{</code>
</stmt>
<stmt file=os.c line=1848 start=5510 end=5510>
	<code>  char cmd[10], *argv[2];</code>
</stmt>
<stmt file=os.c line=1849 start=5510 end=5510>
	<code>  </code>
</stmt>
<stmt file=os.c line=1850 start=5510 end=5510>
	<code>  // no data/bss segment</code>
</stmt>
<stmt file=os.c line=1851 start=5510 end=5521>
	<code>  cmd[0] = '/'; cmd[1] = 'e'; cmd[2] = 't'; cmd[3] = 'c'; cmd[4] = '/';</code>
	<emi>
		00005618  ffffe801  ENT   0xffffffe8 (D -24)
		0000561c  00002f23  LI    0x2f (D 47)
		00005620  00000e42  SLB   0xe (D 14)
		00005624  00006523  LI    0x65 (D 101)
		00005628  00000f42  SLB   0xf (D 15)
		0000562c  00007423  LI    0x74 (D 116)
		00005630  00001042  SLB   0x10 (D 16)
		00005634  00006323  LI    0x63 (D 99)
		00005638  00001142  SLB   0x11 (D 17)
		0000563c  00002f23  LI    0x2f (D 47)
		00005640  00001242  SLB   0x12 (D 18)
	</emi>
</stmt>
<stmt file=os.c line=1852 start=5521 end=5531>
	<code>  cmd[5] = 'i'; cmd[6] = 'n'; cmd[7] = 'i'; cmd[8] = 't'; cmd[9] = 0;</code>
	<emi>
		00005644  00006923  LI    0x69 (D 105)
		00005648  00001342  SLB   0x13 (D 19)
		0000564c  00006e23  LI    0x6e (D 110)
		00005650  00001442  SLB   0x14 (D 20)
		00005654  00006923  LI    0x69 (D 105)
		00005658  00001542  SLB   0x15 (D 21)
		0000565c  00007423  LI    0x74 (D 116)
		00005660  00001642  SLB   0x16 (D 22)
		00005664  00000023  LI    0x0 (D 0)
		00005668  00001742  SLB   0x17 (D 23)
	</emi>
</stmt>
<stmt file=os.c line=1853 start=5531 end=5531>
	<code>  </code>
</stmt>
<stmt file=os.c line=1854 start=5531 end=5533>
	<code>  argv[0] = cmd;</code>
	<emi>
		0000566c  00000e07  LEA   0xe (D 14)
		00005670  00000440  SL    0x4 (D 4)
	</emi>
</stmt>
<stmt file=os.c line=1855 start=5533 end=5535>
	<code>  argv[1] = 0;</code>
	<emi>
		00005674  00000023  LI    0x0 (D 0)
		00005678  00000840  SL    0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1856 start=5535 end=5535>
	<code></code>
</stmt>
<stmt file=os.c line=1857 start=5535 end=5543>
	<code>  if (!init_fork()) init_exec(cmd, argv);</code>
	<emi>
		0000567c  00000005  JSR   <fwd>
		00005680  00000086  BNZ   <fwd>
		00005684  00000407  LEA   0x4 (D 4)
		00005688  0000009d  PSHA
		0000568c  00001607  LEA   0x16 (D 22)
		00005690  0000009d  PSHA
		00005694  00000005  JSR   <fwd>
		00005698  00001001  ENT   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1858 start=5543 end=5546>
	<code>  init_exit(0); // become the idle task</code>
	<emi>
		0000569c  0000009e  PSHI  0x0 (D 0)
		000056a0  00000005  JSR   <fwd>
		000056a4  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1859 start=5546 end=5546>
	<code>}</code>
</stmt>
<stmt file=os.c line=1860 start=5546 end=5548>
	<code>init_fork() { asm(TRAP,S_fork); }</code>
	<emi>
		000056a8  00001802  LEV   0x18 (D 24)
		000056ac  000001a9  TRAP  0x1 (D 1)
	</emi>
</stmt>
<stmt file=os.c line=1861 start=5548 end=5552>
	<code>init_exec() { asm(LL,8); asm(LBL,16); asm(TRAP,S_exec); }</code>
	<emi>
		000056b0  00000002  LEV   0x0 (D 0)
		000056b4  0000080e  LL    0x8 (D 8)
		000056b8  00001026  LBL   0x10 (D 16)
		000056bc  000009a9  TRAP  0x9 (D 9)
	</emi>
</stmt>
<stmt file=os.c line=1862 start=5552 end=5555>
	<code>init_exit() { asm(LL,8); asm(TRAP,S_exit); }</code>
	<emi>
		000056c0  00000002  LEV   0x0 (D 0)
		000056c4  0000080e  LL    0x8 (D 8)
		000056c8  000002a9  TRAP  0x2 (D 2)
	</emi>
</stmt>
<stmt file=os.c line=1863 start=5555 end=5555>
	<code></code>
</stmt>
<stmt file=os.c line=1864 start=5555 end=5556>
	<code>userinit()</code>
	<emi>
		000056cc  00000002  LEV   0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=1865 start=5556 end=5556>
	<code>{</code>
</stmt>
<stmt file=os.c line=1866 start=5556 end=5556>
	<code>  char *mem;</code>
</stmt>
<stmt file=os.c line=1867 start=5556 end=5559>
	<code>  init = allocproc();</code>
	<emi>
		000056d0  fffff801  ENT   0xfffffff8 (D -8)
		000056d4  fffe2805  JSR   0xfffffe28 (TO 0x5500)
		000056d8  00210445  SG    0x2104 (D 8452)
	</emi>
</stmt>
<stmt file=os.c line=1868 start=5559 end=5571>
	<code>  init->pdir = memcpy(kalloc(), kpdir, PAGE);</code>
	<emi>
		000056dc  00210415  LG    0x2104 (D 8452)
		000056e0  00000c54  ADDI  0xc (D 12)
		000056e4  0000009d  PSHA
		000056e8  0010009e  PSHI  0x1000 (D 4096)
		000056ec  00216815  LG    0x2168 (D 8552)
		000056f0  0000009d  PSHA
		000056f4  ffaaf405  JSR   0xffffaaf4 (TO 0x1ec)
		000056f8  0000009d  PSHA
		000056fc  ffa90005  JSR   0xffffa900 (TO 0x0)
		00005700  00001801  ENT   0x18 (D 24)
		00005704  000000a1  POPB
		00005708  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1869 start=5571 end=5589>
	<code>  mem = memcpy(memset(kalloc(), 0, PAGE), (char *)init_start, (uint)userinit - (uint)init_start);</code>
	<emi>
		0000570c  ffff0808  LEAG  0xffffff08 (D -248)
		00005710  0000009d  PSHA
		00005714  ffffb808  LEAG  0xffffffb8 (D -72)
		00005718  000000a1  POPB
		0000571c  00000056  SUB 
		00005720  0000009d  PSHA
		00005724  fffef008  LEAG  0xfffffef0 (D -272)
		00005728  0000009d  PSHA
		0000572c  0010009e  PSHI  0x1000 (D 4096)
		00005730  0000009e  PSHI  0x0 (D 0)
		00005734  ffaab405  JSR   0xffffaab4 (TO 0x1ec)
		00005738  0000009d  PSHA
		0000573c  ffa8d805  JSR   0xffffa8d8 (TO 0x18)
		00005740  00001801  ENT   0x18 (D 24)
		00005744  0000009d  PSHA
		00005748  ffa8b405  JSR   0xffffa8b4 (TO 0x0)
		0000574c  00001801  ENT   0x18 (D 24)
		00005750  00000440  SL    0x4 (D 4)
	</emi>
</stmt>
<stmt file=os.c line=1870 start=5589 end=5601>
	<code>  mappage(init->pdir, 0, V2P+mem, PTE_P | PTE_W | PTE_U);</code>
	<emi>
		00005754  0000079e  PSHI  0x7 (D 7)
		00005758  00000c0e  LL    0xc (D 12)
		0000575c  0000403b  LBI   0x40 (D 64)
		00005760  0000003c  LBHI  0x0 (D 0)
		00005764  00000053  ADD 
		00005768  0000009d  PSHA
		0000576c  0000009e  PSHI  0x0 (D 0)
		00005770  00210415  LG    0x2104 (D 8452)
		00005774  00000c1c  LX    0xc (D 12)
		00005778  0000009d  PSHA
		0000577c  0043b405  JSR   <fwd>
		00005780  00002001  ENT   0x20 (D 32)
	</emi>
</stmt>
<stmt file=os.c line=1871 start=5601 end=5601>
	<code></code>
</stmt>
<stmt file=os.c line=1872 start=5601 end=5606>
	<code>  init->sz = PAGE;</code>
	<emi>
		00005784  00210415  LG    0x2104 (D 8452)
		00005788  00000854  ADDI  0x8 (D 8)
		0000578c  0000003e  LBA 
		00005790  00100023  LI    0x1000 (D 4096)
		00005794  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1873 start=5606 end=5611>
	<code>  init->tf->sp = PAGE;</code>
	<emi>
		00005798  00210415  LG    0x2104 (D 8452)
		0000579c  0000201c  LX    0x20 (D 32)
		000057a0  0000003e  LBA 
		000057a4  00100023  LI    0x1000 (D 4096)
		000057a8  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1874 start=5611 end=5617>
	<code>  init->tf->fc = USER;</code>
	<emi>
		000057ac  00210415  LG    0x2104 (D 8452)
		000057b0  0000201c  LX    0x20 (D 32)
		000057b4  00003054  ADDI  0x30 (D 48)
		000057b8  0000003e  LBA 
		000057bc  00001023  LI    0x10 (D 16)
		000057c0  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1875 start=5617 end=5623>
	<code>  init->tf->pc = 0;</code>
	<emi>
		000057c4  00210415  LG    0x2104 (D 8452)
		000057c8  0000201c  LX    0x20 (D 32)
		000057cc  00003854  ADDI  0x38 (D 56)
		000057d0  0000003e  LBA 
		000057d4  00000023  LI    0x0 (D 0)
		000057d8  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1876 start=5623 end=5631>
	<code>  safestrcpy(init->name, "initcode", sizeof(init->name));</code>
	<emi>
		000057dc  0000109e  PSHI  0x10 (D 16)
		000057e0  00030408  LEAG  0x304 (D 772)
		000057e4  0000009d  PSHA
		000057e8  00210415  LG    0x2104 (D 8452)
		000057ec  00007454  ADDI  0x74 (D 116)
		000057f0  0000009d  PSHA
		000057f4  ffa98005  JSR   0xffffa980 (TO 0x178)
		000057f8  00001801  ENT   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=1877 start=5631 end=5640>
	<code>  init->cwd = namei("/");</code>
	<emi>
		000057fc  00210415  LG    0x2104 (D 8452)
		00005800  00007054  ADDI  0x70 (D 112)
		00005804  0000009d  PSHA
		00005808  00030d08  LEAG  0x30d (D 781)
		0000580c  0000009d  PSHA
		00005810  ffc90005  JSR   0xffffc900 (TO 0x2114)
		00005814  00000801  ENT   0x8 (D 8)
		00005818  000000a1  POPB
		0000581c  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1878 start=5640 end=5645>
	<code>  init->state = RUNNABLE;</code>
	<emi>
		00005820  00210415  LG    0x2104 (D 8452)
		00005824  00001454  ADDI  0x14 (D 20)
		00005828  0000003e  LBA 
		0000582c  00000323  LI    0x3 (D 3)
		00005830  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1879 start=5645 end=5645>
	<code>}</code>
</stmt>
<stmt file=os.c line=1880 start=5645 end=5645>
	<code></code>
</stmt>
<stmt file=os.c line=1881 start=5645 end=5645>
	<code>// set up kernel page table</code>
</stmt>
<stmt file=os.c line=1882 start=5645 end=5646>
	<code>setupkvm()</code>
	<emi>
		00005834  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1883 start=5646 end=5646>
	<code>{</code>
</stmt>
<stmt file=os.c line=1884 start=5646 end=5646>
	<code>  uint i, *pde, *pt;</code>
</stmt>
<stmt file=os.c line=1885 start=5646 end=5646>
	<code></code>
</stmt>
<stmt file=os.c line=1886 start=5646 end=5654>
	<code>  kpdir = memset(kalloc(), 0, PAGE); // kalloc returns physical addresses here (kfree wont work until later on)</code>
	<emi>
		00005838  fffff001  ENT   0xfffffff0 (D -16)
		0000583c  0010009e  PSHI  0x1000 (D 4096)
		00005840  0000009e  PSHI  0x0 (D 0)
		00005844  ffa9a405  JSR   0xffffa9a4 (TO 0x1ec)
		00005848  0000009d  PSHA
		0000584c  ffa7c805  JSR   0xffffa7c8 (TO 0x18)
		00005850  00001801  ENT   0x18 (D 24)
		00005854  00216845  SG    0x2168 (D 8552)
	</emi>
</stmt>
<stmt file=os.c line=1887 start=5654 end=5654>
	<code></code>
</stmt>
<stmt file=os.c line=1888 start=5654 end=5657>
	<code>  for (i=0; i<mem_sz; i += PAGE) {</code>
	<emi>
		00005858  00000023  LI    0x0 (D 0)
		0000585c  00000c40  SL    0xc (D 12)
		00005860  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1889 start=5657 end=5666>
	<code>    pde = &kpdir[(P2V+i) >> 22];</code>
	<emi>
		00005864  00000c0e  LL    0xc (D 12)
		00005868  ffffc03b  LBI   0xffffffc0 (D -64)
		0000586c  0000003c  LBHI  0x0 (D 0)
		00005870  00000053  ADD 
		00005874  00001678  SRUI  0x16 (D 22)
		00005878  0000045a  MULI  0x4 (D 4)
		0000587c  0021682d  LBG   0x2168 (D 8552)
		00005880  00000053  ADD 
		00005884  00000840  SL    0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1890 start=5666 end=5670>
	<code>    if (*pde & PTE_P)</code>
	<emi>
		00005888  0000080e  LL    0x8 (D 8)
		0000588c  0000001c  LX  
		00005890  00000169  ANDI  0x1 (D 1)
		00005894  00000084  BZ    <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1891 start=5670 end=5674>
	<code>      pt = *pde & -PAGE;</code>
	<emi>
		00005898  0000080e  LL    0x8 (D 8)
		0000589c  0000001c  LX  
		000058a0  fff00069  ANDI  0xfffff000 (D -4096)
		000058a4  00000440  SL    0x4 (D 4)
	</emi>
</stmt>
<stmt file=os.c line=1892 start=5674 end=5674>
	<code>    else</code>
</stmt>
<stmt file=os.c line=1893 start=5674 end=5686>
	<code>      *pde = (uint)(pt = memset(kalloc(), 0, PAGE)) | PTE_P | PTE_W;</code>
	<emi>
		000058a8  00000003  JMP   <fwd>
		000058ac  0010009e  PSHI  0x1000 (D 4096)
		000058b0  0000009e  PSHI  0x0 (D 0)
		000058b4  ffa93405  JSR   0xffffa934 (TO 0x1ec)
		000058b8  0000009d  PSHA
		000058bc  ffa75805  JSR   0xffffa758 (TO 0x18)
		000058c0  00001801  ENT   0x18 (D 24)
		000058c4  00000440  SL    0x4 (D 4)
		000058c8  0000016c  ORI   0x1 (D 1)
		000058cc  0000026c  ORI   0x2 (D 2)
		000058d0  00000826  LBL   0x8 (D 8)
		000058d4  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1894 start=5686 end=5700>
	<code>    pt[((P2V+i) >> 12) & 0x3ff] = i | PTE_P | PTE_W;</code>
	<emi>
		000058d8  00000c0e  LL    0xc (D 12)
		000058dc  ffffc03b  LBI   0xffffffc0 (D -64)
		000058e0  0000003c  LBHI  0x0 (D 0)
		000058e4  00000053  ADD 
		000058e8  00000c78  SRUI  0xc (D 12)
		000058ec  0003ff69  ANDI  0x3ff (D 1023)
		000058f0  0000045a  MULI  0x4 (D 4)
		000058f4  00000455  ADDL  0x4 (D 4)
		000058f8  0000009d  PSHA
		000058fc  0000140e  LL    0x14 (D 20)
		00005900  0000016c  ORI   0x1 (D 1)
		00005904  0000026c  ORI   0x2 (D 2)
		00005908  000000a1  POPB
		0000590c  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1895 start=5700 end=5700>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1896 start=5700 end=5706>
	<code>}</code>
	<emi>
		00005910  00000c0e  LL    0xc (D 12)
		00005914  00100054  ADDI  0x1000 (D 4096)
		00005918  00000c40  SL    0xc (D 12)
		0000591c  00000c0e  LL    0xc (D 12)
		00005920  0021102d  LBG   0x2110 (D 8464)
		00005924  0000008d  BLTU  <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1897 start=5706 end=5706>
	<code></code>
</stmt>
<stmt file=os.c line=1898 start=5706 end=5706>
	<code>// return the address of the PTE in page table pd that corresponds to virtual address va</code>
</stmt>
<stmt file=os.c line=1899 start=5706 end=5707>
	<code>uint *walkpdir(uint *pd, uint va)</code>
	<emi>
		00005928  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1900 start=5707 end=5707>
	<code>{</code>
</stmt>
<stmt file=os.c line=1901 start=5707 end=5707>
	<code>  uint *pde = &pd[va >> 22], *pt;</code>
</stmt>
<stmt file=os.c line=1902 start=5707 end=5707>
	<code></code>
</stmt>
<stmt file=os.c line=1903 start=5707 end=5719>
	<code>  if (!(*pde & PTE_P)) return 0;</code>
	<emi>
		0000592c  fffff801  ENT   0xfffffff8 (D -8)
		00005930  0000180e  LL    0x18 (D 24)
		00005934  00001678  SRUI  0x16 (D 22)
		00005938  0000045a  MULI  0x4 (D 4)
		0000593c  00001055  ADDL  0x10 (D 16)
		00005940  00000440  SL    0x4 (D 4)
		00005944  0000040e  LL    0x4 (D 4)
		00005948  0000001c  LX  
		0000594c  00000169  ANDI  0x1 (D 1)
		00005950  00000086  BNZ   <fwd>
		00005954  00000023  LI    0x0 (D 0)
		00005958  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1904 start=5719 end=5726>
	<code>  pt = P2V+(*pde & -PAGE);</code>
	<emi>
		0000595c  0000040e  LL    0x4 (D 4)
		00005960  0000001c  LX  
		00005964  fff00069  ANDI  0xfffff000 (D -4096)
		00005968  ffffc03b  LBI   0xffffffc0 (D -64)
		0000596c  0000003c  LBHI  0x0 (D 0)
		00005970  00000053  ADD 
		00005974  00000040  SL    0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=1905 start=5726 end=5732>
	<code>  return &pt[(va >> 12) & 0x3ff];</code>
	<emi>
		00005978  0000180e  LL    0x18 (D 24)
		0000597c  00000c78  SRUI  0xc (D 12)
		00005980  0003ff69  ANDI  0x3ff (D 1023)
		00005984  0000045a  MULI  0x4 (D 4)
		00005988  00000055  ADDL  0x0 (D 0)
		0000598c  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1906 start=5732 end=5732>
	<code>}</code>
</stmt>
<stmt file=os.c line=1907 start=5732 end=5732>
	<code></code>
</stmt>
<stmt file=os.c line=1908 start=5732 end=5732>
	<code>// create PTE for a page</code>
</stmt>
<stmt file=os.c line=1909 start=5732 end=5733>
	<code>mappage(uint *pd, uint va, uint pa, int perm)</code>
	<emi>
		00005990  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1910 start=5733 end=5733>
	<code>{</code>
</stmt>
<stmt file=os.c line=1911 start=5733 end=5733>
	<code>  uint *pde, *pte, *pt;</code>
</stmt>
<stmt file=os.c line=1912 start=5733 end=5733>
	<code></code>
</stmt>
<stmt file=os.c line=1913 start=5733 end=5742>
	<code>  if (*(pde = &pd[va >> 22]) & PTE_P)</code>
	<emi>
		00005994  fffff001  ENT   0xfffffff0 (D -16)
		00005998  0000200e  LL    0x20 (D 32)
		0000599c  00001678  SRUI  0x16 (D 22)
		000059a0  0000045a  MULI  0x4 (D 4)
		000059a4  00001855  ADDL  0x18 (D 24)
		000059a8  00000c40  SL    0xc (D 12)
		000059ac  0000001c  LX  
		000059b0  00000169  ANDI  0x1 (D 1)
		000059b4  00000084  BZ    <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1914 start=5742 end=5749>
	<code>    pt = P2V+(*pde & -PAGE);</code>
	<emi>
		000059b8  00000c0e  LL    0xc (D 12)
		000059bc  0000001c  LX  
		000059c0  fff00069  ANDI  0xfffff000 (D -4096)
		000059c4  ffffc03b  LBI   0xffffffc0 (D -64)
		000059c8  0000003c  LBHI  0x0 (D 0)
		000059cc  00000053  ADD 
		000059d0  00000440  SL    0x4 (D 4)
	</emi>
</stmt>
<stmt file=os.c line=1915 start=5749 end=5749>
	<code>  else</code>
</stmt>
<stmt file=os.c line=1916 start=5749 end=5765>
	<code>    *pde = (V2P+(uint)(pt = memset(kalloc(), 0, PAGE))) | PTE_P | PTE_W | PTE_U;</code>
	<emi>
		000059d4  00000003  JMP   <fwd>
		000059d8  0010009e  PSHI  0x1000 (D 4096)
		000059dc  0000009e  PSHI  0x0 (D 0)
		000059e0  ffa80805  JSR   0xffffa808 (TO 0x1ec)
		000059e4  0000009d  PSHA
		000059e8  ffa62c05  JSR   0xffffa62c (TO 0x18)
		000059ec  00001801  ENT   0x18 (D 24)
		000059f0  00000440  SL    0x4 (D 4)
		000059f4  0000403b  LBI   0x40 (D 64)
		000059f8  0000003c  LBHI  0x0 (D 0)
		000059fc  00000053  ADD 
		00005a00  0000016c  ORI   0x1 (D 1)
		00005a04  0000026c  ORI   0x2 (D 2)
		00005a08  0000046c  ORI   0x4 (D 4)
		00005a0c  00000c26  LBL   0xc (D 12)
		00005a10  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1917 start=5765 end=5771>
	<code>  pte = &pt[(va >> 12) & 0x3ff];</code>
	<emi>
		00005a14  0000200e  LL    0x20 (D 32)
		00005a18  00000c78  SRUI  0xc (D 12)
		00005a1c  0003ff69  ANDI  0x3ff (D 1023)
		00005a20  0000045a  MULI  0x4 (D 4)
		00005a24  00000455  ADDL  0x4 (D 4)
		00005a28  00000840  SL    0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1918 start=5771 end=5794>
	<code>  if (*pte & PTE_P) { printf("*pte=0x%x pd=0x%x va=0x%x pa=0x%x perm=0x%x", *pte, pd, va, pa, perm); panic("remap"); }</code>
	<emi>
		00005a2c  0000080e  LL    0x8 (D 8)
		00005a30  0000001c  LX  
		00005a34  00000169  ANDI  0x1 (D 1)
		00005a38  00000084  BZ    <fwd>
		00005a3c  0000300e  LL    0x30 (D 48)
		00005a40  0000009d  PSHA
		00005a44  0000300e  LL    0x30 (D 48)
		00005a48  0000009d  PSHA
		00005a4c  0000300e  LL    0x30 (D 48)
		00005a50  0000009d  PSHA
		00005a54  0000300e  LL    0x30 (D 48)
		00005a58  0000009d  PSHA
		00005a5c  0000280e  LL    0x28 (D 40)
		00005a60  0000001c  LX  
		00005a64  0000009d  PSHA
		00005a68  00030f08  LEAG  0x30f (D 783)
		00005a6c  0000009d  PSHA
		00005a70  ffa94405  JSR   0xffffa944 (TO 0x3b8)
		00005a74  00003001  ENT   0x30 (D 48)
		00005a78  00033b08  LEAG  0x33b (D 827)
		00005a7c  0000009d  PSHA
		00005a80  ffaab005  JSR   0xffffaab0 (TO 0x534)
		00005a84  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1919 start=5794 end=5798>
	<code>  *pte = pa | perm;</code>
	<emi>
		00005a88  0000280e  LL    0x28 (D 40)
		00005a8c  0000306d  ORL   0x30 (D 48)
		00005a90  00000826  LBL   0x8 (D 8)
		00005a94  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1920 start=5798 end=5798>
	<code>}</code>
</stmt>
<stmt file=os.c line=1921 start=5798 end=5798>
	<code></code>
</stmt>
<stmt file=os.c line=1922 start=5798 end=5798>
	<code>// Allocate page tables and physical memory to grow process from oldsz to</code>
</stmt>
<stmt file=os.c line=1923 start=5798 end=5798>
	<code>// newsz, which need not be page aligned.  Returns new size or 0 on error.</code>
</stmt>
<stmt file=os.c line=1924 start=5798 end=5799>
	<code>int allocuvm(uint *pd, uint oldsz, uint newsz, int create) // XXX rename grow() ?</code>
	<emi>
		00005a98  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1925 start=5799 end=5799>
	<code>{</code>
</stmt>
<stmt file=os.c line=1926 start=5799 end=5799>
	<code>  uint va;</code>
</stmt>
<stmt file=os.c line=1927 start=5799 end=5806>
	<code>  if (newsz > USERTOP) return 0; // XXX make sure this never happens...</code>
	<emi>
		00005a9c  fffff801  ENT   0xfffffff8 (D -8)
		00005aa0  ffffc023  LI    0xffffffc0 (D -64)
		00005aa4  00000024  LHI   0x0 (D 0)
		00005aa8  00002026  LBL   0x20 (D 32)
		00005aac  00000090  BGEU  <fwd>
		00005ab0  00000023  LI    0x0 (D 0)
		00005ab4  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1928 start=5806 end=5813>
	<code>  if (newsz <= oldsz) panic("allocuvm: newsz <= oldsz"); // XXX do pre-checking in caller, no more post-checking needed</code>
	<emi>
		00005ab8  0000180e  LL    0x18 (D 24)
		00005abc  00002026  LBL   0x20 (D 32)
		00005ac0  0000008d  BLTU  <fwd>
		00005ac4  00034108  LEAG  0x341 (D 833)
		00005ac8  0000009d  PSHA
		00005acc  ffaa6405  JSR   0xffffaa64 (TO 0x534)
		00005ad0  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1929 start=5813 end=5813>
	<code>  </code>
</stmt>
<stmt file=os.c line=1930 start=5813 end=5818>
	<code>  va = (oldsz + PAGE-1) & -PAGE;</code>
	<emi>
		00005ad4  0000180e  LL    0x18 (D 24)
		00005ad8  00100054  ADDI  0x1000 (D 4096)
		00005adc  ffffff54  ADDI  0xffffffff (D -1)
		00005ae0  fff00069  ANDI  0xfffff000 (D -4096)
		00005ae4  00000440  SL    0x4 (D 4)
	</emi>
</stmt>
<stmt file=os.c line=1931 start=5818 end=5819>
	<code>  while (va < newsz) {</code>
	<emi>
		00005ae8  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1932 start=5819 end=5821>
	<code>    if (create)</code>
	<emi>
		00005aec  0000280e  LL    0x28 (D 40)
		00005af0  00000084  BZ    <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1933 start=5821 end=5838>
	<code>      mappage(pd, va, V2P+(memset(kalloc(), 0, PAGE)), PTE_P | PTE_W | PTE_U);</code>
	<emi>
		00005af4  0000079e  PSHI  0x7 (D 7)
		00005af8  0010009e  PSHI  0x1000 (D 4096)
		00005afc  0000009e  PSHI  0x0 (D 0)
		00005b00  ffa6e805  JSR   0xffffa6e8 (TO 0x1ec)
		00005b04  0000009d  PSHA
		00005b08  ffa50c05  JSR   0xffffa50c (TO 0x18)
		00005b0c  00001801  ENT   0x18 (D 24)
		00005b10  0000403b  LBI   0x40 (D 64)
		00005b14  0000003c  LBHI  0x0 (D 0)
		00005b18  00000053  ADD 
		00005b1c  0000009d  PSHA
		00005b20  0000140e  LL    0x14 (D 20)
		00005b24  0000009d  PSHA
		00005b28  0000280e  LL    0x28 (D 40)
		00005b2c  0000009d  PSHA
		00005b30  fffe6005  JSR   0xfffffe60 (TO 0x5994)
		00005b34  00002001  ENT   0x20 (D 32)
	</emi>
</stmt>
<stmt file=os.c line=1934 start=5838 end=5838>
	<code>    else</code>
</stmt>
<stmt file=os.c line=1935 start=5838 end=5847>
	<code>      mappage(pd, va, 0, PTE_W | PTE_U);</code>
	<emi>
		00005b38  00000003  JMP   <fwd>
		00005b3c  0000069e  PSHI  0x6 (D 6)
		00005b40  0000009e  PSHI  0x0 (D 0)
		00005b44  0000140e  LL    0x14 (D 20)
		00005b48  0000009d  PSHA
		00005b4c  0000280e  LL    0x28 (D 40)
		00005b50  0000009d  PSHA
		00005b54  fffe3c05  JSR   0xfffffe3c (TO 0x5994)
		00005b58  00002001  ENT   0x20 (D 32)
	</emi>
</stmt>
<stmt file=os.c line=1936 start=5847 end=5850>
	<code>    va += PAGE;</code>
	<emi>
		00005b5c  0000040e  LL    0x4 (D 4)
		00005b60  00100054  ADDI  0x1000 (D 4096)
		00005b64  00000440  SL    0x4 (D 4)
	</emi>
</stmt>
<stmt file=os.c line=1937 start=5850 end=5850>
	<code>  }  </code>
</stmt>
<stmt file=os.c line=1938 start=5850 end=5855>
	<code>  return newsz; // XXX not needed if never fails</code>
	<emi>
		00005b68  0000040e  LL    0x4 (D 4)
		00005b6c  00002026  LBL   0x20 (D 32)
		00005b70  0000008d  BLTU  <fwd>
		00005b74  0000200e  LL    0x20 (D 32)
		00005b78  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1939 start=5855 end=5855>
	<code>}</code>
</stmt>
<stmt file=os.c line=1940 start=5855 end=5855>
	<code></code>
</stmt>
<stmt file=os.c line=1941 start=5855 end=5855>
	<code>// deallocate user pages to bring the process size from oldsz to newsz.</code>
</stmt>
<stmt file=os.c line=1942 start=5855 end=5855>
	<code>// oldsz and newsz need not be page-aligned, nor does newsz need to be less than oldsz.   XXXX wha why?</code>
</stmt>
<stmt file=os.c line=1943 start=5855 end=5855>
	<code>// oldsz can be larger than the actual process size.  Returns the new process size.</code>
</stmt>
<stmt file=os.c line=1944 start=5855 end=5856>
	<code>int deallocuvm(uint *pd, uint oldsz, uint newsz) // XXX rename shrink() ?? //XXX memset 0 top of partial page if present !!!</code>
	<emi>
		00005b7c  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1945 start=5856 end=5856>
	<code>{</code>
</stmt>
<stmt file=os.c line=1946 start=5856 end=5856>
	<code>  uint va, *pde, *pte, *pt;</code>
</stmt>
<stmt file=os.c line=1947 start=5856 end=5856>
	<code></code>
</stmt>
<stmt file=os.c line=1948 start=5856 end=5862>
	<code>  if (newsz >= oldsz) return oldsz; // XXX maybe make sure this never happens</code>
	<emi>
		00005b80  fffff001  ENT   0xfffffff0 (D -16)
		00005b84  0000280e  LL    0x28 (D 40)
		00005b88  00002026  LBL   0x20 (D 32)
		00005b8c  0000008d  BLTU  <fwd>
		00005b90  0000200e  LL    0x20 (D 32)
		00005b94  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1949 start=5862 end=5862>
	<code></code>
</stmt>
<stmt file=os.c line=1950 start=5862 end=5864>
	<code>  va = newsz;</code>
	<emi>
		00005b98  0000280e  LL    0x28 (D 40)
		00005b9c  00000c40  SL    0xc (D 12)
	</emi>
</stmt>
<stmt file=os.c line=1951 start=5864 end=5867>
	<code>  if (va & (PAGE-1)) {</code>
	<emi>
		00005ba0  00000c0e  LL    0xc (D 12)
		00005ba4  000fff69  ANDI  0xfff (D 4095)
		00005ba8  00000084  BZ    <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1952 start=5867 end=5878>
	<code>    memset(va, 0, PAGE - (va & (PAGE-1)));</code>
	<emi>
		00005bac  00000c0e  LL    0xc (D 12)
		00005bb0  000fff69  ANDI  0xfff (D 4095)
		00005bb4  0000003e  LBA 
		00005bb8  00100023  LI    0x1000 (D 4096)
		00005bbc  00000056  SUB 
		00005bc0  0000009d  PSHA
		00005bc4  0000009e  PSHI  0x0 (D 0)
		00005bc8  00001c0e  LL    0x1c (D 28)
		00005bcc  0000009d  PSHA
		00005bd0  ffa44405  JSR   0xffffa444 (TO 0x18)
		00005bd4  00001801  ENT   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=1953 start=5878 end=5883>
	<code>    va = (va + PAGE-1) & -PAGE;</code>
	<emi>
		00005bd8  00000c0e  LL    0xc (D 12)
		00005bdc  00100054  ADDI  0x1000 (D 4096)
		00005be0  ffffff54  ADDI  0xffffffff (D -1)
		00005be4  fff00069  ANDI  0xfffff000 (D -4096)
		00005be8  00000c40  SL    0xc (D 12)
	</emi>
</stmt>
<stmt file=os.c line=1954 start=5883 end=5883>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1955 start=5883 end=5883>
	<code></code>
</stmt>
<stmt file=os.c line=1956 start=5883 end=5884>
	<code>  while(va < oldsz) {</code>
	<emi>
		00005bec  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1957 start=5884 end=5890>
	<code>    pde = &pd[(va >> 22) & 0x3ff]; //&pd[PDX(va)];</code>
	<emi>
		00005bf0  00000c0e  LL    0xc (D 12)
		00005bf4  00001678  SRUI  0x16 (D 22)
		00005bf8  0003ff69  ANDI  0x3ff (D 1023)
		00005bfc  0000045a  MULI  0x4 (D 4)
		00005c00  00001855  ADDL  0x18 (D 24)
		00005c04  00000840  SL    0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1958 start=5890 end=5894>
	<code>    if (*pde & PTE_P) { // XXX this may no longer be true if we are paging out pde/pte's?</code>
	<emi>
		00005c08  0000080e  LL    0x8 (D 8)
		00005c0c  0000001c  LX  
		00005c10  00000169  ANDI  0x1 (D 1)
		00005c14  00000084  BZ    <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1959 start=5894 end=5901>
	<code>      pt = P2V+(*pde & -PAGE);</code>
	<emi>
		00005c18  0000080e  LL    0x8 (D 8)
		00005c1c  0000001c  LX  
		00005c20  fff00069  ANDI  0xfffff000 (D -4096)
		00005c24  ffffc03b  LBI   0xffffffc0 (D -64)
		00005c28  0000003c  LBHI  0x0 (D 0)
		00005c2c  00000053  ADD 
		00005c30  00000040  SL    0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=1960 start=5901 end=5907>
	<code>      pte = &pt[(va >> 12) & 0x3ff]; // &pt[PTX(va)];</code>
	<emi>
		00005c34  00000c0e  LL    0xc (D 12)
		00005c38  00000c78  SRUI  0xc (D 12)
		00005c3c  0003ff69  ANDI  0x3ff (D 1023)
		00005c40  0000045a  MULI  0x4 (D 4)
		00005c44  00000055  ADDL  0x0 (D 0)
		00005c48  00000440  SL    0x4 (D 4)
	</emi>
</stmt>
<stmt file=os.c line=1961 start=5907 end=5907>
	<code></code>
</stmt>
<stmt file=os.c line=1962 start=5907 end=5911>
	<code>      if (*pte & PTE_P) {</code>
	<emi>
		00005c4c  0000040e  LL    0x4 (D 4)
		00005c50  0000001c  LX  
		00005c54  00000169  ANDI  0x1 (D 1)
		00005c58  00000084  BZ    <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1963 start=5911 end=5920>
	<code>        kfree(P2V+(*pte & -PAGE));</code>
	<emi>
		00005c5c  0000040e  LL    0x4 (D 4)
		00005c60  0000001c  LX  
		00005c64  fff00069  ANDI  0xfffff000 (D -4096)
		00005c68  ffffc03b  LBI   0xffffffc0 (D -64)
		00005c6c  0000003c  LBHI  0x0 (D 0)
		00005c70  00000053  ADD 
		00005c74  0000009d  PSHA
		00005c78  ffa5fc05  JSR   0xffffa5fc (TO 0x278)
		00005c7c  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1964 start=5920 end=5923>
	<code>        *pte = 0;      </code>
	<emi>
		00005c80  00000023  LI    0x0 (D 0)
		00005c84  00000426  LBL   0x4 (D 4)
		00005c88  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=1965 start=5923 end=5923>
	<code>      }</code>
</stmt>
<stmt file=os.c line=1966 start=5923 end=5926>
	<code>      va += PAGE;</code>
	<emi>
		00005c8c  00000c0e  LL    0xc (D 12)
		00005c90  00100054  ADDI  0x1000 (D 4096)
		00005c94  00000c40  SL    0xc (D 12)
	</emi>
</stmt>
<stmt file=os.c line=1967 start=5926 end=5926>
	<code>    }</code>
</stmt>
<stmt file=os.c line=1968 start=5926 end=5926>
	<code>    else</code>
</stmt>
<stmt file=os.c line=1969 start=5926 end=5931>
	<code>      va = (va + PAGE * 1024) & -(PAGE * 1024);</code>
	<emi>
		00005c98  00000003  JMP   <fwd>
		00005c9c  00000c0e  LL    0xc (D 12)
		00005ca0  40000054  ADDI  0x400000 (D 4194304)
		00005ca4  c0000069  ANDI  0xffc00000 (D -4194304)
		00005ca8  00000c40  SL    0xc (D 12)
	</emi>
</stmt>
<stmt file=os.c line=1970 start=5931 end=5931>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1971 start=5931 end=5936>
	<code>  return newsz; // XXX not needed if never fails</code>
	<emi>
		00005cac  00000c0e  LL    0xc (D 12)
		00005cb0  00002026  LBL   0x20 (D 32)
		00005cb4  0000008d  BLTU  <fwd>
		00005cb8  0000280e  LL    0x28 (D 40)
		00005cbc  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1972 start=5936 end=5936>
	<code>}</code>
</stmt>
<stmt file=os.c line=1973 start=5936 end=5936>
	<code></code>
</stmt>
<stmt file=os.c line=1974 start=5936 end=5936>
	<code>// free a page table and all the physical memory pages in the user part</code>
</stmt>
<stmt file=os.c line=1975 start=5936 end=5937>
	<code>freevm(uint *pd)</code>
	<emi>
		00005cc0  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=1976 start=5937 end=5937>
	<code>{</code>
</stmt>
<stmt file=os.c line=1977 start=5937 end=5937>
	<code>  uint i;</code>
</stmt>
<stmt file=os.c line=1978 start=5937 end=5937>
	<code></code>
</stmt>
<stmt file=os.c line=1979 start=5937 end=5944>
	<code>  if (!pd) panic("freevm: no pd");</code>
	<emi>
		00005cc4  fffff801  ENT   0xfffffff8 (D -8)
		00005cc8  0000100e  LL    0x10 (D 16)
		00005ccc  00000086  BNZ   <fwd>
		00005cd0  00035a08  LEAG  0x35a (D 858)
		00005cd4  0000009d  PSHA
		00005cd8  ffa85805  JSR   0xffffa858 (TO 0x534)
		00005cdc  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1980 start=5944 end=5952>
	<code>  deallocuvm(pd, USERTOP, 0);  // deallocate all user memory XXX do this more simply</code>
	<emi>
		00005ce0  0000009e  PSHI  0x0 (D 0)
		00005ce4  ffffc023  LI    0xffffffc0 (D -64)
		00005ce8  00000024  LHI   0x0 (D 0)
		00005cec  0000009d  PSHA
		00005cf0  0000200e  LL    0x20 (D 32)
		00005cf4  0000009d  PSHA
		00005cf8  fffe8405  JSR   0xfffffe84 (TO 0x5b80)
		00005cfc  00001801  ENT   0x18 (D 24)
	</emi>
</stmt>
<stmt file=os.c line=1981 start=5952 end=5955>
	<code>  for (i = 0; i < ((USERTOP >> 22) & 0x3ff); i++) { // for (i = 0; i < PDX(USERTOP); i++)</code>
	<emi>
		00005d00  00000023  LI    0x0 (D 0)
		00005d04  00000440  SL    0x4 (D 4)
		00005d08  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1982 start=5955 end=5972>
	<code>    if (pd[i] & PTE_P) kfree(P2V+(pd[i] & -PAGE)); // deallocate all page table entries</code>
	<emi>
		00005d0c  0000040e  LL    0x4 (D 4)
		00005d10  0000045a  MULI  0x4 (D 4)
		00005d14  00001055  ADDL  0x10 (D 16)
		00005d18  0000001c  LX  
		00005d1c  00000169  ANDI  0x1 (D 1)
		00005d20  00000084  BZ    <fwd>
		00005d24  0000040e  LL    0x4 (D 4)
		00005d28  0000045a  MULI  0x4 (D 4)
		00005d2c  00001055  ADDL  0x10 (D 16)
		00005d30  0000001c  LX  
		00005d34  fff00069  ANDI  0xfffff000 (D -4096)
		00005d38  ffffc03b  LBI   0xffffffc0 (D -64)
		00005d3c  0000003c  LBHI  0x0 (D 0)
		00005d40  00000053  ADD 
		00005d44  0000009d  PSHA
		00005d48  ffa52c05  JSR   0xffffa52c (TO 0x278)
		00005d4c  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1983 start=5972 end=5972>
	<code>  }</code>
</stmt>
<stmt file=os.c line=1984 start=5972 end=5982>
	<code>  kfree(pd); // deallocate page directory</code>
	<emi>
		00005d50  0000040e  LL    0x4 (D 4)
		00005d54  ffffff57  SUBI  0xffffffff (D -1)
		00005d58  00000440  SL    0x4 (D 4)
		00005d5c  0000040e  LL    0x4 (D 4)
		00005d60  0003003b  LBI   0x300 (D 768)
		00005d64  0000008d  BLTU  <fwd>
		00005d68  0000100e  LL    0x10 (D 16)
		00005d6c  0000009d  PSHA
		00005d70  ffa50405  JSR   0xffffa504 (TO 0x278)
		00005d74  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1985 start=5982 end=5982>
	<code>}</code>
</stmt>
<stmt file=os.c line=1986 start=5982 end=5982>
	<code></code>
</stmt>
<stmt file=os.c line=1987 start=5982 end=5982>
	<code>// copy parent process page table for a child</code>
</stmt>
<stmt file=os.c line=1988 start=5982 end=5983>
	<code>uint *copyuvm(uint *pd, uint sz)</code>
	<emi>
		00005d78  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1989 start=5983 end=5983>
	<code>{</code>
</stmt>
<stmt file=os.c line=1990 start=5983 end=5983>
	<code>  uint va, *d, *pte;</code>
</stmt>
<stmt file=os.c line=1991 start=5983 end=5983>
	<code></code>
</stmt>
<stmt file=os.c line=1992 start=5983 end=5992>
	<code>  d = memcpy(kalloc(), kpdir, PAGE);</code>
	<emi>
		00005d7c  fffff001  ENT   0xfffffff0 (D -16)
		00005d80  0010009e  PSHI  0x1000 (D 4096)
		00005d84  00216815  LG    0x2168 (D 8552)
		00005d88  0000009d  PSHA
		00005d8c  ffa45c05  JSR   0xffffa45c (TO 0x1ec)
		00005d90  0000009d  PSHA
		00005d94  ffa26805  JSR   0xffffa268 (TO 0x0)
		00005d98  00001801  ENT   0x18 (D 24)
		00005d9c  00000840  SL    0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1993 start=5992 end=5995>
	<code>  for (va = 0; va < sz; va += PAGE) {</code>
	<emi>
		00005da0  00000023  LI    0x0 (D 0)
		00005da4  00000c40  SL    0xc (D 12)
		00005da8  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1994 start=5995 end=6007>
	<code>    if (!(pte = walkpdir(pd, va))) panic("copyuvm: pte should exist");</code>
	<emi>
		00005dac  00000c0e  LL    0xc (D 12)
		00005db0  0000009d  PSHA
		00005db4  0000200e  LL    0x20 (D 32)
		00005db8  0000009d  PSHA
		00005dbc  fffb6c05  JSR   0xfffffb6c (TO 0x592c)
		00005dc0  00001001  ENT   0x10 (D 16)
		00005dc4  00000440  SL    0x4 (D 4)
		00005dc8  00000086  BNZ   <fwd>
		00005dcc  00036808  LEAG  0x368 (D 872)
		00005dd0  0000009d  PSHA
		00005dd4  ffa75c05  JSR   0xffffa75c (TO 0x534)
		00005dd8  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=1995 start=6007 end=6007>
	<code></code>
</stmt>
<stmt file=os.c line=1996 start=6007 end=6011>
	<code>    if (*pte & PTE_P)</code>
	<emi>
		00005ddc  0000040e  LL    0x4 (D 4)
		00005de0  0000001c  LX  
		00005de4  00000169  ANDI  0x1 (D 1)
		00005de8  00000084  BZ    <fwd>
	</emi>
</stmt>
<stmt file=os.c line=1997 start=6011 end=6034>
	<code>      mappage(d, va, V2P+(memcpy(kalloc(), P2V+(*pte & -PAGE), PAGE)), PTE_P | PTE_W | PTE_U); // XXX implement copy on write</code>
	<emi>
		00005dec  0000079e  PSHI  0x7 (D 7)
		00005df0  0010009e  PSHI  0x1000 (D 4096)
		00005df4  0000140e  LL    0x14 (D 20)
		00005df8  0000001c  LX  
		00005dfc  fff00069  ANDI  0xfffff000 (D -4096)
		00005e00  ffffc03b  LBI   0xffffffc0 (D -64)
		00005e04  0000003c  LBHI  0x0 (D 0)
		00005e08  00000053  ADD 
		00005e0c  0000009d  PSHA
		00005e10  ffa3d805  JSR   0xffffa3d8 (TO 0x1ec)
		00005e14  0000009d  PSHA
		00005e18  ffa1e405  JSR   0xffffa1e4 (TO 0x0)
		00005e1c  00001801  ENT   0x18 (D 24)
		00005e20  0000403b  LBI   0x40 (D 64)
		00005e24  0000003c  LBHI  0x0 (D 0)
		00005e28  00000053  ADD 
		00005e2c  0000009d  PSHA
		00005e30  00001c0e  LL    0x1c (D 28)
		00005e34  0000009d  PSHA
		00005e38  0000200e  LL    0x20 (D 32)
		00005e3c  0000009d  PSHA
		00005e40  fffb5005  JSR   0xfffffb50 (TO 0x5994)
		00005e44  00002001  ENT   0x20 (D 32)
	</emi>
</stmt>
<stmt file=os.c line=1998 start=6034 end=6034>
	<code>    else</code>
</stmt>
<stmt file=os.c line=1999 start=6034 end=6043>
	<code>      mappage(d, va, 0, PTE_W | PTE_U);</code>
	<emi>
		00005e48  00000003  JMP   <fwd>
		00005e4c  0000069e  PSHI  0x6 (D 6)
		00005e50  0000009e  PSHI  0x0 (D 0)
		00005e54  00001c0e  LL    0x1c (D 28)
		00005e58  0000009d  PSHA
		00005e5c  0000200e  LL    0x20 (D 32)
		00005e60  0000009d  PSHA
		00005e64  fffb2c05  JSR   0xfffffb2c (TO 0x5994)
		00005e68  00002001  ENT   0x20 (D 32)
	</emi>
</stmt>
<stmt file=os.c line=2000 start=6043 end=6043>
	<code>  }</code>
</stmt>
<stmt file=os.c line=2001 start=6043 end=6051>
	<code>  return d;</code>
	<emi>
		00005e6c  00000c0e  LL    0xc (D 12)
		00005e70  00100054  ADDI  0x1000 (D 4096)
		00005e74  00000c40  SL    0xc (D 12)
		00005e78  00000c0e  LL    0xc (D 12)
		00005e7c  00002026  LBL   0x20 (D 32)
		00005e80  0000008d  BLTU  <fwd>
		00005e84  0000080e  LL    0x8 (D 8)
		00005e88  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=2002 start=6051 end=6051>
	<code>}</code>
</stmt>
<stmt file=os.c line=2003 start=6051 end=6051>
	<code></code>
</stmt>
<stmt file=os.c line=2004 start=6051 end=6052>
	<code>swtch(int *old, int new) // switch stacks</code>
	<emi>
		00005e8c  00001002  LEV   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=2005 start=6052 end=6052>
	<code>{</code>
</stmt>
<stmt file=os.c line=2006 start=6052 end=6053>
	<code>  asm(LEA,0); // a = sp</code>
	<emi>
		00005e90  00000007  LEA   0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=2007 start=6053 end=6054>
	<code>  asm(LBL,8); // b = old</code>
	<emi>
		00005e94  00000826  LBL   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=2008 start=6054 end=6055>
	<code>  asm(SX,0);  // *b = a</code>
	<emi>
		00005e98  0000004a  SX    0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=2009 start=6055 end=6056>
	<code>  asm(LL,16); // a = new</code>
	<emi>
		00005e9c  0000100e  LL    0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=2010 start=6056 end=6057>
	<code>  asm(SSP);   // sp = a</code>
	<emi>
		00005ea0  0000009c  SSP 
	</emi>
</stmt>
<stmt file=os.c line=2011 start=6057 end=6057>
	<code>}</code>
</stmt>
<stmt file=os.c line=2012 start=6057 end=6057>
	<code></code>
</stmt>
<stmt file=os.c line=2013 start=6057 end=6058>
	<code>scheduler()</code>
	<emi>
		00005ea4  00000002  LEV   0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=2014 start=6058 end=6058>
	<code>{</code>
</stmt>
<stmt file=os.c line=2015 start=6058 end=6058>
	<code>  int n;</code>
</stmt>
<stmt file=os.c line=2016 start=6058 end=6058>
	<code>  </code>
</stmt>
<stmt file=os.c line=2017 start=6058 end=6062>
	<code>  for (n = 0; n < NPROC; n++) {  // XXX do me differently</code>
	<emi>
		00005ea8  fffff801  ENT   0xfffffff8 (D -8)
		00005eac  00000023  LI    0x0 (D 0)
		00005eb0  00000440  SL    0x4 (D 4)
		00005eb4  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=2018 start=6062 end=6079>
	<code>    proc[n].next = &proc[(n+1)&(NPROC-1)];</code>
	<emi>
		00005eb8  00000008  LEAG  0x0 (D 0)
		00005ebc  0000009d  PSHA
		00005ec0  00000c0e  LL    0xc (D 12)
		00005ec4  0000845a  MULI  0x84 (D 132)
		00005ec8  000000a1  POPB
		00005ecc  00000053  ADD 
		00005ed0  0000009d  PSHA
		00005ed4  00000008  LEAG  0x0 (D 0)
		00005ed8  0000009d  PSHA
		00005edc  0000140e  LL    0x14 (D 20)
		00005ee0  00000154  ADDI  0x1 (D 1)
		00005ee4  00003f69  ANDI  0x3f (D 63)
		00005ee8  0000845a  MULI  0x84 (D 132)
		00005eec  000000a1  POPB
		00005ef0  00000053  ADD 
		00005ef4  000000a1  POPB
		00005ef8  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=2019 start=6079 end=6097>
	<code>    proc[n].prev = &proc[(n-1)&(NPROC-1)];</code>
	<emi>
		00005efc  00000008  LEAG  0x0 (D 0)
		00005f00  0000009d  PSHA
		00005f04  00000c0e  LL    0xc (D 12)
		00005f08  0000845a  MULI  0x84 (D 132)
		00005f0c  000000a1  POPB
		00005f10  00000053  ADD 
		00005f14  00000454  ADDI  0x4 (D 4)
		00005f18  0000009d  PSHA
		00005f1c  00000008  LEAG  0x0 (D 0)
		00005f20  0000009d  PSHA
		00005f24  0000140e  LL    0x14 (D 20)
		00005f28  ffffff54  ADDI  0xffffffff (D -1)
		00005f2c  00003f69  ANDI  0x3f (D 63)
		00005f30  0000845a  MULI  0x84 (D 132)
		00005f34  000000a1  POPB
		00005f38  00000053  ADD 
		00005f3c  000000a1  POPB
		00005f40  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=2020 start=6097 end=6097>
	<code>  }</code>
</stmt>
<stmt file=os.c line=2021 start=6097 end=6097>
	<code>  </code>
</stmt>
<stmt file=os.c line=2022 start=6097 end=6105>
	<code>  u = &proc[0];</code>
	<emi>
		00005f44  0000040e  LL    0x4 (D 4)
		00005f48  ffffff57  SUBI  0xffffffff (D -1)
		00005f4c  00000440  SL    0x4 (D 4)
		00005f50  0000040e  LL    0x4 (D 4)
		00005f54  0000403b  LBI   0x40 (D 64)
		00005f58  0000008c  BLT   <fwd>
		00005f5c  00000008  LEAG  0x0 (D 0)
		00005f60  00210045  SG    0x2100 (D 8448)
	</emi>
</stmt>
<stmt file=os.c line=2023 start=6105 end=6113>
	<code>  pdir(V2P+(uint)(u->pdir));</code>
	<emi>
		00005f64  00210015  LG    0x2100 (D 8448)
		00005f68  00000c1c  LX    0xc (D 12)
		00005f6c  0000403b  LBI   0x40 (D 64)
		00005f70  0000003c  LBHI  0x0 (D 0)
		00005f74  00000053  ADD 
		00005f78  0000009d  PSHA
		00005f7c  ffa10805  JSR   0xffffa108 (TO 0x88)
		00005f80  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=2024 start=6113 end=6118>
	<code>  u->state = RUNNING;</code>
	<emi>
		00005f84  00210015  LG    0x2100 (D 8448)
		00005f88  00001454  ADDI  0x14 (D 20)
		00005f8c  0000003e  LBA 
		00005f90  00000423  LI    0x4 (D 4)
		00005f94  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=2025 start=6118 end=6125>
	<code>  swtch(&n, u->context);</code>
	<emi>
		00005f98  00210015  LG    0x2100 (D 8448)
		00005f9c  0000241c  LX    0x24 (D 36)
		00005fa0  0000009d  PSHA
		00005fa4  00000c07  LEA   0xc (D 12)
		00005fa8  0000009d  PSHA
		00005fac  fffee005  JSR   0xfffffee0 (TO 0x5e90)
		00005fb0  00001001  ENT   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=2026 start=6125 end=6129>
	<code>  panic("scheduler returned!\n");</code>
	<emi>
		00005fb4  00038208  LEAG  0x382 (D 898)
		00005fb8  0000009d  PSHA
		00005fbc  ffa57405  JSR   0xffffa574 (TO 0x534)
		00005fc0  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=2027 start=6129 end=6129>
	<code>}</code>
</stmt>
<stmt file=os.c line=2028 start=6129 end=6129>
	<code></code>
</stmt>
<stmt file=os.c line=2029 start=6129 end=6130>
	<code>sched() // XXX redesign this better</code>
	<emi>
		00005fc4  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=2030 start=6130 end=6130>
	<code>{</code>
</stmt>
<stmt file=os.c line=2031 start=6130 end=6130>
	<code>  int n; struct proc *p;</code>
</stmt>
<stmt file=os.c line=2032 start=6130 end=6130>
	<code>//  if (u->state == RUNNING) panic("sched running");</code>
</stmt>
<stmt file=os.c line=2033 start=6130 end=6130>
	<code>//  if (lien()) panic("sched interruptible");</code>
</stmt>
<stmt file=os.c line=2034 start=6130 end=6133>
	<code>  p = u;</code>
	<emi>
		00005fc8  fffff801  ENT   0xfffffff8 (D -8)
		00005fcc  00210015  LG    0x2100 (D 8448)
		00005fd0  00000040  SL    0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=2035 start=6133 end=6133>
	<code>//  while (u->state != RUNNABLE) u = u->next;</code>
</stmt>
<stmt file=os.c line=2036 start=6133 end=6136>
	<code>  for (n=0;n<NPROC;n++) {</code>
	<emi>
		00005fd4  00000023  LI    0x0 (D 0)
		00005fd8  00000440  SL    0x4 (D 4)
		00005fdc  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=2037 start=6136 end=6139>
	<code>    u = u->next;</code>
	<emi>
		00005fe0  00210015  LG    0x2100 (D 8448)
		00005fe4  0000001c  LX  
		00005fe8  00210045  SG    0x2100 (D 8448)
	</emi>
</stmt>
<stmt file=os.c line=2038 start=6139 end=6143>
	<code>    if (u == &proc[0]) continue;</code>
	<emi>
		00005fec  00000008  LEAG  0x0 (D 0)
		00005ff0  0021002d  LBG   0x2100 (D 8448)
		00005ff4  0000008a  BNE   <fwd>
		00005ff8  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=2039 start=6143 end=6148>
	<code>    if (u->state == RUNNABLE) goto found;</code>
	<emi>
		00005ffc  00210015  LG    0x2100 (D 8448)
		00006000  0000141c  LX    0x14 (D 20)
		00006004  0000033b  LBI   0x3 (D 3)
		00006008  0000008a  BNE   <fwd>
		0000600c  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=2040 start=6148 end=6148>
	<code>  }</code>
</stmt>
<stmt file=os.c line=2041 start=6148 end=6156>
	<code>  u = &proc[0];</code>
	<emi>
		00006010  0000040e  LL    0x4 (D 4)
		00006014  ffffff57  SUBI  0xffffffff (D -1)
		00006018  00000440  SL    0x4 (D 4)
		0000601c  0000040e  LL    0x4 (D 4)
		00006020  0000403b  LBI   0x40 (D 64)
		00006024  0000008c  BLT   <fwd>
		00006028  00000008  LEAG  0x0 (D 0)
		0000602c  00210045  SG    0x2100 (D 8448)
	</emi>
</stmt>
<stmt file=os.c line=2042 start=6156 end=6156>
	<code>  //printf("-");</code>
</stmt>
<stmt file=os.c line=2043 start=6156 end=6156>
	<code>  </code>
</stmt>
<stmt file=os.c line=2044 start=6156 end=6156>
	<code>found:</code>
</stmt>
<stmt file=os.c line=2045 start=6156 end=6161>
	<code>  u->state = RUNNING;</code>
	<emi>
		00006030  00210015  LG    0x2100 (D 8448)
		00006034  00001454  ADDI  0x14 (D 20)
		00006038  0000003e  LBA 
		0000603c  00000423  LI    0x4 (D 4)
		00006040  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=2046 start=6161 end=6164>
	<code>  if (p != u) {</code>
	<emi>
		00006044  00210015  LG    0x2100 (D 8448)
		00006048  00000026  LBL   0x0 (D 0)
		0000604c  00000088  BE    <fwd>
	</emi>
</stmt>
<stmt file=os.c line=2047 start=6164 end=6172>
	<code>    pdir(V2P+(uint)(u->pdir));</code>
	<emi>
		00006050  00210015  LG    0x2100 (D 8448)
		00006054  00000c1c  LX    0xc (D 12)
		00006058  0000403b  LBI   0x40 (D 64)
		0000605c  0000003c  LBHI  0x0 (D 0)
		00006060  00000053  ADD 
		00006064  0000009d  PSHA
		00006068  ffa01c05  JSR   0xffffa01c (TO 0x88)
		0000606c  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=2048 start=6172 end=6172>
	<code>    //printf("+");</code>
</stmt>
<stmt file=os.c line=2049 start=6172 end=6180>
	<code>    swtch(&p->context, u->context);</code>
	<emi>
		00006070  00210015  LG    0x2100 (D 8448)
		00006074  0000241c  LX    0x24 (D 36)
		00006078  0000009d  PSHA
		0000607c  0000080e  LL    0x8 (D 8)
		00006080  00002454  ADDI  0x24 (D 36)
		00006084  0000009d  PSHA
		00006088  fffe0405  JSR   0xfffffe04 (TO 0x5e90)
		0000608c  00001001  ENT   0x10 (D 16)
	</emi>
</stmt>
<stmt file=os.c line=2050 start=6180 end=6180>
	<code>  }</code>
</stmt>
<stmt file=os.c line=2051 start=6180 end=6180>
	<code>  //else printf("spin(%d)\n",u->pid);    XXX else do a wait for interrupt? (which will actually pend because interrupts are turned off here)</code>
</stmt>
<stmt file=os.c line=2052 start=6180 end=6180>
	<code>}</code>
</stmt>
<stmt file=os.c line=2053 start=6180 end=6180>
	<code></code>
</stmt>
<stmt file=os.c line=2054 start=6180 end=6181>
	<code>trap(uint *sp, double g, double f, int c, int b, int a, int fc, uint *pc)  </code>
	<emi>
		00006090  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=2055 start=6181 end=6181>
	<code>{</code>
</stmt>
<stmt file=os.c line=2056 start=6181 end=6181>
	<code>  uint va;</code>
</stmt>
<stmt file=os.c line=2057 start=6181 end=6184>
	<code>  switch (fc) {</code>
	<emi>
		00006094  fffff801  ENT   0xfffffff8 (D -8)
		00006098  0000400e  LL    0x40 (D 64)
		0000609c  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=2058 start=6184 end=6188>
	<code>  case FSYS: panic("FSYS from kernel");</code>
	<emi>
		000060a0  00039708  LEAG  0x397 (D 919)
		000060a4  0000009d  PSHA
		000060a8  ffa48805  JSR   0xffffa488 (TO 0x534)
		000060ac  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=2059 start=6188 end=6188>
	<code>  case FSYS + USER:</code>
</stmt>
<stmt file=os.c line=2060 start=6188 end=6194>
	<code>    if (u->killed) exit(-1);</code>
	<emi>
		000060b0  00210015  LG    0x2100 (D 8448)
		000060b4  00002c1c  LX    0x2c (D 44)
		000060b8  00000084  BZ    <fwd>
		000060bc  ffffff9e  PSHI  0xffffffff (D -1)
		000060c0  ffe7e405  JSR   0xffffe7e4 (TO 0x48a8)
		000060c4  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=2061 start=6194 end=6200>
	<code>    u->tf = &sp;</code>
	<emi>
		000060c8  00210015  LG    0x2100 (D 8448)
		000060cc  00002054  ADDI  0x20 (D 32)
		000060d0  0000009d  PSHA
		000060d4  00001807  LEA   0x18 (D 24)
		000060d8  000000a1  POPB
		000060dc  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=2062 start=6200 end=6204>
	<code>    switch (pc[-1] >> 8) {</code>
	<emi>
		000060e0  0000480e  LL    0x48 (D 72)
		000060e4  fffffc1c  LX    0xfffffffc (D -4)
		000060e8  00000878  SRUI  0x8 (D 8)
		000060ec  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=2063 start=6204 end=6207>
	<code>    case S_fork:    a = fork(); break;</code>
	<emi>
		000060f0  ffe5e805  JSR   0xffffe5e8 (TO 0x46dc)
		000060f4  00003840  SL    0x38 (D 56)
		000060f8  00000003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=2064 start=6207 end=6220>
	<code>    case S_exit:    if (a < -99) printf("exit(%d)\n",a); exit(a); // XXX debug feature</code>
	<emi>
		000060fc  0000380e  LL    0x38 (D 56)
		00006100  ffff9d3b  LBI   0xffffff9d (D -99)
		00006104  0000008f  BGE   <fwd>
		00006108  0000380e  LL    0x38 (D 56)
		0000610c  0000009d  PSHA
		00006110  0003a808  LEAG  0x3a8 (D 936)
		00006114  0000009d  PSHA
		00006118  ffa29c05  JSR   0xffffa29c (TO 0x3b8)
		0000611c  00001001  ENT   0x10 (D 16)
		00006120  0000380e  LL    0x38 (D 56)
		00006124  0000009d  PSHA
		00006128  ffe77c05  JSR   0xffffe77c (TO 0x48a8)
		0000612c  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=2065 start=6220 end=6223>
	<code>    case S_wait:    a = wait(); break; // XXX args?</code>
	<emi>
		00006130  ffe9d805  JSR   0xffffe9d8 (TO 0x4b0c)
		00006134  00003840  SL    0x38 (D 56)
		00006138  0060f803  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=2066 start=6223 end=6229>
	<code>    case S_pipe:    a = pipe(a); break;</code>
	<emi>
		0000613c  0000380e  LL    0x38 (D 56)
		00006140  0000009d  PSHA
		00006144  ffdcb005  JSR   0xffffdcb0 (TO 0x3df8)
		00006148  00000801  ENT   0x8 (D 8)
		0000614c  00003840  SL    0x38 (D 56)
		00006150  00613803  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=2067 start=6229 end=6239>
	<code>    case S_write:   a = write(a, b, c); break;</code>
	<emi>
		00006154  0000280e  LL    0x28 (D 40)
		00006158  0000009d  PSHA
		0000615c  0000380e  LL    0x38 (D 56)
		00006160  0000009d  PSHA
		00006164  0000480e  LL    0x48 (D 72)
		00006168  0000009d  PSHA
		0000616c  ffcf9005  JSR   0xffffcf90 (TO 0x3100)
		00006170  00001801  ENT   0x18 (D 24)
		00006174  00003840  SL    0x38 (D 56)
		00006178  00615003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=2068 start=6239 end=6249>
	<code>    case S_read:    a = read(a, b, c); break;</code>
	<emi>
		0000617c  0000280e  LL    0x28 (D 40)
		00006180  0000009d  PSHA
		00006184  0000380e  LL    0x38 (D 56)
		00006188  0000009d  PSHA
		0000618c  0000480e  LL    0x48 (D 72)
		00006190  0000009d  PSHA
		00006194  ffcd5005  JSR   0xffffcd50 (TO 0x2ee8)
		00006198  00001801  ENT   0x18 (D 24)
		0000619c  00003840  SL    0x38 (D 56)
		000061a0  00617803  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=2069 start=6249 end=6255>
	<code>    case S_close:   a = close(a); break;</code>
	<emi>
		000061a4  0000380e  LL    0x38 (D 56)
		000061a8  0000009d  PSHA
		000061ac  ffcb9005  JSR   0xffffcb90 (TO 0x2d40)
		000061b0  00000801  ENT   0x8 (D 8)
		000061b4  00003840  SL    0x38 (D 56)
		000061b8  0061a003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=2070 start=6255 end=6261>
	<code>    case S_kill:    a = kill(a); break;</code>
	<emi>
		000061bc  0000380e  LL    0x38 (D 56)
		000061c0  0000009d  PSHA
		000061c4  ffe89405  JSR   0xffffe894 (TO 0x4a5c)
		000061c8  00000801  ENT   0x8 (D 8)
		000061cc  00003840  SL    0x38 (D 56)
		000061d0  0061b803  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=2071 start=6261 end=6269>
	<code>    case S_exec:    a = exec(a, b); break;</code>
	<emi>
		000061d4  0000300e  LL    0x30 (D 48)
		000061d8  0000009d  PSHA
		000061dc  0000400e  LL    0x40 (D 64)
		000061e0  0000009d  PSHA
		000061e4  ffde0c05  JSR   0xffffde0c (TO 0x3ff4)
		000061e8  00001001  ENT   0x10 (D 16)
		000061ec  00003840  SL    0x38 (D 56)
		000061f0  0061d003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=2072 start=6269 end=6277>
	<code>    case S_open:    a = open(a, b); break;</code>
	<emi>
		000061f4  0000300e  LL    0x30 (D 48)
		000061f8  0000009d  PSHA
		000061fc  0000400e  LL    0x40 (D 64)
		00006200  0000009d  PSHA
		00006204  ffd71405  JSR   0xffffd714 (TO 0x391c)
		00006208  00001001  ENT   0x10 (D 16)
		0000620c  00003840  SL    0x38 (D 56)
		00006210  0061f003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=2073 start=6277 end=6287>
	<code>    case S_mknod:   a = mknod(a, b, c); break;</code>
	<emi>
		00006214  0000280e  LL    0x28 (D 40)
		00006218  0000009d  PSHA
		0000621c  0000380e  LL    0x38 (D 56)
		00006220  0000009d  PSHA
		00006224  0000480e  LL    0x48 (D 72)
		00006228  0000009d  PSHA
		0000622c  ffdaac05  JSR   0xffffdaac (TO 0x3cdc)
		00006230  00001801  ENT   0x18 (D 24)
		00006234  00003840  SL    0x38 (D 56)
		00006238  00621003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=2074 start=6287 end=6293>
	<code>    case S_unlink:  a = unlink(a); break;</code>
	<emi>
		0000623c  0000380e  LL    0x38 (D 56)
		00006240  0000009d  PSHA
		00006244  ffd42805  JSR   0xffffd428 (TO 0x3670)
		00006248  00000801  ENT   0x8 (D 8)
		0000624c  00003840  SL    0x38 (D 56)
		00006250  00623803  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=2075 start=6293 end=6301>
	<code>    case S_fstat:   a = fstat(a, b); break;</code>
	<emi>
		00006254  0000300e  LL    0x30 (D 48)
		00006258  0000009d  PSHA
		0000625c  0000400e  LL    0x40 (D 64)
		00006260  0000009d  PSHA
		00006264  ffcb4005  JSR   0xffffcb40 (TO 0x2da8)
		00006268  00001001  ENT   0x10 (D 16)
		0000626c  00003840  SL    0x38 (D 56)
		00006270  00625003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=2076 start=6301 end=6309>
	<code>    case S_link:    a = link(a, b); break;</code>
	<emi>
		00006274  0000300e  LL    0x30 (D 48)
		00006278  0000009d  PSHA
		0000627c  0000400e  LL    0x40 (D 64)
		00006280  0000009d  PSHA
		00006284  ffd24005  JSR   0xffffd240 (TO 0x34c8)
		00006288  00001001  ENT   0x10 (D 16)
		0000628c  00003840  SL    0x38 (D 56)
		00006290  00627003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=2077 start=6309 end=6315>
	<code>    case S_mkdir:   a = mkdir(a); break;</code>
	<emi>
		00006294  0000380e  LL    0x38 (D 56)
		00006298  0000009d  PSHA
		0000629c  ffd9e005  JSR   0xffffd9e0 (TO 0x3c80)
		000062a0  00000801  ENT   0x8 (D 8)
		000062a4  00003840  SL    0x38 (D 56)
		000062a8  00629003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=2078 start=6315 end=6321>
	<code>    case S_chdir:   a = chdir(a); break;</code>
	<emi>
		000062ac  0000380e  LL    0x38 (D 56)
		000062b0  0000009d  PSHA
		000062b4  ffda8805  JSR   0xffffda88 (TO 0x3d40)
		000062b8  00000801  ENT   0x8 (D 8)
		000062bc  00003840  SL    0x38 (D 56)
		000062c0  0062a803  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=2079 start=6321 end=6329>
	<code>    case S_dup2:    a = dup2(a,b); break;</code>
	<emi>
		000062c4  0000300e  LL    0x30 (D 48)
		000062c8  0000009d  PSHA
		000062cc  0000400e  LL    0x40 (D 64)
		000062d0  0000009d  PSHA
		000062d4  ffd16c05  JSR   0xffffd16c (TO 0x3444)
		000062d8  00001001  ENT   0x10 (D 16)
		000062dc  00003840  SL    0x38 (D 56)
		000062e0  0062c003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=2080 start=6329 end=6333>
	<code>    case S_getpid:  a = u->pid; break;</code>
	<emi>
		000062e4  00210015  LG    0x2100 (D 8448)
		000062e8  0000181c  LX    0x18 (D 24)
		000062ec  00003840  SL    0x38 (D 56)
		000062f0  0062e003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=2081 start=6333 end=6339>
	<code>    case S_sbrk:    a = sbrk(a); break;</code>
	<emi>
		000062f4  0000380e  LL    0x38 (D 56)
		000062f8  0000009d  PSHA
		000062fc  ffe97c05  JSR   0xffffe97c (TO 0x4c7c)
		00006300  00000801  ENT   0x8 (D 8)
		00006304  00003840  SL    0x38 (D 56)
		00006308  0062f003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=2082 start=6339 end=6345>
	<code>    case S_sleep:   a = ssleep(a); break;</code>
	<emi>
		0000630c  0000380e  LL    0x38 (D 56)
		00006310  0000009d  PSHA
		00006314  ffea8c05  JSR   0xffffea8c (TO 0x4da4)
		00006318  00000801  ENT   0x8 (D 8)
		0000631c  00003840  SL    0x38 (D 56)
		00006320  00630803  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=2083 start=6345 end=6348>
	<code>    case S_uptime:  a = ticks; break;</code>
	<emi>
		00006324  00216c15  LG    0x216c (D 8556)
		00006328  00003840  SL    0x38 (D 56)
		0000632c  00632003  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=2084 start=6348 end=6358>
	<code>    case S_lseek:   a = lseek(a, b, c); break;</code>
	<emi>
		00006330  0000280e  LL    0x28 (D 40)
		00006334  0000009d  PSHA
		00006338  0000380e  LL    0x38 (D 56)
		0000633c  0000009d  PSHA
		00006340  0000480e  LL    0x48 (D 72)
		00006344  0000009d  PSHA
		00006348  ffcf8005  JSR   0xffffcf80 (TO 0x32cc)
		0000634c  00001801  ENT   0x18 (D 24)
		00006350  00003840  SL    0x38 (D 56)
		00006354  00632c03  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=2085 start=6358 end=6358>
	<code>//  case S_mount:   a = mount(a, b, c); break;</code>
</stmt>
<stmt file=os.c line=2086 start=6358 end=6358>
	<code>//  case S_umount:  a = umount(a); break;</code>
</stmt>
<stmt file=os.c line=2087 start=6358 end=6368>
	<code>    case S_socket:  a = socket(a, b, c); break;</code>
	<emi>
		00006358  0000280e  LL    0x28 (D 40)
		0000635c  0000009d  PSHA
		00006360  0000380e  LL    0x38 (D 56)
		00006364  0000009d  PSHA
		00006368  0000480e  LL    0x48 (D 72)
		0000636c  0000009d  PSHA
		00006370  ffeaa805  JSR   0xffffeaa8 (TO 0x4e1c)
		00006374  00001801  ENT   0x18 (D 24)
		00006378  00003840  SL    0x38 (D 56)
		0000637c  00635403  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=2088 start=6368 end=6378>
	<code>    case S_bind:    a = bind(a, b, c); break;</code>
	<emi>
		00006380  0000280e  LL    0x28 (D 40)
		00006384  0000009d  PSHA
		00006388  0000380e  LL    0x38 (D 56)
		0000638c  0000009d  PSHA
		00006390  0000480e  LL    0x48 (D 72)
		00006394  0000009d  PSHA
		00006398  ffee8c05  JSR   0xffffee8c (TO 0x5228)
		0000639c  00001801  ENT   0x18 (D 24)
		000063a0  00003840  SL    0x38 (D 56)
		000063a4  00637c03  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=2089 start=6378 end=6386>
	<code>    case S_listen:  a = listen(a, b); break;</code>
	<emi>
		000063a8  0000300e  LL    0x30 (D 48)
		000063ac  0000009d  PSHA
		000063b0  0000400e  LL    0x40 (D 64)
		000063b4  0000009d  PSHA
		000063b8  ffeefc05  JSR   0xffffeefc (TO 0x52b8)
		000063bc  00001001  ENT   0x10 (D 16)
		000063c0  00003840  SL    0x38 (D 56)
		000063c4  0063a403  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=2090 start=6386 end=6396>
	<code>    case S_poll:    a = poll(a, b, c); break;</code>
	<emi>
		000063c8  0000280e  LL    0x28 (D 40)
		000063cc  0000009d  PSHA
		000063d0  0000380e  LL    0x38 (D 56)
		000063d4  0000009d  PSHA
		000063d8  0000480e  LL    0x48 (D 72)
		000063dc  0000009d  PSHA
		000063e0  ffeb7805  JSR   0xffffeb78 (TO 0x4f5c)
		000063e4  00001801  ENT   0x18 (D 24)
		000063e8  00003840  SL    0x38 (D 56)
		000063ec  0063c403  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=2091 start=6396 end=6406>
	<code>    case S_accept:  a = accept(a, b, c); break;</code>
	<emi>
		000063f0  0000280e  LL    0x28 (D 40)
		000063f4  0000009d  PSHA
		000063f8  0000380e  LL    0x38 (D 56)
		000063fc  0000009d  PSHA
		00006400  0000480e  LL    0x48 (D 72)
		00006404  0000009d  PSHA
		00006408  ffef0805  JSR   0xffffef08 (TO 0x5314)
		0000640c  00001801  ENT   0x18 (D 24)
		00006410  00003840  SL    0x38 (D 56)
		00006414  0063ec03  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=2092 start=6406 end=6416>
	<code>    case S_connect: a = connect(a, b, c); break;</code>
	<emi>
		00006418  0000280e  LL    0x28 (D 40)
		0000641c  0000009d  PSHA
		00006420  0000380e  LL    0x38 (D 56)
		00006424  0000009d  PSHA
		00006428  0000480e  LL    0x48 (D 72)
		0000642c  0000009d  PSHA
		00006430  ffed6005  JSR   0xffffed60 (TO 0x5194)
		00006434  00001801  ENT   0x18 (D 24)
		00006438  00003840  SL    0x38 (D 56)
		0000643c  00641403  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=2093 start=6416 end=6431>
	<code>    default: printf("pid:%d name:%s unknown syscall %d\n", u->pid, u->name, a); a = -1; break;</code>
	<emi>
		00006440  0000380e  LL    0x38 (D 56)
		00006444  0000009d  PSHA
		00006448  00210015  LG    0x2100 (D 8448)
		0000644c  00007454  ADDI  0x74 (D 116)
		00006450  0000009d  PSHA
		00006454  00210015  LG    0x2100 (D 8448)
		00006458  0000181c  LX    0x18 (D 24)
		0000645c  0000009d  PSHA
		00006460  0003b208  LEAG  0x3b2 (D 946)
		00006464  0000009d  PSHA
		00006468  ff9f4c05  JSR   0xffff9f4c (TO 0x3b8)
		0000646c  00002001  ENT   0x20 (D 32)
		00006470  ffffff23  LI    0xffffffff (D -1)
		00006474  00003840  SL    0x38 (D 56)
		00006478  00643c03  JMP   <fwd>
	</emi>
</stmt>
<stmt file=os.c line=2094 start=6431 end=6431>
	<code>    }</code>
</stmt>
<stmt file=os.c line=2095 start=6431 end=6441>
	<code>    if (u->killed) exit(-1);</code>
	<emi>
		0000647c  00647803  JMP   <fwd>
		00006480  00001f3b  LBI   0x1f (D 31)
		00006484  ffffb890  BGEU  0xffffffb8 (D -72)
		00006488  0003d804  JMPI  0x3d8 (D 984)
		0000648c  00210015  LG    0x2100 (D 8448)
		00006490  00002c1c  LX    0x2c (D 44)
		00006494  00000084  BZ    <fwd>
		00006498  ffffff9e  PSHI  0xffffffff (D -1)
		0000649c  ffe40805  JSR   0xffffe408 (TO 0x48a8)
		000064a0  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=2096 start=6441 end=6442>
	<code>    return;</code>
	<emi>
		000064a4  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=2097 start=6442 end=6442>
	<code>    </code>
</stmt>
<stmt file=os.c line=2098 start=6442 end=6446>
	<code>  case FMEM:          panic("FMEM from kernel");</code>
	<emi>
		000064a8  00045408  LEAG  0x454 (D 1108)
		000064ac  0000009d  PSHA
		000064b0  ffa08005  JSR   0xffffa080 (TO 0x534)
		000064b4  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=2099 start=6446 end=6453>
	<code>  case FMEM   + USER: printf("FMEM + USER\n"); exit(-1);  // XXX psignal(SIGBUS)</code>
	<emi>
		000064b8  00046508  LEAG  0x465 (D 1125)
		000064bc  0000009d  PSHA
		000064c0  ff9ef405  JSR   0xffff9ef4 (TO 0x3b8)
		000064c4  00000801  ENT   0x8 (D 8)
		000064c8  ffffff9e  PSHI  0xffffffff (D -1)
		000064cc  ffe3d805  JSR   0xffffe3d8 (TO 0x48a8)
		000064d0  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=2100 start=6453 end=6457>
	<code>  case FPRIV:         panic("FPRIV from kernel");</code>
	<emi>
		000064d4  00047208  LEAG  0x472 (D 1138)
		000064d8  0000009d  PSHA
		000064dc  ffa05405  JSR   0xffffa054 (TO 0x534)
		000064e0  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=2101 start=6457 end=6464>
	<code>  case FPRIV  + USER: printf("FPRIV + USER\n"); exit(-1); // XXX psignal(SIGINS)</code>
	<emi>
		000064e4  00048408  LEAG  0x484 (D 1156)
		000064e8  0000009d  PSHA
		000064ec  ff9ec805  JSR   0xffff9ec8 (TO 0x3b8)
		000064f0  00000801  ENT   0x8 (D 8)
		000064f4  ffffff9e  PSHI  0xffffffff (D -1)
		000064f8  ffe3ac05  JSR   0xffffe3ac (TO 0x48a8)
		000064fc  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=2102 start=6464 end=6468>
	<code>  case FINST:         panic("FINST from kernel");</code>
	<emi>
		00006500  00049208  LEAG  0x492 (D 1170)
		00006504  0000009d  PSHA
		00006508  ffa02805  JSR   0xffffa028 (TO 0x534)
		0000650c  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=2103 start=6468 end=6475>
	<code>  case FINST  + USER: printf("FINST + USER\n"); exit(-1); // psignal(SIGINS)</code>
	<emi>
		00006510  0004a408  LEAG  0x4a4 (D 1188)
		00006514  0000009d  PSHA
		00006518  ff9e9c05  JSR   0xffff9e9c (TO 0x3b8)
		0000651c  00000801  ENT   0x8 (D 8)
		00006520  ffffff9e  PSHI  0xffffffff (D -1)
		00006524  ffe38005  JSR   0xffffe380 (TO 0x48a8)
		00006528  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=2104 start=6475 end=6479>
	<code>  case FARITH:        panic("FARITH from kernel");</code>
	<emi>
		0000652c  0004b208  LEAG  0x4b2 (D 1202)
		00006530  0000009d  PSHA
		00006534  ff9ffc05  JSR   0xffff9ffc (TO 0x534)
		00006538  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=2105 start=6479 end=6486>
	<code>  case FARITH + USER: printf("FARITH + USER\n"); exit(-1); // XXX psignal(SIGFPT)</code>
	<emi>
		0000653c  0004c508  LEAG  0x4c5 (D 1221)
		00006540  0000009d  PSHA
		00006544  ff9e7005  JSR   0xffff9e70 (TO 0x3b8)
		00006548  00000801  ENT   0x8 (D 8)
		0000654c  ffffff9e  PSHI  0xffffffff (D -1)
		00006550  ffe35405  JSR   0xffffe354 (TO 0x48a8)
		00006554  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=2106 start=6486 end=6496>
	<code>  case FIPAGE:        printf("FIPAGE from kernel [0x%x]", lvadr()); panic("!\n");</code>
	<emi>
		00006558  ff9b1005  JSR   0xffff9b10 (TO 0x6c)
		0000655c  0000009d  PSHA
		00006560  0004d408  LEAG  0x4d4 (D 1236)
		00006564  0000009d  PSHA
		00006568  ff9e4c05  JSR   0xffff9e4c (TO 0x3b8)
		0000656c  00001001  ENT   0x10 (D 16)
		00006570  0004ee08  LEAG  0x4ee (D 1262)
		00006574  0000009d  PSHA
		00006578  ff9fb805  JSR   0xffff9fb8 (TO 0x534)
		0000657c  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=2107 start=6496 end=6505>
	<code>  case FIPAGE + USER: printf("FIPAGE + USER [0x%x]", lvadr()); exit(-1); // XXX psignal(SIGSEG) or page in</code>
	<emi>
		00006580  ff9ae805  JSR   0xffff9ae8 (TO 0x6c)
		00006584  0000009d  PSHA
		00006588  0004f108  LEAG  0x4f1 (D 1265)
		0000658c  0000009d  PSHA
		00006590  ff9e2405  JSR   0xffff9e24 (TO 0x3b8)
		00006594  00001001  ENT   0x10 (D 16)
		00006598  ffffff9e  PSHI  0xffffffff (D -1)
		0000659c  ffe30805  JSR   0xffffe308 (TO 0x48a8)
		000065a0  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=2108 start=6505 end=6505>
	<code>  case FWPAGE:</code>
</stmt>
<stmt file=os.c line=2109 start=6505 end=6505>
	<code>  case FWPAGE + USER:</code>
</stmt>
<stmt file=os.c line=2110 start=6505 end=6505>
	<code>  case FRPAGE:        // XXX</code>
</stmt>
<stmt file=os.c line=2111 start=6505 end=6505>
	<code>  case FRPAGE + USER: // XXX</code>
</stmt>
<stmt file=os.c line=2112 start=6505 end=6515>
	<code>    if ((va = lvadr()) >= u->sz) exit(-1);</code>
	<emi>
		000065a4  00210015  LG    0x2100 (D 8448)
		000065a8  0000081c  LX    0x8 (D 8)
		000065ac  0000009d  PSHA
		000065b0  ff9ab805  JSR   0xffff9ab8 (TO 0x6c)
		000065b4  00000c40  SL    0xc (D 12)
		000065b8  000000a1  POPB
		000065bc  0000008d  BLTU  <fwd>
		000065c0  ffffff9e  PSHI  0xffffffff (D -1)
		000065c4  ffe2e005  JSR   0xffffe2e0 (TO 0x48a8)
		000065c8  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=2113 start=6515 end=6518>
	<code>    pc--; // printf("fault"); // restart instruction</code>
	<emi>
		000065cc  0000480e  LL    0x48 (D 72)
		000065d0  00000457  SUBI  0x4 (D 4)
		000065d4  00004840  SL    0x48 (D 72)
	</emi>
</stmt>
<stmt file=os.c line=2114 start=6518 end=6537>
	<code>    mappage(u->pdir, va & -PAGE, V2P+(memset(kalloc(), 0, PAGE)), PTE_P | PTE_W | PTE_U);</code>
	<emi>
		000065d8  0000079e  PSHI  0x7 (D 7)
		000065dc  0010009e  PSHI  0x1000 (D 4096)
		000065e0  0000009e  PSHI  0x0 (D 0)
		000065e4  ff9c0405  JSR   0xffff9c04 (TO 0x1ec)
		000065e8  0000009d  PSHA
		000065ec  ff9a2805  JSR   0xffff9a28 (TO 0x18)
		000065f0  00001801  ENT   0x18 (D 24)
		000065f4  0000403b  LBI   0x40 (D 64)
		000065f8  0000003c  LBHI  0x0 (D 0)
		000065fc  00000053  ADD 
		00006600  0000009d  PSHA
		00006604  0000140e  LL    0x14 (D 20)
		00006608  fff00069  ANDI  0xfffff000 (D -4096)
		0000660c  0000009d  PSHA
		00006610  00210015  LG    0x2100 (D 8448)
		00006614  00000c1c  LX    0xc (D 12)
		00006618  0000009d  PSHA
		0000661c  fff37405  JSR   0xfffff374 (TO 0x5994)
		00006620  00002001  ENT   0x20 (D 32)
	</emi>
</stmt>
<stmt file=os.c line=2115 start=6537 end=6538>
	<code>    return;</code>
	<emi>
		00006624  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=2116 start=6538 end=6538>
	<code></code>
</stmt>
<stmt file=os.c line=2117 start=6538 end=6538>
	<code>  case FTIMER: </code>
</stmt>
<stmt file=os.c line=2118 start=6538 end=6538>
	<code>  case FTIMER + USER: </code>
</stmt>
<stmt file=os.c line=2119 start=6538 end=6541>
	<code>    ticks++;</code>
	<emi>
		00006628  00216c15  LG    0x216c (D 8556)
		0000662c  ffffff57  SUBI  0xffffffff (D -1)
		00006630  00216c45  SG    0x216c (D 8556)
	</emi>
</stmt>
<stmt file=os.c line=2120 start=6541 end=6545>
	<code>    wakeup(&ticks);</code>
	<emi>
		00006634  00216c08  LEAG  0x216c (D 8556)
		00006638  0000009d  PSHA
		0000663c  ffee3805  JSR   0xffffee38 (TO 0x5478)
		00006640  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=2121 start=6545 end=6545>
	<code></code>
</stmt>
<stmt file=os.c line=2122 start=6545 end=6545>
	<code>    // force process exit if it has been killed and is in user space</code>
</stmt>
<stmt file=os.c line=2123 start=6545 end=6554>
	<code>    if (u->killed && (fc & USER)) exit(-1);</code>
	<emi>
		00006644  00210015  LG    0x2100 (D 8448)
		00006648  00002c1c  LX    0x2c (D 44)
		0000664c  00000084  BZ    <fwd>
		00006650  0000400e  LL    0x40 (D 64)
		00006654  00001069  ANDI  0x10 (D 16)
		00006658  00664c84  BZ    <fwd>
		0000665c  ffffff9e  PSHI  0xffffffff (D -1)
		00006660  ffe24405  JSR   0xffffe244 (TO 0x48a8)
		00006664  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=2124 start=6554 end=6554>
	<code> </code>
</stmt>
<stmt file=os.c line=2125 start=6554 end=6554>
	<code>    // force process to give up CPU on clock tick</code>
</stmt>
<stmt file=os.c line=2126 start=6554 end=6572>
	<code>    if (u->state != RUNNING) { printf("pid=%d state=%d\n", u->pid, u->state); panic("!\n"); }        </code>
	<emi>
		00006668  00210015  LG    0x2100 (D 8448)
		0000666c  0000141c  LX    0x14 (D 20)
		00006670  0000043b  LBI   0x4 (D 4)
		00006674  00000088  BE    <fwd>
		00006678  00210015  LG    0x2100 (D 8448)
		0000667c  0000141c  LX    0x14 (D 20)
		00006680  0000009d  PSHA
		00006684  00210015  LG    0x2100 (D 8448)
		00006688  0000181c  LX    0x18 (D 24)
		0000668c  0000009d  PSHA
		00006690  00050608  LEAG  0x506 (D 1286)
		00006694  0000009d  PSHA
		00006698  ff9d1c05  JSR   0xffff9d1c (TO 0x3b8)
		0000669c  00001801  ENT   0x18 (D 24)
		000066a0  00051708  LEAG  0x517 (D 1303)
		000066a4  0000009d  PSHA
		000066a8  ff9e8805  JSR   0xffff9e88 (TO 0x534)
		000066ac  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=2127 start=6572 end=6577>
	<code>    u->state = RUNNABLE;</code>
	<emi>
		000066b0  00210015  LG    0x2100 (D 8448)
		000066b4  00001454  ADDI  0x14 (D 20)
		000066b8  0000003e  LBA 
		000066bc  00000323  LI    0x3 (D 3)
		000066c0  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=2128 start=6577 end=6578>
	<code>    sched();</code>
	<emi>
		000066c4  fff90005  JSR   0xfffff900 (TO 0x5fc8)
	</emi>
</stmt>
<stmt file=os.c line=2129 start=6578 end=6578>
	<code></code>
</stmt>
<stmt file=os.c line=2130 start=6578 end=6587>
	<code>    if (u->killed && (fc & USER)) exit(-1);</code>
	<emi>
		000066c8  00210015  LG    0x2100 (D 8448)
		000066cc  00002c1c  LX    0x2c (D 44)
		000066d0  00000084  BZ    <fwd>
		000066d4  0000400e  LL    0x40 (D 64)
		000066d8  00001069  ANDI  0x10 (D 16)
		000066dc  0066d084  BZ    <fwd>
		000066e0  ffffff9e  PSHI  0xffffffff (D -1)
		000066e4  ffe1c005  JSR   0xffffe1c0 (TO 0x48a8)
		000066e8  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=2131 start=6587 end=6588>
	<code>    return;</code>
	<emi>
		000066ec  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=2132 start=6588 end=6588>
	<code>    </code>
</stmt>
<stmt file=os.c line=2133 start=6588 end=6588>
	<code>  case FKEYBD:</code>
</stmt>
<stmt file=os.c line=2134 start=6588 end=6588>
	<code>  case FKEYBD + USER:</code>
</stmt>
<stmt file=os.c line=2135 start=6588 end=6589>
	<code>    consoleintr();</code>
	<emi>
		000066f0  ff9efc05  JSR   0xffff9efc (TO 0x5f0)
	</emi>
</stmt>
<stmt file=os.c line=2136 start=6589 end=6590>
	<code>    return; //??XXX postkill?</code>
	<emi>
		000066f4  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=2137 start=6590 end=6590>
	<code>  }</code>
</stmt>
<stmt file=os.c line=2138 start=6590 end=6594>
	<code>}</code>
	<emi>
		000066f8  00000003  JMP   <fwd>
		000066fc  00001a3b  LBI   0x1a (D 26)
		00006700  0066f890  BGEU  <fwd>
		00006704  00051c04  JMPI  0x51c (D 1308)
	</emi>
</stmt>
<stmt file=os.c line=2139 start=6594 end=6594>
	<code></code>
</stmt>
<stmt file=os.c line=2140 start=6594 end=6595>
	<code>alltraps()</code>
	<emi>
		00006708  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=2141 start=6595 end=6595>
	<code>{</code>
</stmt>
<stmt file=os.c line=2142 start=6595 end=6596>
	<code>  asm(PSHA);</code>
	<emi>
		0000670c  0000009d  PSHA
	</emi>
</stmt>
<stmt file=os.c line=2143 start=6596 end=6597>
	<code>  asm(PSHB);</code>
	<emi>
		00006710  000000a0  PSHB
	</emi>
</stmt>
<stmt file=os.c line=2144 start=6597 end=6598>
	<code>  asm(PSHC);</code>
	<emi>
		00006714  000000ae  PSHC
	</emi>
</stmt>
<stmt file=os.c line=2145 start=6598 end=6599>
	<code>  asm(PSHF);</code>
	<emi>
		00006718  0000009f  PSHF
	</emi>
</stmt>
<stmt file=os.c line=2146 start=6599 end=6600>
	<code>  asm(PSHG);</code>
	<emi>
		0000671c  000000b1  PSHG
	</emi>
</stmt>
<stmt file=os.c line=2147 start=6600 end=6602>
	<code>  asm(LUSP); asm(PSHA);</code>
	<emi>
		00006720  000000aa  LUSP
		00006724  0000009d  PSHA
	</emi>
</stmt>
<stmt file=os.c line=2148 start=6602 end=6603>
	<code>  trap();                // registers passed back out by magic reference :^O</code>
	<emi>
		00006728  fff96805  JSR   0xfffff968 (TO 0x6094)
	</emi>
</stmt>
<stmt file=os.c line=2149 start=6603 end=6605>
	<code>  asm(POPA); asm(SUSP);</code>
	<emi>
		0000672c  000000a3  POPA
		00006730  000000ab  SUSP
	</emi>
</stmt>
<stmt file=os.c line=2150 start=6605 end=6606>
	<code>  asm(POPG);</code>
	<emi>
		00006734  000000b2  POPG
	</emi>
</stmt>
<stmt file=os.c line=2151 start=6606 end=6607>
	<code>  asm(POPF);</code>
	<emi>
		00006738  000000a2  POPF
	</emi>
</stmt>
<stmt file=os.c line=2152 start=6607 end=6608>
	<code>  asm(POPC);</code>
	<emi>
		0000673c  000000af  POPC
	</emi>
</stmt>
<stmt file=os.c line=2153 start=6608 end=6609>
	<code>  asm(POPB);</code>
	<emi>
		00006740  000000a1  POPB
	</emi>
</stmt>
<stmt file=os.c line=2154 start=6609 end=6610>
	<code>  asm(POPA);</code>
	<emi>
		00006744  000000a3  POPA
	</emi>
</stmt>
<stmt file=os.c line=2155 start=6610 end=6611>
	<code>  asm(RTI);</code>
	<emi>
		00006748  00000098  RTI 
	</emi>
</stmt>
<stmt file=os.c line=2156 start=6611 end=6611>
	<code>}</code>
</stmt>
<stmt file=os.c line=2157 start=6611 end=6611>
	<code></code>
</stmt>
<stmt file=os.c line=2158 start=6611 end=6612>
	<code>mainc()</code>
	<emi>
		0000674c  00000002  LEV   0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=2159 start=6612 end=6612>
	<code>{</code>
</stmt>
<stmt file=os.c line=2160 start=6612 end=6615>
	<code>  kpdir[0] = 0;          // don't need low map anymore</code>
	<emi>
		00006750  00000023  LI    0x0 (D 0)
		00006754  0021682d  LBG   0x2168 (D 8552)
		00006758  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=2161 start=6615 end=6616>
	<code>  consoleinit();         // console device</code>
	<emi>
		0000675c  ffa0b405  JSR   0xffffa0b4 (TO 0x814)
	</emi>
</stmt>
<stmt file=os.c line=2162 start=6616 end=6620>
	<code>  ivec(alltraps);        // trap vector</code>
	<emi>
		00006760  ffffa808  LEAG  0xffffffa8 (D -88)
		00006764  0000009d  PSHA
		00006768  ff98f405  JSR   0xffff98f4 (TO 0x60)
		0000676c  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=2163 start=6620 end=6621>
	<code>  binit();               // buffer cache</code>
	<emi>
		00006770  ffa1d405  JSR   0xffffa1d4 (TO 0x948)
	</emi>
</stmt>
<stmt file=os.c line=2164 start=6621 end=6622>
	<code>  ideinit();             // disk</code>
	<emi>
		00006774  ffa0b005  JSR   0xffffa0b0 (TO 0x828)
	</emi>
</stmt>
<stmt file=os.c line=2165 start=6622 end=6625>
	<code>  stmr(128*1024);        // set timer</code>
	<emi>
		00006778  0200009e  PSHI  0x20000 (D 131072)
		0000677c  ff98fc05  JSR   0xffff98fc (TO 0x7c)
		00006780  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=2166 start=6625 end=6626>
	<code>  userinit();            // first user process</code>
	<emi>
		00006784  ffef4805  JSR   0xffffef48 (TO 0x56d0)
	</emi>
</stmt>
<stmt file=os.c line=2167 start=6626 end=6630>
	<code>  printf("Welcome!\n");</code>
	<emi>
		00006788  00058408  LEAG  0x584 (D 1412)
		0000678c  0000009d  PSHA
		00006790  ff9c2405  JSR   0xffff9c24 (TO 0x3b8)
		00006794  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=2168 start=6630 end=6631>
	<code>  scheduler();           // start running processes</code>
	<emi>
		00006798  fff70c05  JSR   0xfffff70c (TO 0x5ea8)
	</emi>
</stmt>
<stmt file=os.c line=2169 start=6631 end=6631>
	<code>}</code>
</stmt>
<stmt file=os.c line=2170 start=6631 end=6631>
	<code></code>
</stmt>
<stmt file=os.c line=2171 start=6631 end=6632>
	<code>main()</code>
	<emi>
		0000679c  00000002  LEV   0x0 (D 0)
	</emi>
</stmt>
<stmt file=os.c line=2172 start=6632 end=6632>
	<code>{</code>
</stmt>
<stmt file=os.c line=2173 start=6632 end=6632>
	<code>  int *ksp;              // temp kernel stack pointer</code>
</stmt>
<stmt file=os.c line=2174 start=6632 end=6632>
	<code>  static char kstack[256]; // temp kernel stack</code>
</stmt>
<stmt file=os.c line=2175 start=6632 end=6632>
	<code>  static int endbss;     // last variable in bss segment</code>
</stmt>
<stmt file=os.c line=2176 start=6632 end=6632>
	<code>    </code>
</stmt>
<stmt file=os.c line=2177 start=6632 end=6632>
	<code>  // initialize memory allocation</code>
</stmt>
<stmt file=os.c line=2178 start=6632 end=6637>
	<code>  mem_top = kreserved = ((uint)&endbss + PAGE + 3) & -PAGE; </code>
	<emi>
		000067a0  fffff801  ENT   0xfffffff8 (D -8)
		000067a4  0348ef08  LEAG  0x348ef (D 215279)
		000067a8  fff00069  ANDI  0xfffff000 (D -4096)
		000067ac  00211445  SG    0x2114 (D 8468)
		000067b0  00210c45  SG    0x210c (D 8460)
	</emi>
</stmt>
<stmt file=os.c line=2179 start=6637 end=6639>
	<code>  mem_sz = msiz();</code>
	<emi>
		000067b4  ff98bc05  JSR   0xffff98bc (TO 0x74)
		000067b8  00211045  SG    0x2110 (D 8464)
	</emi>
</stmt>
<stmt file=os.c line=2180 start=6639 end=6639>
	<code>  </code>
</stmt>
<stmt file=os.c line=2181 start=6639 end=6639>
	<code>  // initialize kernel page table</code>
</stmt>
<stmt file=os.c line=2182 start=6639 end=6640>
	<code>  setupkvm();</code>
	<emi>
		000067bc  fff07805  JSR   0xfffff078 (TO 0x5838)
	</emi>
</stmt>
<stmt file=os.c line=2183 start=6640 end=6644>
	<code>  kpdir[0] = kpdir[(uint)USERTOP >> 22]; // need a 1:1 map of low physical memory for awhile</code>
	<emi>
		000067c0  00216815  LG    0x2168 (D 8552)
		000067c4  000c001c  LX    0xc00 (D 3072)
		000067c8  0021682d  LBG   0x2168 (D 8552)
		000067cc  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=2184 start=6644 end=6644>
	<code></code>
</stmt>
<stmt file=os.c line=2185 start=6644 end=6644>
	<code>  // initialize kernel stack pointer</code>
</stmt>
<stmt file=os.c line=2186 start=6644 end=6647>
	<code>  ksp = ((uint)kstack + sizeof(kstack) - 8) & -8;</code>
	<emi>
		000067d0  0338e408  LEAG  0x338e4 (D 211172)
		000067d4  fffff869  ANDI  0xfffffff8 (D -8)
		000067d8  00000440  SL    0x4 (D 4)
	</emi>
</stmt>
<stmt file=os.c line=2187 start=6647 end=6648>
	<code>  asm(LL, 4);</code>
	<emi>
		000067dc  0000040e  LL    0x4 (D 4)
	</emi>
</stmt>
<stmt file=os.c line=2188 start=6648 end=6649>
	<code>  asm(SSP);</code>
	<emi>
		000067e0  0000009c  SSP 
	</emi>
</stmt>
<stmt file=os.c line=2189 start=6649 end=6649>
	<code></code>
</stmt>
<stmt file=os.c line=2190 start=6649 end=6649>
	<code>  // turn on paging</code>
</stmt>
<stmt file=os.c line=2191 start=6649 end=6653>
	<code>  pdir(kpdir);</code>
	<emi>
		000067e4  00216815  LG    0x2168 (D 8552)
		000067e8  0000009d  PSHA
		000067ec  ff989805  JSR   0xffff9898 (TO 0x88)
		000067f0  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=2192 start=6653 end=6656>
	<code>  spage(1);</code>
	<emi>
		000067f4  0000019e  PSHI  0x1 (D 1)
		000067f8  ff989805  JSR   0xffff9898 (TO 0x94)
		000067fc  00000801  ENT   0x8 (D 8)
	</emi>
</stmt>
<stmt file=os.c line=2193 start=6656 end=6661>
	<code>  kpdir = P2V+(uint)kpdir;</code>
	<emi>
		00006800  00216815  LG    0x2168 (D 8552)
		00006804  ffffc03b  LBI   0xffffffc0 (D -64)
		00006808  0000003c  LBHI  0x0 (D 0)
		0000680c  00000053  ADD 
		00006810  00216845  SG    0x2168 (D 8552)
	</emi>
</stmt>
<stmt file=os.c line=2194 start=6661 end=6666>
	<code>  mem_top = P2V+mem_top;</code>
	<emi>
		00006814  00210c15  LG    0x210c (D 8460)
		00006818  ffffc03b  LBI   0xffffffc0 (D -64)
		0000681c  0000003c  LBHI  0x0 (D 0)
		00006820  00000053  ADD 
		00006824  00210c45  SG    0x210c (D 8460)
	</emi>
</stmt>
<stmt file=os.c line=2195 start=6666 end=6666>
	<code></code>
</stmt>
<stmt file=os.c line=2196 start=6666 end=6666>
	<code>  // jump (via return) to high memory</code>
</stmt>
<stmt file=os.c line=2197 start=6666 end=6672>
	<code>  ksp = P2V+(((uint)kstack + sizeof(kstack) - 8) & -8);</code>
	<emi>
		00006828  0338e408  LEAG  0x338e4 (D 211172)
		0000682c  fffff869  ANDI  0xfffffff8 (D -8)
		00006830  ffffc03b  LBI   0xffffffc0 (D -64)
		00006834  0000003c  LBHI  0x0 (D 0)
		00006838  00000053  ADD 
		0000683c  00000440  SL    0x4 (D 4)
	</emi>
</stmt>
<stmt file=os.c line=2198 start=6672 end=6678>
	<code>  *ksp = P2V+(uint)mainc;</code>
	<emi>
		00006840  ffff0c08  LEAG  0xffffff0c (D -244)
		00006844  ffffc03b  LBI   0xffffffc0 (D -64)
		00006848  0000003c  LBHI  0x0 (D 0)
		0000684c  00000053  ADD 
		00006850  00000426  LBL   0x4 (D 4)
		00006854  0000004a  SX  
	</emi>
</stmt>
<stmt file=os.c line=2199 start=6678 end=6679>
	<code>  asm(LL, 4);</code>
	<emi>
		00006858  0000040e  LL    0x4 (D 4)
	</emi>
</stmt>
<stmt file=os.c line=2200 start=6679 end=6680>
	<code>  asm(SSP);</code>
	<emi>
		0000685c  0000009c  SSP 
	</emi>
</stmt>
<stmt file=os.c line=2201 start=6680 end=6681>
	<code>  asm(LEV);</code>
	<emi>
		00006860  00000002  LEV 
	</emi>
</stmt>
<stmt file=os.c line=2202 start=6681 end=6681>
	<code>}</code>
</stmt>
<stmt file=os.c line=2203 start=6681 end=6682>
	<code></code>
	<emi>
		00006864  00000802  LEV   0x8 (D 8)
	</emi>
</stmt>
