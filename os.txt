os.c  1: // os.c - based on xv6 with heavy modifications
os.c  2: #include <u.h>
root/lib/u.h  1: // u.h
root/lib/u.h  2: 
root/lib/u.h  3: // instruction set
root/lib/u.h  4: enum {
root/lib/u.h  5:   HALT,ENT ,LEV ,JMP ,JMPI,JSR ,JSRA,LEA ,LEAG,CYC ,MCPY,MCMP,MCHR,MSET, // system
root/lib/u.h  6:   LL  ,LLS ,LLH ,LLC ,LLB ,LLD ,LLF ,LG  ,LGS ,LGH ,LGC ,LGB ,LGD ,LGF , // load a
root/lib/u.h  7:   LX  ,LXS ,LXH ,LXC ,LXB ,LXD ,LXF ,LI  ,LHI ,LIF ,
root/lib/u.h  8:   LBL ,LBLS,LBLH,LBLC,LBLB,LBLD,LBLF,LBG ,LBGS,LBGH,LBGC,LBGB,LBGD,LBGF, // load b
root/lib/u.h  9:   LBX ,LBXS,LBXH,LBXC,LBXB,LBXD,LBXF,LBI ,LBHI,LBIF,LBA ,LBAD,
root/lib/u.h  10:   SL  ,SLH ,SLB ,SLD ,SLF ,SG  ,SGH ,SGB ,SGD ,SGF ,                     // store
root/lib/u.h  11:   SX  ,SXH ,SXB ,SXD ,SXF ,
root/lib/u.h  12:   ADDF,SUBF,MULF,DIVF,                                                   // arithmetic
root/lib/u.h  13:   ADD ,ADDI,ADDL,SUB ,SUBI,SUBL,MUL ,MULI,MULL,DIV ,DIVI,DIVL,
root/lib/u.h  14:   DVU ,DVUI,DVUL,MOD ,MODI,MODL,MDU ,MDUI,MDUL,AND ,ANDI,ANDL,
root/lib/u.h  15:   OR  ,ORI ,ORL ,XOR ,XORI,XORL,SHL ,SHLI,SHLL,SHR ,SHRI,SHRL,
root/lib/u.h  16:   SRU ,SRUI,SRUL,EQ  ,EQF ,NE  ,NEF ,LT  ,LTU ,LTF ,GE  ,GEU ,GEF ,      // logical
root/lib/u.h  17:   BZ  ,BZF ,BNZ ,BNZF,BE  ,BEF ,BNE ,BNEF,BLT ,BLTU,BLTF,BGE ,BGEU,BGEF, // conditional
root/lib/u.h  18:   CID ,CUD ,CDI ,CDU ,                                                   // conversion
root/lib/u.h  19:   CLI ,STI ,RTI ,BIN ,BOUT,NOP ,SSP ,PSHA,PSHI,PSHF,PSHB,POPB,POPF,POPA, // misc
root/lib/u.h  20:   IVEC,PDIR,SPAG,TIME,LVAD,TRAP,LUSP,SUSP,LCL ,LCA ,PSHC,POPC,MSIZ,
root/lib/u.h  21:   PSHG,POPG,NET1,NET2,NET3,NET4,NET5,NET6,NET7,NET8,NET9,
root/lib/u.h  22:   POW ,ATN2,FABS,ATAN,LOG ,LOGT,EXP ,FLOR,CEIL,HYPO,SIN ,COS ,TAN ,ASIN, // math
root/lib/u.h  23:   ACOS,SINH,COSH,TANH,SQRT,FMOD,
root/lib/u.h  24:   IDLE
root/lib/u.h  25: };
root/lib/u.h  26: 
root/lib/u.h  27: // system calls
root/lib/u.h  28: enum {
root/lib/u.h  29:   S_fork=1, S_exit,   S_wait,   S_pipe,   S_write,  S_read,   S_close,  S_kill,
root/lib/u.h  30:   S_exec,   S_open,   S_mknod,  S_unlink, S_fstat,  S_link,   S_mkdir,  S_chdir,
root/lib/u.h  31:   S_dup2,   S_getpid, S_sbrk,   S_sleep,  S_uptime, S_lseek,  S_mount,  S_umount,
root/lib/u.h  32:   S_socket, S_bind,   S_listen, S_poll,   S_accept, S_connect, 
root/lib/u.h  33: };
root/lib/u.h  34: 
root/lib/u.h  35: typedef unsigned char uchar;
root/lib/u.h  36: typedef unsigned short ushort;
root/lib/u.h  37: typedef unsigned int uint;
root/lib/u.h  38: 
os.c  3: 
os.c  4: enum {
os.c  5:   PAGE    = 4096,       // page size
os.c  6:   NPROC   = 64,         // maximum number of processes
os.c  7:   NOFILE  = 16,         // open files per process
os.c  8:   NFILE   = 100,        // open files per system
os.c  9:   NBUF    = 10,         // size of disk block cache
os.c  10:   NINODE  = 50,         // maximum number of active i-nodes  XXX make this more dynamic ... 
os.c  11:   NDEV    = 10,         // maximum major device number
os.c  12:   USERTOP = 0xc0000000, // end of user address space
os.c  13:   P2V     = +USERTOP,   // turn a physical address into a virtual address
os.c  14:   V2P     = -USERTOP,   // turn a virtual address into a physical address
os.c  15:   FSSIZE  = PAGE*1024,  // XXX
os.c  16:   MAXARG  = 256,        // max exec arguments
os.c  17:   STACKSZ = 0x800000,   // user stack size (8MB)
os.c  18: };
os.c  19: 
os.c  20: enum { // page table entry flags   XXX refactor vs. i386
os.c  21:   PTE_P = 0x001, // present
os.c  22:   PTE_W = 0x002, // writeable
os.c  23:   PTE_U = 0x004, // user
os.c  24:   PTE_A = 0x020, // accessed
os.c  25:   PTE_D = 0x040, // dirty
os.c  26: };
os.c  27: 
os.c  28: enum { // processor fault codes
os.c  29:   FMEM,   // bad physical address
os.c  30:   FTIMER, // timer interrupt
os.c  31:   FKEYBD, // keyboard interrupt
os.c  32:   FPRIV,  // privileged instruction
os.c  33:   FINST,  // illegal instruction
os.c  34:   FSYS,   // software trap
os.c  35:   FARITH, // arithmetic trap
os.c  36:   FIPAGE, // page fault on opcode fetch
os.c  37:   FWPAGE, // page fault on write
os.c  38:   FRPAGE, // page fault on read
os.c  39:   USER=16 // user mode exception
os.c  40: };
os.c  41: 
os.c  42: struct trapframe { // layout of the trap frame built on the stack by trap handler
os.c  43:   int sp, pad1;
os.c  44:   double g, f;
os.c  45:   int c,  pad2;
os.c  46:   int b,  pad3;
os.c  47:   int a,  pad4;
os.c  48:   int fc, pad5;
os.c  49:   int pc, pad6;
os.c  50: };
os.c  51: 
os.c  52: struct buf {
os.c  53:   int flags;
os.c  54:   uint sector;
os.c  55:   struct buf *prev;      // LRU cache list
os.c  56:   struct buf *next;
os.c  57: //  struct buf *qnext;     // disk queue XXX
os.c  58:   uchar *data;
os.c  59: };
os.c  60: enum { B_BUSY  = 1,      // buffer is locked by some process
os.c  61:        B_VALID = 2,      // buffer has been read from disk
os.c  62:        B_DIRTY = 4};     // buffer needs to be written to disk
os.c  63: enum { S_IFIFO = 0x1000, // fifo
os.c  64:        S_IFCHR = 0x2000, // character
os.c  65:        S_IFBLK = 0x3000, // block
os.c  66:        S_IFDIR = 0x4000, // directory
os.c  67:        S_IFREG = 0x8000, // regular
os.c  68:        S_IFMT  = 0xF000 }; // file type mask
os.c  69: enum { O_RDONLY, O_WRONLY, O_RDWR, O_CREAT = 0x100, O_TRUNC = 0x200 };
os.c  70: enum { SEEK_SET, SEEK_CUR, SEEK_END };
os.c  71: 
os.c  72: struct stat {
os.c  73:   ushort st_dev;         // device number
os.c  74:   ushort st_mode;        // type of file
os.c  75:   uint   st_ino;         // inode number on device
os.c  76:   uint   st_nlink;       // number of links to file
os.c  77:   uint   st_size;        // size of file in bytes
os.c  78: };
os.c  79: 
os.c  80: // disk file system format
os.c  81: enum {
os.c  82:   ROOTINO  = 16,         // root i-number
os.c  83:   NDIR     = 480,
os.c  84:   NIDIR    = 512,
os.c  85:   NIIDIR   = 8,
os.c  86:   NIIIDIR  = 4,
os.c  87:   DIRSIZ   = 252,
os.c  88:   PIPESIZE = 4000,       // XXX up to a page (since pipe is a page)
os.c  89: };
os.c  90: 
os.c  91: struct dinode { // on-disk inode structure
os.c  92:   ushort mode;           // file mode
os.c  93:   uint nlink;            // number of links to inode in file system
os.c  94:   uint size;             // size of file
os.c  95:   uint pad[17];
os.c  96:   uint dir[NDIR];        // data block addresses
os.c  97:   uint idir[NIDIR];
os.c  98:   uint iidir[NIIDIR];    // XXX not implemented
os.c  99:   uint iiidir[NIIIDIR];  // XXX not implemented
os.c  100: };
os.c  101: 
os.c  102: struct direct { // directory is a file containing a sequence of direct structures.
os.c  103:   uint d_ino;
os.c  104:   char d_name[DIRSIZ];
os.c  105: };
os.c  106: 
os.c  107: struct pipe {
os.c  108:   char data[PIPESIZE];
os.c  109:   uint nread;            // number of bytes read
os.c  110:   uint nwrite;           // number of bytes written
os.c  111:   int readopen;          // read fd is still open
os.c  112:   int writeopen;         // write fd is still open
os.c  113: };
os.c  114: 
os.c  115: struct inode { // in-memory copy of an inode
os.c  116:   uint inum;             // inode number
os.c  117:   int ref;               // reference count
os.c  118:   int flags;             // I_BUSY, I_VALID
os.c  119:   ushort mode;           // copy of disk inode
os.c  120:   uint nlink;
os.c  121:   uint size;
os.c  122:   uint dir[NDIR];
os.c  123:   uint idir[NIDIR];
os.c  124: };
os.c  125: 
os.c  126: enum { FD_NONE, FD_PIPE, FD_INODE, FD_SOCKET, FD_RFS };
os.c  127: struct file {
os.c  128:   int type;
os.c  129:   int ref;
os.c  130:   char readable;
os.c  131:   char writable;
os.c  132:   struct pipe *pipe;     // XXX make vnode
os.c  133:   struct inode *ip;
os.c  134:   uint off;
os.c  135: };
os.c  136: 
os.c  137: enum { I_BUSY = 1, I_VALID = 2 };
os.c  138: enum { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
os.c  139: 
os.c  140: struct proc { // per-process state
os.c  141:   struct proc *next;
os.c  142:   struct proc *prev;
os.c  143:   uint sz;               // size of process memory (bytes)
os.c  144:   uint *pdir;            // page directory
os.c  145:   char *kstack;          // bottom of kernel stack for this process
os.c  146:   int state;             // process state
os.c  147:   int pid;               // process ID
os.c  148:   struct proc *parent;   // parent process
os.c  149:   struct trapframe *tf;  // trap frame for current syscall
os.c  150:   int context;           // swtch() here to run process
os.c  151:   void *chan;            // if non-zero, sleeping on chan
os.c  152:   int killed;            // if non-zero, have been killed
os.c  153:   struct file *ofile[NOFILE]; // open files
os.c  154:   struct inode *cwd;     // current directory
os.c  155:   char name[16];         // process name (debugging)
os.c  156: };
os.c  157: 
os.c  158: struct devsw { // device implementations XXX redesign
os.c  159:   int (*read)();
os.c  160:   int (*write)();
os.c  161: };
os.c  162: 
os.c  163: enum { CONSOLE = 1 }; // XXX ditch..
os.c  164: 
os.c  165: enum { INPUT_BUF = 128 };
os.c  166: struct input_s {
os.c  167:   char buf[INPUT_BUF];
os.c  168:   uint r;  // read index
os.c  169:   uint w;  // write index
os.c  170: };
os.c  171: 
os.c  172: enum { PF_INET = 2, AF_INET = 2, SOCK_STREAM = 1, INADDR_ANY = 0 }; // XXX keep or chuck these?
os.c  173: 
os.c  174: // *** Globals ***
os.c  175: 
os.c  176: struct proc proc[NPROC];
os.c  177: struct proc *u;          // current process
os.c  178: struct proc *init;
os.c  179: char *mem_free;          // memory free list
os.c  180: char *mem_top;           // current top of unused memory
os.c  181: uint mem_sz;             // size of physical memory
os.c  182: uint kreserved;          // start of kernel reserved memory heap
os.c  183: struct devsw devsw[NDEV];
os.c  184: uint *kpdir;             // kernel page directory
os.c  185: uint ticks;
os.c  186: char *memdisk;
os.c  187: struct input_s input;    // XXX do this some other way?
os.c  188: struct buf bcache[NBUF];
os.c  189: struct buf bfreelist;    // linked list of all buffers, through prev/next.   bfreelist.next is most recently used
os.c  190: struct inode inode[NINODE]; // inode cache XXX make dynamic and eventually power of 2, look into iget()
os.c  191: struct file file[NFILE];
os.c  192: int nextpid;
os.c  193: 
os.c  194: rfsd = -1; // XXX will be set on mount, XXX total redesign?
os.c  195: 
os.c  196: // *** Code ***
os.c  197: 
os.c  198: void *memcpy(void *d, void *s, uint n) { asm(LL,8); asm(LBL, 16); asm(LCL,24); asm(MCPY); asm(LL,8); }
00000000  0000080e  LL    0x8 (D 8)
00000004  00001026  LBL   0x10 (D 16)
00000008  000018ac  LCL   0x18 (D 24)
0000000c  0000000a  MCPY
00000010  0000080e  LL    0x8 (D 8)
os.c  199: void *memset(void *d, uint c,  uint n) { asm(LL,8); asm(LBLB,16); asm(LCL,24); asm(MSET); asm(LL,8); }
00000014  00000002  LEV   0x0 (D 0)
00000018  0000080e  LL    0x8 (D 8)
0000001c  0000102a  LBLB  0x10 (D 16)
00000020  000018ac  LCL   0x18 (D 24)
00000024  0000000d  MSET
00000028  0000080e  LL    0x8 (D 8)
os.c  200: void *memchr(void *s, uint c,  uint n) { asm(LL,8); asm(LBLB,16); asm(LCL,24); asm(MCHR); }
0000002c  00000002  LEV   0x0 (D 0)
00000030  0000080e  LL    0x8 (D 8)
00000034  0000102a  LBLB  0x10 (D 16)
00000038  000018ac  LCL   0x18 (D 24)
0000003c  0000000c  MCHR
os.c  201: 
os.c  202: int in(port)    { asm(LL,8); asm(BIN); }
00000040  00000002  LEV   0x0 (D 0)
00000044  0000080e  LL    0x8 (D 8)
00000048  00000099  BIN 
os.c  203: out(port, val)  { asm(LL,8); asm(LBL,16); asm(BOUT); }
0000004c  00000002  LEV   0x0 (D 0)
00000050  0000080e  LL    0x8 (D 8)
00000054  00001026  LBL   0x10 (D 16)
00000058  0000009a  BOUT
os.c  204: ivec(void *isr) { asm(LL,8); asm(IVEC); }
0000005c  00000002  LEV   0x0 (D 0)
00000060  0000080e  LL    0x8 (D 8)
00000064  000000a4  IVEC
os.c  205: lvadr()         { asm(LVAD); }
00000068  00000002  LEV   0x0 (D 0)
0000006c  000000a8  LVAD
os.c  206: uint msiz()     { asm(MSIZ); }
00000070  00000002  LEV   0x0 (D 0)
00000074  000000b0  MSIZ
os.c  207: stmr(val)       { asm(LL,8); asm(TIME); }
00000078  00000002  LEV   0x0 (D 0)
0000007c  0000080e  LL    0x8 (D 8)
00000080  000000a7  TIME
os.c  208: pdir(val)       { asm(LL,8); asm(PDIR); }
00000084  00000002  LEV   0x0 (D 0)
00000088  0000080e  LL    0x8 (D 8)
0000008c  000000a5  PDIR
os.c  209: spage(val)      { asm(LL,8); asm(SPAG); }
00000090  00000002  LEV   0x0 (D 0)
00000094  0000080e  LL    0x8 (D 8)
00000098  000000a6  SPAG
os.c  210: splhi()         { asm(CLI); }
0000009c  00000002  LEV   0x0 (D 0)
000000a0  00000096  CLI 
os.c  211: splx(int e)     { if (e) asm(STI); }
000000a4  00000002  LEV   0x0 (D 0)
000000a8  0000080e  LL    0x8 (D 8)
000000ac  00000084  BZ    <fwd>
000000b0  00000097  STI 
os.c  212: 
os.c  213: int strlen(void *s) { return memchr(s, 0, -1) - s; }
000000b4  00000002  LEV   0x0 (D 0)
000000b8  ffffff9e  PSHI  0xffffffff (D -1)
000000bc  0000009e  PSHI  0x0 (D 0)
000000c0  0000180e  LL    0x18 (D 24)
000000c4  0000009d  PSHA
000000c8  ffff6405  JSR   0xffffff64 (TO 0x30)
000000cc  00001801  ENT   0x18 (D 24)
000000d0  00000858  SUBL  0x8 (D 8)
000000d4  0000015d  DIVI  0x1 (D 1)
000000d8  00000002  LEV   0x0 (D 0)
os.c  214: 
os.c  215: xstrncpy(char *s, char *t, int n) // no return value unlike strncpy XXX remove me only called once
000000dc  00000002  LEV   0x0 (D 0)
os.c  216: {
os.c  217:   while (n-- > 0 && (*s++ = *t++));
000000e0  00000003  JMP   <fwd>
os.c  218:   while (n-- > 0) *s++ = 0;
000000e4  0000180e  LL    0x18 (D 24)
000000e8  00000157  SUBI  0x1 (D 1)
000000ec  00001840  SL    0x18 (D 24)
000000f0  00000154  ADDI  0x1 (D 1)
000000f4  0000003e  LBA 
000000f8  00000023  LI    0x0 (D 0)
000000fc  0000008f  BGE   <fwd>
00000100  0000080e  LL    0x8 (D 8)
00000104  ffffff57  SUBI  0xffffffff (D -1)
00000108  00000840  SL    0x8 (D 8)
0000010c  ffffff54  ADDI  0xffffffff (D -1)
00000110  0000009d  PSHA
00000114  0000180e  LL    0x18 (D 24)
00000118  ffffff57  SUBI  0xffffffff (D -1)
0000011c  00001840  SL    0x18 (D 24)
00000120  ffffff1f  LXC   0xffffffff (D -1)
00000124  000000a1  POPB
00000128  0000004c  SXB 
0000012c  00001872  SHLI  0x18 (D 24)
00000130  00001875  SHRI  0x18 (D 24)
00000134  00000086  BNZ   <fwd>
00000138  00000003  JMP   <fwd>
0000013c  0000080e  LL    0x8 (D 8)
00000140  ffffff57  SUBI  0xffffffff (D -1)
00000144  00000840  SL    0x8 (D 8)
00000148  ffffff54  ADDI  0xffffffff (D -1)
0000014c  0000003e  LBA 
00000150  00000023  LI    0x0 (D 0)
00000154  0000004c  SXB 
os.c  219: }
00000158  0000180e  LL    0x18 (D 24)
0000015c  00000157  SUBI  0x1 (D 1)
00000160  00001840  SL    0x18 (D 24)
00000164  00000154  ADDI  0x1 (D 1)
00000168  0000003e  LBA 
0000016c  00000023  LI    0x0 (D 0)
00000170  0000008c  BLT   <fwd>
os.c  220: 
os.c  221: safestrcpy(char *s, char *t, int n) // like strncpy but guaranteed to null-terminate.
00000174  00000002  LEV   0x0 (D 0)
os.c  222: {
os.c  223:   if (n <= 0) return;
00000178  00000023  LI    0x0 (D 0)
0000017c  00001826  LBL   0x18 (D 24)
00000180  0000008c  BLT   <fwd>
00000184  00000002  LEV   0x0 (D 0)
os.c  224:   while (--n > 0 && (*s++ = *t++));
00000188  00000003  JMP   <fwd>
os.c  225:   *s = 0;
0000018c  0000180e  LL    0x18 (D 24)
00000190  00000157  SUBI  0x1 (D 1)
00000194  00001840  SL    0x18 (D 24)
00000198  0000003e  LBA 
0000019c  00000023  LI    0x0 (D 0)
000001a0  0000008f  BGE   <fwd>
000001a4  0000080e  LL    0x8 (D 8)
000001a8  ffffff57  SUBI  0xffffffff (D -1)
000001ac  00000840  SL    0x8 (D 8)
000001b0  ffffff54  ADDI  0xffffffff (D -1)
000001b4  0000009d  PSHA
000001b8  0000180e  LL    0x18 (D 24)
000001bc  ffffff57  SUBI  0xffffffff (D -1)
000001c0  00001840  SL    0x18 (D 24)
000001c4  ffffff1f  LXC   0xffffffff (D -1)
000001c8  000000a1  POPB
000001cc  0000004c  SXB 
000001d0  00001872  SHLI  0x18 (D 24)
000001d4  00001875  SHRI  0x18 (D 24)
000001d8  00000086  BNZ   <fwd>
000001dc  00000023  LI    0x0 (D 0)
000001e0  00000826  LBL   0x8 (D 8)
000001e4  0000004c  SXB 
os.c  226: }
os.c  227: 
os.c  228: // page allocator
os.c  229: char *kalloc()
000001e8  00000002  LEV   0x0 (D 0)
os.c  230: {
os.c  231:   char *r; int e = splhi();
os.c  232:   if (r = mem_free) mem_free = *(char **)r;
000001ec  fffff801  ENT   0xfffffff8 (D -8)
000001f0  fffeac05  JSR   0xfffffeac (TO 0xa0)
000001f4  00000040  SL    0x0 (D 0)
000001f8  00210815  LG    0x2108 (D 8456)
000001fc  00000440  SL    0x4 (D 4)
00000200  00000084  BZ    <fwd>
00000204  0000040e  LL    0x4 (D 4)
00000208  0000001c  LX  
0000020c  00210845  SG    0x2108 (D 8456)
os.c  233:   else if ((uint)(r = mem_top) < P2V+(mem_sz - FSSIZE)) mem_top += PAGE; //XXX uint issue is going to be a problem with other pointer compares!
00000210  00000003  JMP   <fwd>
00000214  00211015  LG    0x2110 (D 8464)
00000218  c0000054  ADDI  0xffc00000 (D -4194304)
0000021c  ffffc03b  LBI   0xffffffc0 (D -64)
00000220  0000003c  LBHI  0x0 (D 0)
00000224  00000053  ADD 
00000228  0000009d  PSHA
0000022c  00210c15  LG    0x210c (D 8460)
00000230  00000c40  SL    0xc (D 12)
00000234  000000a1  POPB
00000238  00000090  BGEU  <fwd>
0000023c  00210c15  LG    0x210c (D 8460)
00000240  00100054  ADDI  0x1000 (D 4096)
00000244  00210c45  SG    0x210c (D 8460)
os.c  234:   else panic("kalloc failure!");  //XXX need to sleep here!
00000248  00000003  JMP   <fwd>
0000024c  00000408  LEAG  0x4 (D 4)
00000250  0000009d  PSHA
00000254  00000005  JSR   <fwd>
00000258  00000801  ENT   0x8 (D 8)
os.c  235:   splx(e);
0000025c  0000000e  LL    0x0 (D 0)
00000260  0000009d  PSHA
00000264  fffe4005  JSR   0xfffffe40 (TO 0xa8)
00000268  00000801  ENT   0x8 (D 8)
os.c  236:   return r;
0000026c  0000040e  LL    0x4 (D 4)
00000270  00000802  LEV   0x8 (D 8)
os.c  237: }
os.c  238: 
os.c  239: kfree(char *v)
00000274  00000802  LEV   0x8 (D 8)
os.c  240: {
os.c  241:   int e = splhi();
os.c  242:   if ((uint)v % PAGE || v < (char *)(P2V+kreserved) || (uint)v >= P2V+(mem_sz - FSSIZE)) panic("kfree");
00000278  fffff801  ENT   0xfffffff8 (D -8)
0000027c  fffe2005  JSR   0xfffffe20 (TO 0xa0)
00000280  00000440  SL    0x4 (D 4)
00000284  0000100e  LL    0x10 (D 16)
00000288  00100066  MDUI  0x1000 (D 4096)
0000028c  00000086  BNZ   <fwd>
00000290  00211415  LG    0x2114 (D 8468)
00000294  ffffc03b  LBI   0xffffffc0 (D -64)
00000298  0000003c  LBHI  0x0 (D 0)
0000029c  00000053  ADD 
000002a0  0000003e  LBA 
000002a4  0000100e  LL    0x10 (D 16)
000002a8  00028c8d  BLTU  <fwd>
000002ac  00211015  LG    0x2110 (D 8464)
000002b0  c0000054  ADDI  0xffc00000 (D -4194304)
000002b4  ffffc03b  LBI   0xffffffc0 (D -64)
000002b8  0000003c  LBHI  0x0 (D 0)
000002bc  00000053  ADD 
000002c0  0000003e  LBA 
000002c4  0000100e  LL    0x10 (D 16)
000002c8  0000008d  BLTU  <fwd>
000002cc  00001408  LEAG  0x14 (D 20)
000002d0  0000009d  PSHA
000002d4  00025405  JSR   <fwd>
000002d8  00000801  ENT   0x8 (D 8)
os.c  243:   *(char **)v = mem_free;
000002dc  00210815  LG    0x2108 (D 8456)
000002e0  00001026  LBL   0x10 (D 16)
000002e4  0000004a  SX  
os.c  244:   mem_free = v;
000002e8  0000100e  LL    0x10 (D 16)
000002ec  00210845  SG    0x2108 (D 8456)
os.c  245:   splx(e);
000002f0  0000040e  LL    0x4 (D 4)
000002f4  0000009d  PSHA
000002f8  fffdac05  JSR   0xfffffdac (TO 0xa8)
000002fc  00000801  ENT   0x8 (D 8)
os.c  246: }
os.c  247: 
os.c  248: // console device
os.c  249: cout(char c)
00000300  00000802  LEV   0x8 (D 8)
os.c  250: {
os.c  251:   out(1, c);
00000304  00000811  LLC   0x8 (D 8)
00000308  0000009d  PSHA
0000030c  0000019e  PSHI  0x1 (D 1)
00000310  fffd3c05  JSR   0xfffffd3c (TO 0x50)
00000314  00001001  ENT   0x10 (D 16)
os.c  252: }
os.c  253: printn(int n)
00000318  00000002  LEV   0x0 (D 0)
os.c  254: {
os.c  255:   if (n > 9) { printn(n / 10); n %= 10; }
0000031c  00000923  LI    0x9 (D 9)
00000320  00000826  LBL   0x8 (D 8)
00000324  0000008f  BGE   <fwd>
00000328  0000080e  LL    0x8 (D 8)
0000032c  00000a5d  DIVI  0xa (D 10)
00000330  0000009d  PSHA
00000334  ffffe405  JSR   0xffffffe4 (TO 0x31c)
00000338  00000801  ENT   0x8 (D 8)
0000033c  0000080e  LL    0x8 (D 8)
00000340  00000a63  MODI  0xa (D 10)
00000344  00000840  SL    0x8 (D 8)
os.c  256:   cout(n + '0');
00000348  0000080e  LL    0x8 (D 8)
0000034c  00003054  ADDI  0x30 (D 48)
00000350  0000009d  PSHA
00000354  ffffac05  JSR   0xffffffac (TO 0x304)
00000358  00000801  ENT   0x8 (D 8)
os.c  257: }
os.c  258: printx(uint n)
0000035c  00000002  LEV   0x0 (D 0)
os.c  259: {
os.c  260:   if (n > 15) { printx(n >> 4); n &= 15; }
00000360  00000f23  LI    0xf (D 15)
00000364  00000826  LBL   0x8 (D 8)
00000368  00000090  BGEU  <fwd>
0000036c  0000080e  LL    0x8 (D 8)
00000370  00000478  SRUI  0x4 (D 4)
00000374  0000009d  PSHA
00000378  ffffe405  JSR   0xffffffe4 (TO 0x360)
0000037c  00000801  ENT   0x8 (D 8)
00000380  0000080e  LL    0x8 (D 8)
00000384  00000f69  ANDI  0xf (D 15)
00000388  00000840  SL    0x8 (D 8)
os.c  261:   cout(n + (n > 9 ? 'a' - 10 : '0'));
0000038c  00000923  LI    0x9 (D 9)
00000390  00000826  LBL   0x8 (D 8)
00000394  00000090  BGEU  <fwd>
00000398  00005723  LI    0x57 (D 87)
0000039c  00000003  JMP   <fwd>
000003a0  00003023  LI    0x30 (D 48)
000003a4  00000855  ADDL  0x8 (D 8)
000003a8  0000009d  PSHA
000003ac  ffff5405  JSR   0xffffff54 (TO 0x304)
000003b0  00000801  ENT   0x8 (D 8)
os.c  262: }
os.c  263: printf(char *f, ...) // XXX simplify or chuck
000003b4  00000002  LEV   0x0 (D 0)
os.c  264: {
os.c  265:   int n, e = splhi(); char *s; va_list v;
os.c  266:   va_start(v, f);
000003b8  fffff001  ENT   0xfffffff0 (D -16)
000003bc  fffce005  JSR   0xfffffce0 (TO 0xa0)
000003c0  00000840  SL    0x8 (D 8)
000003c4  00001807  LEA   0x18 (D 24)
000003c8  00000040  SL    0x0 (D 0)
os.c  267:   while (*f) {
000003cc  00000003  JMP   <fwd>
os.c  268:     if (*f != '%') { cout(*f++); continue; }
000003d0  0000180e  LL    0x18 (D 24)
000003d4  0000001f  LXC 
000003d8  0000253b  LBI   0x25 (D 37)
000003dc  00000088  BE    <fwd>
000003e0  0000180e  LL    0x18 (D 24)
000003e4  ffffff57  SUBI  0xffffffff (D -1)
000003e8  00001840  SL    0x18 (D 24)
000003ec  ffffff1f  LXC   0xffffffff (D -1)
000003f0  0000009d  PSHA
000003f4  ffff0c05  JSR   0xffffff0c (TO 0x304)
000003f8  00000801  ENT   0x8 (D 8)
000003fc  0003cc03  JMP   <fwd>
os.c  269:     switch (*++f) {
00000400  0000180e  LL    0x18 (D 24)
00000404  00000154  ADDI  0x1 (D 1)
00000408  00001840  SL    0x18 (D 24)
0000040c  0000001f  LXC 
00000410  00000003  JMP   <fwd>
os.c  270:     case 'd': f++; if ((n = va_arg(v,int)) < 0) { cout('-'); printn(-n); } else printn(n); continue;
00000414  0000180e  LL    0x18 (D 24)
00000418  ffffff57  SUBI  0xffffffff (D -1)
0000041c  00001840  SL    0x18 (D 24)
00000420  0000000e  LL    0x0 (D 0)
00000424  00000854  ADDI  0x8 (D 8)
00000428  00000040  SL    0x0 (D 0)
0000042c  0000001c  LX  
00000430  00000c40  SL    0xc (D 12)
00000434  0000003b  LBI   0x0 (D 0)
00000438  0000008f  BGE   <fwd>
0000043c  00002d9e  PSHI  0x2d (D 45)
00000440  fffec005  JSR   0xfffffec0 (TO 0x304)
00000444  00000801  ENT   0x8 (D 8)
00000448  00000c0e  LL    0xc (D 12)
0000044c  ffffff5a  MULI  0xffffffff (D -1)
00000450  0000009d  PSHA
00000454  fffec405  JSR   0xfffffec4 (TO 0x31c)
00000458  00000801  ENT   0x8 (D 8)
0000045c  00000003  JMP   <fwd>
00000460  00000c0e  LL    0xc (D 12)
00000464  0000009d  PSHA
00000468  fffeb005  JSR   0xfffffeb0 (TO 0x31c)
0000046c  00000801  ENT   0x8 (D 8)
00000470  0003fc03  JMP   <fwd>
os.c  271:     case 'x': f++; printx(va_arg(v,int)); continue;
00000474  0000180e  LL    0x18 (D 24)
00000478  ffffff57  SUBI  0xffffffff (D -1)
0000047c  00001840  SL    0x18 (D 24)
00000480  0000000e  LL    0x0 (D 0)
00000484  00000854  ADDI  0x8 (D 8)
00000488  00000040  SL    0x0 (D 0)
0000048c  0000001c  LX  
00000490  0000009d  PSHA
00000494  fffec805  JSR   0xfffffec8 (TO 0x360)
00000498  00000801  ENT   0x8 (D 8)
0000049c  00047003  JMP   <fwd>
os.c  272:     case 's': f++; for (s = va_arg(v, char *); *s; s++) cout(*s); continue;
000004a0  0000180e  LL    0x18 (D 24)
000004a4  ffffff57  SUBI  0xffffffff (D -1)
000004a8  00001840  SL    0x18 (D 24)
000004ac  0000000e  LL    0x0 (D 0)
000004b0  00000854  ADDI  0x8 (D 8)
000004b4  00000040  SL    0x0 (D 0)
000004b8  0000001c  LX  
000004bc  00000440  SL    0x4 (D 4)
000004c0  00000003  JMP   <fwd>
000004c4  0000040e  LL    0x4 (D 4)
000004c8  0000001f  LXC 
000004cc  0000009d  PSHA
000004d0  fffe3005  JSR   0xfffffe30 (TO 0x304)
000004d4  00000801  ENT   0x8 (D 8)
000004d8  0000040e  LL    0x4 (D 4)
000004dc  ffffff57  SUBI  0xffffffff (D -1)
000004e0  00000440  SL    0x4 (D 4)
000004e4  0000040e  LL    0x4 (D 4)
000004e8  0000001f  LXC 
000004ec  00000086  BNZ   <fwd>
000004f0  00049c03  JMP   <fwd>
os.c  273:     }
os.c  274:     cout('%');
000004f4  00000003  JMP   <fwd>
000004f8  00006457  SUBI  0x64 (D 100)
000004fc  0000153b  LBI   0x15 (D 21)
00000500  0004f490  BGEU  <fwd>
00000504  00001c04  JMPI  0x1c (D 28)
00000508  0000259e  PSHI  0x25 (D 37)
0000050c  fffdf405  JSR   0xfffffdf4 (TO 0x304)
00000510  00000801  ENT   0x8 (D 8)
os.c  275:   }
os.c  276:   splx(e);
00000514  0000180e  LL    0x18 (D 24)
00000518  0000001f  LXC 
0000051c  00000086  BNZ   <fwd>
00000520  0000080e  LL    0x8 (D 8)
00000524  0000009d  PSHA
00000528  fffb7c05  JSR   0xfffffb7c (TO 0xa8)
0000052c  00000801  ENT   0x8 (D 8)
os.c  277: }
os.c  278: 
os.c  279: panic(char *s)
00000530  00001002  LEV   0x10 (D 16)
os.c  280: {
os.c  281:   asm(CLI);
00000534  00000096  CLI 
os.c  282:   out(1,'p'); out(1,'a'); out(1,'n'); out(1,'i'); out(1,'c'); out(1,':'); out(1,' '); 
00000538  0000709e  PSHI  0x70 (D 112)
0000053c  0000019e  PSHI  0x1 (D 1)
00000540  fffb0c05  JSR   0xfffffb0c (TO 0x50)
00000544  00001001  ENT   0x10 (D 16)
00000548  0000619e  PSHI  0x61 (D 97)
0000054c  0000019e  PSHI  0x1 (D 1)
00000550  fffafc05  JSR   0xfffffafc (TO 0x50)
00000554  00001001  ENT   0x10 (D 16)
00000558  00006e9e  PSHI  0x6e (D 110)
0000055c  0000019e  PSHI  0x1 (D 1)
00000560  fffaec05  JSR   0xfffffaec (TO 0x50)
00000564  00001001  ENT   0x10 (D 16)
00000568  0000699e  PSHI  0x69 (D 105)
0000056c  0000019e  PSHI  0x1 (D 1)
00000570  fffadc05  JSR   0xfffffadc (TO 0x50)
00000574  00001001  ENT   0x10 (D 16)
00000578  0000639e  PSHI  0x63 (D 99)
0000057c  0000019e  PSHI  0x1 (D 1)
00000580  fffacc05  JSR   0xfffffacc (TO 0x50)
00000584  00001001  ENT   0x10 (D 16)
00000588  00003a9e  PSHI  0x3a (D 58)
0000058c  0000019e  PSHI  0x1 (D 1)
00000590  fffabc05  JSR   0xfffffabc (TO 0x50)
00000594  00001001  ENT   0x10 (D 16)
00000598  0000209e  PSHI  0x20 (D 32)
0000059c  0000019e  PSHI  0x1 (D 1)
000005a0  fffaac05  JSR   0xfffffaac (TO 0x50)
000005a4  00001001  ENT   0x10 (D 16)
os.c  283:   while (*s) out(1,*s++);
000005a8  00000003  JMP   <fwd>
000005ac  0000080e  LL    0x8 (D 8)
000005b0  ffffff57  SUBI  0xffffffff (D -1)
000005b4  00000840  SL    0x8 (D 8)
000005b8  ffffff1f  LXC   0xffffffff (D -1)
000005bc  0000009d  PSHA
000005c0  0000019e  PSHI  0x1 (D 1)
000005c4  fffa8805  JSR   0xfffffa88 (TO 0x50)
000005c8  00001001  ENT   0x10 (D 16)
os.c  284:   out(1,'\n');
000005cc  0000080e  LL    0x8 (D 8)
000005d0  0000001f  LXC 
000005d4  00000086  BNZ   <fwd>
000005d8  00000a9e  PSHI  0xa (D 10)
000005dc  0000019e  PSHI  0x1 (D 1)
000005e0  fffa6c05  JSR   0xfffffa6c (TO 0x50)
000005e4  00001001  ENT   0x10 (D 16)
os.c  285:   asm(HALT);
000005e8  00000000  HALT
os.c  286: }
os.c  287: 
os.c  288: consoleintr()
000005ec  00000002  LEV   0x0 (D 0)
os.c  289: {
os.c  290:   int c;
os.c  291:   while ((c = in(0)) != -1) {
000005f0  fffff801  ENT   0xfffffff8 (D -8)
000005f4  00000003  JMP   <fwd>
os.c  292: //    printf("<%d>",c); //   XXX
os.c  293:     if (input.w - input.r < INPUT_BUF) {
000005f8  0021f815  LG    0x21f8 (D 8696)
000005fc  0021f42d  LBG   0x21f4 (D 8692)
00000600  00000056  SUB 
00000604  0000803b  LBI   0x80 (D 128)
00000608  00000090  BGEU  <fwd>
os.c  294:       input.buf[input.w++ % INPUT_BUF] = c;
0000060c  00217408  LEAG  0x2174 (D 8564)
00000610  0000009d  PSHA
00000614  0021f815  LG    0x21f8 (D 8696)
00000618  ffffff57  SUBI  0xffffffff (D -1)
0000061c  0021f845  SG    0x21f8 (D 8696)
00000620  ffffff54  ADDI  0xffffffff (D -1)
00000624  00008066  MDUI  0x80 (D 128)
00000628  000000a1  POPB
0000062c  00000053  ADD 
00000630  0000003e  LBA 
00000634  0000040e  LL    0x4 (D 4)
00000638  0000004c  SXB 
os.c  295:       wakeup(&input.r);
0000063c  0021f408  LEAG  0x21f4 (D 8692)
00000640  0000009d  PSHA
00000644  00000005  JSR   <fwd>
00000648  00000801  ENT   0x8 (D 8)
os.c  296:     }
os.c  297:   }
os.c  298: }
0000064c  0000009e  PSHI  0x0 (D 0)
00000650  fff9f005  JSR   0xfffff9f0 (TO 0x44)
00000654  00000801  ENT   0x8 (D 8)
00000658  00000440  SL    0x4 (D 4)
0000065c  ffffff3b  LBI   0xffffffff (D -1)
00000660  0000008a  BNE   <fwd>
os.c  299: 
os.c  300: int consoleread(struct inode *ip, char *dst, int n)
00000664  00000802  LEV   0x8 (D 8)
os.c  301: {
os.c  302:   int target, c, e;
os.c  303: 
os.c  304:   iunlock(ip);
00000668  fffff001  ENT   0xfffffff0 (D -16)
0000066c  0000180e  LL    0x18 (D 24)
00000670  0000009d  PSHA
00000674  00000005  JSR   <fwd>
00000678  00000801  ENT   0x8 (D 8)
os.c  305:   target = n;
0000067c  0000280e  LL    0x28 (D 40)
00000680  00000c40  SL    0xc (D 12)
os.c  306:   e = splhi();
00000684  fffa1805  JSR   0xfffffa18 (TO 0xa0)
00000688  00000440  SL    0x4 (D 4)
os.c  307:   while (n > 0) {
0000068c  00000003  JMP   <fwd>
os.c  308:     if (input.r == input.w && n < target) break; // block until at least one byte transfered
00000690  0021f415  LG    0x21f4 (D 8692)
00000694  0021f82d  LBG   0x21f8 (D 8696)
00000698  0000008a  BNE   <fwd>
0000069c  0000280e  LL    0x28 (D 40)
000006a0  00000c26  LBL   0xc (D 12)
000006a4  0006988f  BGE   <fwd>
000006a8  00000003  JMP   <fwd>
os.c  309:     while (input.r == input.w) {
000006ac  00000003  JMP   <fwd>
os.c  310:       if (u->killed) {
000006b0  00210015  LG    0x2100 (D 8448)
000006b4  00002c1c  LX    0x2c (D 44)
000006b8  00000084  BZ    <fwd>
os.c  311:         splx(e);
000006bc  0000040e  LL    0x4 (D 4)
000006c0  0000009d  PSHA
000006c4  fff9e005  JSR   0xfffff9e0 (TO 0xa8)
000006c8  00000801  ENT   0x8 (D 8)
os.c  312:         ilock(ip);
000006cc  0000180e  LL    0x18 (D 24)
000006d0  0000009d  PSHA
000006d4  00000005  JSR   <fwd>
000006d8  00000801  ENT   0x8 (D 8)
os.c  313:         return -1;
000006dc  ffffff23  LI    0xffffffff (D -1)
000006e0  00001002  LEV   0x10 (D 16)
os.c  314:       }
os.c  315:       sleep(&input.r);
000006e4  0021f408  LEAG  0x21f4 (D 8692)
000006e8  0000009d  PSHA
000006ec  00000005  JSR   <fwd>
000006f0  00000801  ENT   0x8 (D 8)
os.c  316:     }
os.c  317:     c = input.buf[input.r++ % INPUT_BUF];
000006f4  0021f415  LG    0x21f4 (D 8692)
000006f8  0021f82d  LBG   0x21f8 (D 8696)
000006fc  00000088  BE    <fwd>
00000700  00217408  LEAG  0x2174 (D 8564)
00000704  0000009d  PSHA
00000708  0021f415  LG    0x21f4 (D 8692)
0000070c  ffffff57  SUBI  0xffffffff (D -1)
00000710  0021f445  SG    0x21f4 (D 8692)
00000714  ffffff54  ADDI  0xffffffff (D -1)
00000718  00008066  MDUI  0x80 (D 128)
0000071c  000000a1  POPB
00000720  00000053  ADD 
00000724  0000001f  LXC 
00000728  00000840  SL    0x8 (D 8)
os.c  318:     *dst++ = c;  // XXX pagefault possible in cli (perhaps use inode locks to achieve desired effect)
0000072c  0000200e  LL    0x20 (D 32)
00000730  ffffff57  SUBI  0xffffffff (D -1)
00000734  00002040  SL    0x20 (D 32)
00000738  ffffff54  ADDI  0xffffffff (D -1)
0000073c  0000003e  LBA 
00000740  0000080e  LL    0x8 (D 8)
00000744  0000004c  SXB 
os.c  319:     n--;
00000748  0000280e  LL    0x28 (D 40)
0000074c  00000157  SUBI  0x1 (D 1)
00000750  00002840  SL    0x28 (D 40)
os.c  320:   }
os.c  321:   splx(e);
00000754  00000023  LI    0x0 (D 0)
00000758  00002826  LBL   0x28 (D 40)
0000075c  0000008c  BLT   <fwd>
00000760  0000040e  LL    0x4 (D 4)
00000764  0000009d  PSHA
00000768  fff93c05  JSR   0xfffff93c (TO 0xa8)
0000076c  00000801  ENT   0x8 (D 8)
os.c  322:   ilock(ip);
00000770  0000180e  LL    0x18 (D 24)
00000774  0000009d  PSHA
00000778  0006d405  JSR   <fwd>
0000077c  00000801  ENT   0x8 (D 8)
os.c  323: 
os.c  324:   return target - n;
00000780  00000c0e  LL    0xc (D 12)
00000784  00002858  SUBL  0x28 (D 40)
00000788  00001002  LEV   0x10 (D 16)
os.c  325: }
os.c  326: 
os.c  327: int consolewrite(struct inode *ip, char *buf, int n)
0000078c  00001002  LEV   0x10 (D 16)
os.c  328: {
os.c  329:   int i, e;
os.c  330: 
os.c  331:   iunlock(ip);
00000790  fffff801  ENT   0xfffffff8 (D -8)
00000794  0000100e  LL    0x10 (D 16)
00000798  0000009d  PSHA
0000079c  00067405  JSR   <fwd>
000007a0  00000801  ENT   0x8 (D 8)
os.c  332:   e = splhi(); // XXX pagefault possible in cli
000007a4  fff8f805  JSR   0xfffff8f8 (TO 0xa0)
000007a8  00000040  SL    0x0 (D 0)
os.c  333:   for (i = 0; i < n; i++) cout(buf[i]);
000007ac  00000023  LI    0x0 (D 0)
000007b0  00000440  SL    0x4 (D 4)
000007b4  00000003  JMP   <fwd>
000007b8  0000180e  LL    0x18 (D 24)
000007bc  00000455  ADDL  0x4 (D 4)
000007c0  0000001f  LXC 
000007c4  0000009d  PSHA
000007c8  fffb3805  JSR   0xfffffb38 (TO 0x304)
000007cc  00000801  ENT   0x8 (D 8)
os.c  334:   splx(e);
000007d0  0000040e  LL    0x4 (D 4)
000007d4  ffffff57  SUBI  0xffffffff (D -1)
000007d8  00000440  SL    0x4 (D 4)
000007dc  0000040e  LL    0x4 (D 4)
000007e0  00002026  LBL   0x20 (D 32)
000007e4  0000008c  BLT   <fwd>
000007e8  0000000e  LL    0x0 (D 0)
000007ec  0000009d  PSHA
000007f0  fff8b405  JSR   0xfffff8b4 (TO 0xa8)
000007f4  00000801  ENT   0x8 (D 8)
os.c  335:   ilock(ip);
000007f8  0000100e  LL    0x10 (D 16)
000007fc  0000009d  PSHA
00000800  00077805  JSR   <fwd>
00000804  00000801  ENT   0x8 (D 8)
os.c  336:   return n;
00000808  0000200e  LL    0x20 (D 32)
0000080c  00000802  LEV   0x8 (D 8)
os.c  337: }
os.c  338: 
os.c  339: consoleinit()
00000810  00000802  LEV   0x8 (D 8)
os.c  340: {
os.c  341:   devsw[CONSOLE].write = consolewrite;
00000814  ffff7808  LEAG  0xffffff78 (D -136)
00000818  00212445  SG    0x2124 (D 8484)
os.c  342:   devsw[CONSOLE].read  = consoleread;
0000081c  fffe4808  LEAG  0xfffffe48 (D -440)
00000820  00212045  SG    0x2120 (D 8480)
os.c  343: }
os.c  344: 
os.c  345: // fake IDE disk; stores blocks in memory.  useful for running kernel without scratch disk.  XXX but no good for stressing demand pageing logic!
os.c  346: ideinit()
00000824  00000002  LEV   0x0 (D 0)
os.c  347: {
os.c  348:   memdisk = P2V+(mem_sz - FSSIZE);
00000828  00211015  LG    0x2110 (D 8464)
0000082c  c0000054  ADDI  0xffc00000 (D -4194304)
00000830  ffffc03b  LBI   0xffffffc0 (D -64)
00000834  0000003c  LBHI  0x0 (D 0)
00000838  00000053  ADD 
0000083c  00217045  SG    0x2170 (D 8560)
os.c  349: }
os.c  350: 
os.c  351: // sync buf with disk.  if B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
os.c  352: // else if B_VALID is not set, read buf from disk, set B_VALID.
os.c  353: iderw(struct buf *b) // XXX rename?!
00000840  00000002  LEV   0x0 (D 0)
os.c  354: {
os.c  355:   if (!(b->flags & B_BUSY)) panic("iderw: buf not busy");
00000844  0000080e  LL    0x8 (D 8)
00000848  0000001c  LX  
0000084c  00000169  ANDI  0x1 (D 1)
00000850  00000086  BNZ   <fwd>
00000854  00007008  LEAG  0x70 (D 112)
00000858  0000009d  PSHA
0000085c  fffcd405  JSR   0xfffffcd4 (TO 0x534)
00000860  00000801  ENT   0x8 (D 8)
os.c  356:   if ((b->flags & (B_VALID|B_DIRTY)) == B_VALID) panic("iderw: nothing to do");
00000864  0000080e  LL    0x8 (D 8)
00000868  0000001c  LX  
0000086c  00000669  ANDI  0x6 (D 6)
00000870  0000023b  LBI   0x2 (D 2)
00000874  0000008a  BNE   <fwd>
00000878  00008408  LEAG  0x84 (D 132)
0000087c  0000009d  PSHA
00000880  fffcb005  JSR   0xfffffcb0 (TO 0x534)
00000884  00000801  ENT   0x8 (D 8)
os.c  357:   if (b->sector >= (FSSIZE / PAGE)) panic("iderw: sector out of range");
00000888  0000080e  LL    0x8 (D 8)
0000088c  0000041c  LX    0x4 (D 4)
00000890  0004003b  LBI   0x400 (D 1024)
00000894  0000008d  BLTU  <fwd>
00000898  00009908  LEAG  0x99 (D 153)
0000089c  0000009d  PSHA
000008a0  fffc9005  JSR   0xfffffc90 (TO 0x534)
000008a4  00000801  ENT   0x8 (D 8)
os.c  358: 
os.c  359:   if (b->flags & B_DIRTY) {
000008a8  0000080e  LL    0x8 (D 8)
000008ac  0000001c  LX  
000008b0  00000469  ANDI  0x4 (D 4)
000008b4  00000084  BZ    <fwd>
os.c  360:     b->flags &= ~B_DIRTY;
000008b8  0000080e  LL    0x8 (D 8)
000008bc  0000003e  LBA 
000008c0  0000001c  LX  
000008c4  fffffb69  ANDI  0xfffffffb (D -5)
000008c8  0000004a  SX  
os.c  361:     memcpy(memdisk + b->sector*PAGE, b->data, PAGE);
000008cc  0010009e  PSHI  0x1000 (D 4096)
000008d0  0000100e  LL    0x10 (D 16)
000008d4  0000101c  LX    0x10 (D 16)
000008d8  0000009d  PSHA
000008dc  0000180e  LL    0x18 (D 24)
000008e0  0000041c  LX    0x4 (D 4)
000008e4  0010005a  MULI  0x1000 (D 4096)
000008e8  0021702d  LBG   0x2170 (D 8560)
000008ec  00000053  ADD 
000008f0  0000009d  PSHA
000008f4  fff70805  JSR   0xfffff708 (TO 0x0)
000008f8  00001801  ENT   0x18 (D 24)
os.c  362:   } else
os.c  363:     memcpy(b->data, memdisk + b->sector*PAGE, PAGE);
000008fc  00000003  JMP   <fwd>
00000900  0010009e  PSHI  0x1000 (D 4096)
00000904  0000100e  LL    0x10 (D 16)
00000908  0000041c  LX    0x4 (D 4)
0000090c  0010005a  MULI  0x1000 (D 4096)
00000910  0021702d  LBG   0x2170 (D 8560)
00000914  00000053  ADD 
00000918  0000009d  PSHA
0000091c  0000180e  LL    0x18 (D 24)
00000920  0000101c  LX    0x10 (D 16)
00000924  0000009d  PSHA
00000928  fff6d405  JSR   0xfffff6d4 (TO 0x0)
0000092c  00001801  ENT   0x18 (D 24)
os.c  364:   b->flags |= B_VALID;
00000930  0000080e  LL    0x8 (D 8)
00000934  0000003e  LBA 
00000938  0000001c  LX  
0000093c  0000026c  ORI   0x2 (D 2)
00000940  0000004a  SX  
os.c  365: }
os.c  366: 
os.c  367: // buffer cache:
os.c  368: // The buffer cache is a linked list of buf structures holding cached copies of disk block contents.  Caching disk blocks.
os.c  369: // in memory reduces the number of disk reads and also provides a synchronization point for disk blocks used by multiple processes.
os.c  370: // 
os.c  371: // Interface:
os.c  372: // * To get a buffer for a particular disk block, call bread.
os.c  373: // * After changing buffer data, call bwrite to write it to disk.
os.c  374: // * When done with the buffer, call brelse.
os.c  375: // * Do not use the buffer after calling brelse.
os.c  376: // * Only one process at a time can use a buffer, so do not keep them longer than necessary.
os.c  377: // 
os.c  378: // The implementation uses three state flags internally:
os.c  379: // * B_BUSY: the block has been returned from bread and has not been passed back to brelse.  
os.c  380: // * B_VALID: the buffer data has been read from the disk.
os.c  381: // * B_DIRTY: the buffer data has been modified and needs to be written to disk.
os.c  382: binit()
00000944  00000002  LEV   0x0 (D 0)
os.c  383: {
os.c  384:   struct buf *b;
os.c  385: 
os.c  386:   // create linked list of buffers
os.c  387:   bfreelist.prev = bfreelist.next = &bfreelist;
00000948  fffff801  ENT   0xfffffff8 (D -8)
0000094c  0022c408  LEAG  0x22c4 (D 8900)
00000950  0022d045  SG    0x22d0 (D 8912)
00000954  0022cc45  SG    0x22cc (D 8908)
os.c  388:   for (b = bcache; b < bcache+NBUF; b++) {
00000958  0021fc08  LEAG  0x21fc (D 8700)
0000095c  00000440  SL    0x4 (D 4)
00000960  00000003  JMP   <fwd>
os.c  389:     b->next = bfreelist.next;
00000964  0000040e  LL    0x4 (D 4)
00000968  00000c54  ADDI  0xc (D 12)
0000096c  0000003e  LBA 
00000970  0022d015  LG    0x22d0 (D 8912)
00000974  0000004a  SX  
os.c  390:     b->prev = &bfreelist;
00000978  0000040e  LL    0x4 (D 4)
0000097c  00000854  ADDI  0x8 (D 8)
00000980  0000009d  PSHA
00000984  0022c408  LEAG  0x22c4 (D 8900)
00000988  000000a1  POPB
0000098c  0000004a  SX  
os.c  391:     b->data = kalloc();
00000990  0000040e  LL    0x4 (D 4)
00000994  00001054  ADDI  0x10 (D 16)
00000998  0000009d  PSHA
0000099c  fff84c05  JSR   0xfffff84c (TO 0x1ec)
000009a0  000000a1  POPB
000009a4  0000004a  SX  
os.c  392:     bfreelist.next->prev = b;
000009a8  0022d015  LG    0x22d0 (D 8912)
000009ac  00000854  ADDI  0x8 (D 8)
000009b0  0000003e  LBA 
000009b4  0000040e  LL    0x4 (D 4)
000009b8  0000004a  SX  
os.c  393:     bfreelist.next = b;
000009bc  0000040e  LL    0x4 (D 4)
000009c0  0022d045  SG    0x22d0 (D 8912)
os.c  394:   }
os.c  395: }
000009c4  0000040e  LL    0x4 (D 4)
000009c8  ffffec57  SUBI  0xffffffec (D -20)
000009cc  00000440  SL    0x4 (D 4)
000009d0  0022c408  LEAG  0x22c4 (D 8900)
000009d4  0000003e  LBA 
000009d8  0000040e  LL    0x4 (D 4)
000009dc  0000008d  BLTU  <fwd>
os.c  396: 
os.c  397: // look through buffer cache for sector.
os.c  398: // if not found, allocate fresh block.  in either case, return B_BUSY buffer
os.c  399: struct buf *bget(uint sector)
000009e0  00000802  LEV   0x8 (D 8)
os.c  400: {
os.c  401:   struct buf *b; int e = splhi();
os.c  402:   
os.c  403: loop:  // try for cached block
000009e4  fffff801  ENT   0xfffffff8 (D -8)
000009e8  fff6b405  JSR   0xfffff6b4 (TO 0xa0)
000009ec  00000040  SL    0x0 (D 0)
os.c  404:   for (b = bfreelist.next; b != &bfreelist; b = b->next) {
000009f0  0022d015  LG    0x22d0 (D 8912)
000009f4  00000440  SL    0x4 (D 4)
000009f8  00000003  JMP   <fwd>
os.c  405:     if (b->sector == sector) {
000009fc  0000040e  LL    0x4 (D 4)
00000a00  0000041c  LX    0x4 (D 4)
00000a04  00001026  LBL   0x10 (D 16)
00000a08  0000008a  BNE   <fwd>
os.c  406:       if (!(b->flags & B_BUSY)) {
00000a0c  0000040e  LL    0x4 (D 4)
00000a10  0000001c  LX  
00000a14  00000169  ANDI  0x1 (D 1)
00000a18  00000086  BNZ   <fwd>
os.c  407:         b->flags |= B_BUSY;
00000a1c  0000040e  LL    0x4 (D 4)
00000a20  0000003e  LBA 
00000a24  0000001c  LX  
00000a28  0000016c  ORI   0x1 (D 1)
00000a2c  0000004a  SX  
os.c  408:         splx(e);
00000a30  0000000e  LL    0x0 (D 0)
00000a34  0000009d  PSHA
00000a38  fff66c05  JSR   0xfffff66c (TO 0xa8)
00000a3c  00000801  ENT   0x8 (D 8)
os.c  409:         return b;
00000a40  0000040e  LL    0x4 (D 4)
00000a44  00000802  LEV   0x8 (D 8)
os.c  410:       }
os.c  411:       sleep(b);
00000a48  0000040e  LL    0x4 (D 4)
00000a4c  0000009d  PSHA
00000a50  0006ec05  JSR   <fwd>
00000a54  00000801  ENT   0x8 (D 8)
os.c  412:       goto loop;
00000a58  ffff9403  JMP   0xffffff94 (TO 0x9f0)
os.c  413:     }
os.c  414:   }
os.c  415: 
os.c  416:   // allocate fresh block
os.c  417:   for (b = bfreelist.prev; b != &bfreelist; b = b->prev) {
00000a5c  0000040e  LL    0x4 (D 4)
00000a60  00000c1c  LX    0xc (D 12)
00000a64  00000440  SL    0x4 (D 4)
00000a68  0022c408  LEAG  0x22c4 (D 8900)
00000a6c  00000426  LBL   0x4 (D 4)
00000a70  0000008a  BNE   <fwd>
00000a74  0022cc15  LG    0x22cc (D 8908)
00000a78  00000440  SL    0x4 (D 4)
00000a7c  00000003  JMP   <fwd>
os.c  418:     if (!(b->flags & (B_BUSY | B_DIRTY))) {
00000a80  0000040e  LL    0x4 (D 4)
00000a84  0000001c  LX  
00000a88  00000569  ANDI  0x5 (D 5)
00000a8c  00000086  BNZ   <fwd>
os.c  419:       b->sector = sector;
00000a90  0000040e  LL    0x4 (D 4)
00000a94  00000454  ADDI  0x4 (D 4)
00000a98  0000003e  LBA 
00000a9c  0000100e  LL    0x10 (D 16)
00000aa0  0000004a  SX  
os.c  420:       b->flags = B_BUSY;
00000aa4  00000123  LI    0x1 (D 1)
00000aa8  00000426  LBL   0x4 (D 4)
00000aac  0000004a  SX  
os.c  421:       splx(e);
00000ab0  0000000e  LL    0x0 (D 0)
00000ab4  0000009d  PSHA
00000ab8  fff5ec05  JSR   0xfffff5ec (TO 0xa8)
00000abc  00000801  ENT   0x8 (D 8)
os.c  422:       return b;
00000ac0  0000040e  LL    0x4 (D 4)
00000ac4  00000802  LEV   0x8 (D 8)
os.c  423:     }
os.c  424:   }
os.c  425:   panic("bget: no buffers");
00000ac8  0000040e  LL    0x4 (D 4)
00000acc  0000081c  LX    0x8 (D 8)
00000ad0  00000440  SL    0x4 (D 4)
00000ad4  0022c408  LEAG  0x22c4 (D 8900)
00000ad8  00000426  LBL   0x4 (D 4)
00000adc  0000008a  BNE   <fwd>
00000ae0  0000b408  LEAG  0xb4 (D 180)
00000ae4  0000009d  PSHA
00000ae8  fffa4805  JSR   0xfffffa48 (TO 0x534)
00000aec  00000801  ENT   0x8 (D 8)
os.c  426: }
os.c  427: 
os.c  428: // return a B_BUSY buf with the contents of the indicated disk sector
os.c  429: struct buf *bread(uint sector)
00000af0  00000802  LEV   0x8 (D 8)
os.c  430: {
os.c  431:   struct buf *b;
os.c  432: 
os.c  433:   b = bget(sector);
00000af4  fffff801  ENT   0xfffffff8 (D -8)
00000af8  0000100e  LL    0x10 (D 16)
00000afc  0000009d  PSHA
00000b00  fffee005  JSR   0xfffffee0 (TO 0x9e4)
00000b04  00000801  ENT   0x8 (D 8)
00000b08  00000440  SL    0x4 (D 4)
os.c  434:   if (!(b->flags & B_VALID)) iderw(b);
00000b0c  0000040e  LL    0x4 (D 4)
00000b10  0000001c  LX  
00000b14  00000269  ANDI  0x2 (D 2)
00000b18  00000086  BNZ   <fwd>
00000b1c  0000040e  LL    0x4 (D 4)
00000b20  0000009d  PSHA
00000b24  fffd1c05  JSR   0xfffffd1c (TO 0x844)
00000b28  00000801  ENT   0x8 (D 8)
os.c  435:   return b;
00000b2c  0000040e  LL    0x4 (D 4)
00000b30  00000802  LEV   0x8 (D 8)
os.c  436: }
os.c  437: 
os.c  438: // write b's contents to disk.  must be B_BUSY
os.c  439: bwrite(struct buf *b)
00000b34  00000802  LEV   0x8 (D 8)
os.c  440: {
os.c  441:   if (!(b->flags & B_BUSY)) panic("bwrite");
00000b38  0000080e  LL    0x8 (D 8)
00000b3c  0000001c  LX  
00000b40  00000169  ANDI  0x1 (D 1)
00000b44  00000086  BNZ   <fwd>
00000b48  0000c508  LEAG  0xc5 (D 197)
00000b4c  0000009d  PSHA
00000b50  fff9e005  JSR   0xfffff9e0 (TO 0x534)
00000b54  00000801  ENT   0x8 (D 8)
os.c  442:   b->flags |= B_DIRTY;
00000b58  0000080e  LL    0x8 (D 8)
00000b5c  0000003e  LBA 
00000b60  0000001c  LX  
00000b64  0000046c  ORI   0x4 (D 4)
00000b68  0000004a  SX  
os.c  443:   iderw(b);
00000b6c  0000080e  LL    0x8 (D 8)
00000b70  0000009d  PSHA
00000b74  fffccc05  JSR   0xfffffccc (TO 0x844)
00000b78  00000801  ENT   0x8 (D 8)
os.c  444: }
os.c  445: 
os.c  446: // release a B_BUSY buffer.  move to the head of the MRU list
os.c  447: brelse(struct buf *b)
00000b7c  00000002  LEV   0x0 (D 0)
os.c  448: {
os.c  449:   int e = splhi();
os.c  450:   if (!(b->flags & B_BUSY)) panic("brelse");
00000b80  fffff801  ENT   0xfffffff8 (D -8)
00000b84  fff51805  JSR   0xfffff518 (TO 0xa0)
00000b88  00000440  SL    0x4 (D 4)
00000b8c  0000100e  LL    0x10 (D 16)
00000b90  0000001c  LX  
00000b94  00000169  ANDI  0x1 (D 1)
00000b98  00000086  BNZ   <fwd>
00000b9c  0000cc08  LEAG  0xcc (D 204)
00000ba0  0000009d  PSHA
00000ba4  fff98c05  JSR   0xfffff98c (TO 0x534)
00000ba8  00000801  ENT   0x8 (D 8)
os.c  451: 
os.c  452:   b->next->prev = b->prev;
00000bac  0000100e  LL    0x10 (D 16)
00000bb0  00000c1c  LX    0xc (D 12)
00000bb4  00000854  ADDI  0x8 (D 8)
00000bb8  0000009d  PSHA
00000bbc  0000180e  LL    0x18 (D 24)
00000bc0  0000081c  LX    0x8 (D 8)
00000bc4  000000a1  POPB
00000bc8  0000004a  SX  
os.c  453:   b->prev->next = b->next;
00000bcc  0000100e  LL    0x10 (D 16)
00000bd0  0000081c  LX    0x8 (D 8)
00000bd4  00000c54  ADDI  0xc (D 12)
00000bd8  0000009d  PSHA
00000bdc  0000180e  LL    0x18 (D 24)
00000be0  00000c1c  LX    0xc (D 12)
00000be4  000000a1  POPB
00000be8  0000004a  SX  
os.c  454:   b->next = bfreelist.next;
00000bec  0000100e  LL    0x10 (D 16)
00000bf0  00000c54  ADDI  0xc (D 12)
00000bf4  0000003e  LBA 
00000bf8  0022d015  LG    0x22d0 (D 8912)
00000bfc  0000004a  SX  
os.c  455:   b->prev = &bfreelist;
00000c00  0000100e  LL    0x10 (D 16)
00000c04  00000854  ADDI  0x8 (D 8)
00000c08  0000009d  PSHA
00000c0c  0022c408  LEAG  0x22c4 (D 8900)
00000c10  000000a1  POPB
00000c14  0000004a  SX  
os.c  456:   bfreelist.next->prev = b;
00000c18  0022d015  LG    0x22d0 (D 8912)
00000c1c  00000854  ADDI  0x8 (D 8)
00000c20  0000003e  LBA 
00000c24  0000100e  LL    0x10 (D 16)
00000c28  0000004a  SX  
os.c  457:   bfreelist.next = b;
00000c2c  0000100e  LL    0x10 (D 16)
00000c30  0022d045  SG    0x22d0 (D 8912)
os.c  458:   b->flags &= ~B_BUSY;
00000c34  0000100e  LL    0x10 (D 16)
00000c38  0000003e  LBA 
00000c3c  0000001c  LX  
00000c40  fffffe69  ANDI  0xfffffffe (D -2)
00000c44  0000004a  SX  
os.c  459:   wakeup(b);
00000c48  0000100e  LL    0x10 (D 16)
00000c4c  0000009d  PSHA
00000c50  00064405  JSR   <fwd>
00000c54  00000801  ENT   0x8 (D 8)
os.c  460:   splx(e);
00000c58  0000040e  LL    0x4 (D 4)
00000c5c  0000009d  PSHA
00000c60  fff44405  JSR   0xfffff444 (TO 0xa8)
00000c64  00000801  ENT   0x8 (D 8)
os.c  461: }
os.c  462: 
os.c  463: // file system implementation.  four layers:
os.c  464: //   Blocks      - allocator for disk blocks.
os.c  465: //   Files       - inode allocator, reading, writing, metadata.
os.c  466: //   Directories - inode with special contents (list of other inodes!)
os.c  467: //   Names
os.c  468: 
os.c  469: // zero a block
os.c  470: bzero(uint b)  // XXX only called in bfree
00000c68  00000802  LEV   0x8 (D 8)
os.c  471: {
os.c  472:   struct buf *bp;
os.c  473:   bp = bread(b);
00000c6c  fffff801  ENT   0xfffffff8 (D -8)
00000c70  0000100e  LL    0x10 (D 16)
00000c74  0000009d  PSHA
00000c78  fffe7805  JSR   0xfffffe78 (TO 0xaf4)
00000c7c  00000801  ENT   0x8 (D 8)
00000c80  00000440  SL    0x4 (D 4)
os.c  474:   memset(bp->data, 0, PAGE);
00000c84  0010009e  PSHI  0x1000 (D 4096)
00000c88  0000009e  PSHI  0x0 (D 0)
00000c8c  0000140e  LL    0x14 (D 20)
00000c90  0000101c  LX    0x10 (D 16)
00000c94  0000009d  PSHA
00000c98  fff37c05  JSR   0xfffff37c (TO 0x18)
00000c9c  00001801  ENT   0x18 (D 24)
os.c  475:   bwrite(bp);
00000ca0  0000040e  LL    0x4 (D 4)
00000ca4  0000009d  PSHA
00000ca8  fffe8c05  JSR   0xfffffe8c (TO 0xb38)
00000cac  00000801  ENT   0x8 (D 8)
os.c  476:   brelse(bp);
00000cb0  0000040e  LL    0x4 (D 4)
00000cb4  0000009d  PSHA
00000cb8  fffec405  JSR   0xfffffec4 (TO 0xb80)
00000cbc  00000801  ENT   0x8 (D 8)
os.c  477: }
os.c  478: 
os.c  479: // allocate a disk block
os.c  480: uint balloc()
00000cc0  00000802  LEV   0x8 (D 8)
os.c  481: {
os.c  482:   int b, bi, bb;
os.c  483:   struct buf *bp;
os.c  484: 
os.c  485:   for (b = 0; b < 16; b++) {
00000cc4  fffff001  ENT   0xfffffff0 (D -16)
00000cc8  00000023  LI    0x0 (D 0)
00000ccc  00000c40  SL    0xc (D 12)
00000cd0  00000003  JMP   <fwd>
os.c  486:     bp = bread(b);
00000cd4  00000c0e  LL    0xc (D 12)
00000cd8  0000009d  PSHA
00000cdc  fffe1405  JSR   0xfffffe14 (TO 0xaf4)
00000ce0  00000801  ENT   0x8 (D 8)
00000ce4  00000040  SL    0x0 (D 0)
os.c  487:     for (bi = 0; bi < 4096; bi++) {
00000ce8  00000023  LI    0x0 (D 0)
00000cec  00000840  SL    0x8 (D 8)
00000cf0  00000003  JMP   <fwd>
os.c  488:       if (bp->data[bi] == 0xff) continue;
00000cf4  0000000e  LL    0x0 (D 0)
00000cf8  0000101c  LX    0x10 (D 16)
00000cfc  00000855  ADDL  0x8 (D 8)
00000d00  00000020  LXB 
00000d04  0000ff3b  LBI   0xff (D 255)
00000d08  0000008a  BNE   <fwd>
00000d0c  00000003  JMP   <fwd>
os.c  489:       for (bb = 0; bb < 8; bb++) {
00000d10  00000023  LI    0x0 (D 0)
00000d14  00000440  SL    0x4 (D 4)
00000d18  00000003  JMP   <fwd>
os.c  490:         if (bp->data[bi] & (1 << bb)) continue; // is block free?
00000d1c  0000000e  LL    0x0 (D 0)
00000d20  0000101c  LX    0x10 (D 16)
00000d24  00000855  ADDL  0x8 (D 8)
00000d28  00000020  LXB 
00000d2c  0000009d  PSHA
00000d30  00000123  LI    0x1 (D 1)
00000d34  00000c73  SHLL  0xc (D 12)
00000d38  000000a1  POPB
00000d3c  00000068  AND 
00000d40  00000084  BZ    <fwd>
00000d44  00000003  JMP   <fwd>
os.c  491:         bp->data[bi] |= (1 << bb);  // mark block in use
00000d48  00000123  LI    0x1 (D 1)
00000d4c  00000473  SHLL  0x4 (D 4)
00000d50  0000009d  PSHA
00000d54  0000080e  LL    0x8 (D 8)
00000d58  0000101c  LX    0x10 (D 16)
00000d5c  00001055  ADDL  0x10 (D 16)
00000d60  0000003e  LBA 
00000d64  00000020  LXB 
00000d68  0000006d  ORL 
00000d6c  00000801  ENT   0x8 (D 8)
00000d70  0000004c  SXB 
os.c  492:         bwrite(bp);
00000d74  0000000e  LL    0x0 (D 0)
00000d78  0000009d  PSHA
00000d7c  fffdb805  JSR   0xfffffdb8 (TO 0xb38)
00000d80  00000801  ENT   0x8 (D 8)
os.c  493:         brelse(bp);
00000d84  0000000e  LL    0x0 (D 0)
00000d88  0000009d  PSHA
00000d8c  fffdf005  JSR   0xfffffdf0 (TO 0xb80)
00000d90  00000801  ENT   0x8 (D 8)
os.c  494:         return b*(4096*8) + bi*8 + bb;
00000d94  0000080e  LL    0x8 (D 8)
00000d98  0000085a  MULI  0x8 (D 8)
00000d9c  0000009d  PSHA
00000da0  0000140e  LL    0x14 (D 20)
00000da4  0080005a  MULI  0x8000 (D 32768)
00000da8  000000a1  POPB
00000dac  00000053  ADD 
00000db0  00000455  ADDL  0x4 (D 4)
00000db4  00001002  LEV   0x10 (D 16)
os.c  495:       }
os.c  496:     }
00000db8  0000040e  LL    0x4 (D 4)
00000dbc  ffffff57  SUBI  0xffffffff (D -1)
00000dc0  00000440  SL    0x4 (D 4)
00000dc4  0000040e  LL    0x4 (D 4)
00000dc8  0000083b  LBI   0x8 (D 8)
00000dcc  0000008c  BLT   <fwd>
os.c  497:     brelse(bp);
00000dd0  0000080e  LL    0x8 (D 8)
00000dd4  ffffff57  SUBI  0xffffffff (D -1)
00000dd8  00000840  SL    0x8 (D 8)
00000ddc  0000080e  LL    0x8 (D 8)
00000de0  0010003b  LBI   0x1000 (D 4096)
00000de4  0000008c  BLT   <fwd>
00000de8  0000000e  LL    0x0 (D 0)
00000dec  0000009d  PSHA
00000df0  fffd8c05  JSR   0xfffffd8c (TO 0xb80)
00000df4  00000801  ENT   0x8 (D 8)
os.c  498:   }
os.c  499:   panic("balloc: out of blocks");
00000df8  00000c0e  LL    0xc (D 12)
00000dfc  ffffff57  SUBI  0xffffffff (D -1)
00000e00  00000c40  SL    0xc (D 12)
00000e04  00000c0e  LL    0xc (D 12)
00000e08  0000103b  LBI   0x10 (D 16)
00000e0c  0000008c  BLT   <fwd>
00000e10  0000d308  LEAG  0xd3 (D 211)
00000e14  0000009d  PSHA
00000e18  fff71805  JSR   0xfffff718 (TO 0x534)
00000e1c  00000801  ENT   0x8 (D 8)
os.c  500: }
os.c  501: 
os.c  502: // free a disk block
os.c  503: bfree(uint b)
00000e20  00001002  LEV   0x10 (D 16)
os.c  504: {
os.c  505:   int bi, m;
os.c  506:   struct buf *bp;
os.c  507: 
os.c  508:   bzero(b);
00000e24  fffff001  ENT   0xfffffff0 (D -16)
00000e28  0000180e  LL    0x18 (D 24)
00000e2c  0000009d  PSHA
00000e30  fffe3805  JSR   0xfffffe38 (TO 0xc6c)
00000e34  00000801  ENT   0x8 (D 8)
os.c  509: 
os.c  510:   bp = bread(b / (4096*8));
00000e38  0000180e  LL    0x18 (D 24)
00000e3c  00800060  DVUI  0x8000 (D 32768)
00000e40  0000009d  PSHA
00000e44  fffcac05  JSR   0xfffffcac (TO 0xaf4)
00000e48  00000801  ENT   0x8 (D 8)
00000e4c  00000440  SL    0x4 (D 4)
os.c  511:   m = 1 << (b & 7);
00000e50  0000180e  LL    0x18 (D 24)
00000e54  00000769  ANDI  0x7 (D 7)
00000e58  0000003e  LBA 
00000e5c  00000123  LI    0x1 (D 1)
00000e60  00000071  SHL 
00000e64  00000840  SL    0x8 (D 8)
os.c  512:   b = (b / 8) & 4095;
00000e68  0000180e  LL    0x18 (D 24)
00000e6c  00000860  DVUI  0x8 (D 8)
00000e70  000fff69  ANDI  0xfff (D 4095)
00000e74  00001840  SL    0x18 (D 24)
os.c  513:   if (!(bp->data[b] & m)) panic("freeing free block");
00000e78  0000040e  LL    0x4 (D 4)
00000e7c  0000101c  LX    0x10 (D 16)
00000e80  00001855  ADDL  0x18 (D 24)
00000e84  00000020  LXB 
00000e88  0000086a  ANDL  0x8 (D 8)
00000e8c  00000086  BNZ   <fwd>
00000e90  0000e908  LEAG  0xe9 (D 233)
00000e94  0000009d  PSHA
00000e98  fff69805  JSR   0xfffff698 (TO 0x534)
00000e9c  00000801  ENT   0x8 (D 8)
os.c  514:   bp->data[b] &= ~m;  // mark block free on disk
00000ea0  0000080e  LL    0x8 (D 8)
00000ea4  ffffff6f  XORI  0xffffffff (D -1)
00000ea8  0000009d  PSHA
00000eac  00000c0e  LL    0xc (D 12)
00000eb0  0000101c  LX    0x10 (D 16)
00000eb4  00002055  ADDL  0x20 (D 32)
00000eb8  0000003e  LBA 
00000ebc  00000020  LXB 
00000ec0  0000006a  ANDL
00000ec4  00000801  ENT   0x8 (D 8)
00000ec8  0000004c  SXB 
os.c  515:   bwrite(bp);
00000ecc  0000040e  LL    0x4 (D 4)
00000ed0  0000009d  PSHA
00000ed4  fffc6005  JSR   0xfffffc60 (TO 0xb38)
00000ed8  00000801  ENT   0x8 (D 8)
os.c  516:   brelse(bp);
00000edc  0000040e  LL    0x4 (D 4)
00000ee0  0000009d  PSHA
00000ee4  fffc9805  JSR   0xfffffc98 (TO 0xb80)
00000ee8  00000801  ENT   0x8 (D 8)
os.c  517: }
os.c  518: 
os.c  519: // Inodes:
os.c  520: // An inode is a single, unnamed file in the file system.  The inode disk structure holds metadata
os.c  521: // (the type, device numbers, and data size) along with a list of blocks where the data can be found.
os.c  522: //
os.c  523: // The kernel keeps a cache of the in-use on-disk structures to provide a place for synchronizing access
os.c  524: // to inodes shared between multiple processes.
os.c  525: // 
os.c  526: // ip->ref counts the number of pointer references to this cached inode; references are typically kept in
os.c  527: // struct file and in u->cwd.  When ip->ref falls to zero, the inode is no longer cached.  It is an error
os.c  528: // to use an inode without holding a reference to it.
os.c  529: //
os.c  530: // Processes are only allowed to read and write inode metadata and contents when holding the inode's lock,
os.c  531: // represented by the I_BUSY flag in the in-memory copy.  Because inode locks are held during disk accesses, 
os.c  532: // they are implemented using a flag rather than with spin locks.  Callers are responsible for locking
os.c  533: // inodes before passing them to routines in this file; leaving this responsibility with the caller makes
os.c  534: // it possible for them to create arbitrarily-sized atomic operations.
os.c  535: //
os.c  536: // To give maximum control over locking to the callers, the routines in this file that return inode pointers 
os.c  537: // return pointers to *unlocked* inodes.  It is the callers' responsibility to lock them before using them.
os.c  538: // A non-zero ip->ref keeps these unlocked inodes in the cache.
os.c  539: 
os.c  540: // find the inode with number inum and return the in-memory copy.  does not lock the inode and does not read it from disk
os.c  541: struct inode *iget(uint inum)
00000eec  00001002  LEV   0x10 (D 16)
os.c  542: {
os.c  543:   struct inode *ip, *empty; int e = splhi();
os.c  544: 
os.c  545:   // is the inode already cached
os.c  546:   empty = 0;
00000ef0  fffff001  ENT   0xfffffff0 (D -16)
00000ef4  fff1a805  JSR   0xfffff1a8 (TO 0xa0)
00000ef8  00000440  SL    0x4 (D 4)
00000efc  00000023  LI    0x0 (D 0)
00000f00  00000840  SL    0x8 (D 8)
os.c  547:   for (ip = &inode[0]; ip < &inode[NINODE]; ip++) {
00000f04  0022d808  LEAG  0x22d8 (D 8920)
00000f08  00000c40  SL    0xc (D 12)
00000f0c  00000003  JMP   <fwd>
os.c  548:     if (ip->ref > 0 && ip->inum == inum) {
00000f10  00000c0e  LL    0xc (D 12)
00000f14  0000041c  LX    0x4 (D 4)
00000f18  0000003e  LBA 
00000f1c  00000023  LI    0x0 (D 0)
00000f20  0000008f  BGE   <fwd>
00000f24  00000c0e  LL    0xc (D 12)
00000f28  0000001c  LX  
00000f2c  00001826  LBL   0x18 (D 24)
00000f30  000f208a  BNE   <fwd>
os.c  549:       ip->ref++;
00000f34  00000c0e  LL    0xc (D 12)
00000f38  00000454  ADDI  0x4 (D 4)
00000f3c  0000003e  LBA 
00000f40  0000001c  LX  
00000f44  ffffff57  SUBI  0xffffffff (D -1)
00000f48  0000004a  SX  
os.c  550:       splx(e);
00000f4c  0000040e  LL    0x4 (D 4)
00000f50  0000009d  PSHA
00000f54  fff15005  JSR   0xfffff150 (TO 0xa8)
00000f58  00000801  ENT   0x8 (D 8)
os.c  551:       return ip;
00000f5c  00000c0e  LL    0xc (D 12)
00000f60  00001002  LEV   0x10 (D 16)
os.c  552:     }
os.c  553:     if (!empty && !ip->ref) empty = ip; // remember empty slot
00000f64  0000080e  LL    0x8 (D 8)
00000f68  00000086  BNZ   <fwd>
00000f6c  00000c0e  LL    0xc (D 12)
00000f70  0000041c  LX    0x4 (D 4)
00000f74  000f6886  BNZ   <fwd>
00000f78  00000c0e  LL    0xc (D 12)
00000f7c  00000840  SL    0x8 (D 8)
os.c  554:   }
os.c  555: 
os.c  556:   // recycle an inode cache entry
os.c  557:   if (!empty) panic("iget: no inodes");
00000f80  00000c0e  LL    0xc (D 12)
00000f84  fff06857  SUBI  0xfffff068 (D -3992)
00000f88  00000c40  SL    0xc (D 12)
00000f8c  032e8808  LEAG  0x32e88 (D 208520)
00000f90  0000003e  LBA 
00000f94  00000c0e  LL    0xc (D 12)
00000f98  0000008d  BLTU  <fwd>
00000f9c  0000080e  LL    0x8 (D 8)
00000fa0  00000086  BNZ   <fwd>
00000fa4  0000fc08  LEAG  0xfc (D 252)
00000fa8  0000009d  PSHA
00000fac  fff58405  JSR   0xfffff584 (TO 0x534)
00000fb0  00000801  ENT   0x8 (D 8)
os.c  558: 
os.c  559:   ip = empty;
00000fb4  0000080e  LL    0x8 (D 8)
00000fb8  00000c40  SL    0xc (D 12)
os.c  560:   ip->inum = inum;
00000fbc  0000180e  LL    0x18 (D 24)
00000fc0  00000c26  LBL   0xc (D 12)
00000fc4  0000004a  SX  
os.c  561:   ip->ref = 1;
00000fc8  00000c0e  LL    0xc (D 12)
00000fcc  00000454  ADDI  0x4 (D 4)
00000fd0  0000003e  LBA 
00000fd4  00000123  LI    0x1 (D 1)
00000fd8  0000004a  SX  
os.c  562:   ip->flags = 0;
00000fdc  00000c0e  LL    0xc (D 12)
00000fe0  00000854  ADDI  0x8 (D 8)
00000fe4  0000003e  LBA 
00000fe8  00000023  LI    0x0 (D 0)
00000fec  0000004a  SX  
os.c  563:   splx(e);
00000ff0  0000040e  LL    0x4 (D 4)
00000ff4  0000009d  PSHA
00000ff8  fff0ac05  JSR   0xfffff0ac (TO 0xa8)
00000ffc  00000801  ENT   0x8 (D 8)
os.c  564:   
os.c  565:   return ip;
00001000  00000c0e  LL    0xc (D 12)
00001004  00001002  LEV   0x10 (D 16)
os.c  566: }
os.c  567: 
os.c  568: // allocate a new inode with the given mode
os.c  569: struct inode *ialloc(ushort mode)
00001008  00001002  LEV   0x10 (D 16)
os.c  570: {
os.c  571:   int inum;
os.c  572:   struct buf *bp;
os.c  573:   struct dinode *dip;
os.c  574: 
os.c  575:   inum = balloc();
0000100c  fffff001  ENT   0xfffffff0 (D -16)
00001010  fffcb005  JSR   0xfffffcb0 (TO 0xcc4)
00001014  00000c40  SL    0xc (D 12)
os.c  576:   bp = bread(inum);
00001018  00000c0e  LL    0xc (D 12)
0000101c  0000009d  PSHA
00001020  fffad005  JSR   0xfffffad0 (TO 0xaf4)
00001024  00000801  ENT   0x8 (D 8)
00001028  00000840  SL    0x8 (D 8)
os.c  577:   dip = (struct dinode *)bp->data;
0000102c  0000080e  LL    0x8 (D 8)
00001030  0000101c  LX    0x10 (D 16)
00001034  00000440  SL    0x4 (D 4)
os.c  578:   memset(dip, 0, sizeof(*dip));
00001038  0010009e  PSHI  0x1000 (D 4096)
0000103c  0000009e  PSHI  0x0 (D 0)
00001040  0000140e  LL    0x14 (D 20)
00001044  0000009d  PSHA
00001048  ffefcc05  JSR   0xffffefcc (TO 0x18)
0000104c  00001801  ENT   0x18 (D 24)
os.c  579:   dip->mode = mode;
00001050  00001810  LLH   0x18 (D 24)
00001054  00000426  LBL   0x4 (D 4)
00001058  0000004b  SXH 
os.c  580:   bwrite(bp);   // mark it allocated on the disk
0000105c  0000080e  LL    0x8 (D 8)
00001060  0000009d  PSHA
00001064  fffad005  JSR   0xfffffad0 (TO 0xb38)
00001068  00000801  ENT   0x8 (D 8)
os.c  581:   brelse(bp);
0000106c  0000080e  LL    0x8 (D 8)
00001070  0000009d  PSHA
00001074  fffb0805  JSR   0xfffffb08 (TO 0xb80)
00001078  00000801  ENT   0x8 (D 8)
os.c  582:   return iget(inum);
0000107c  00000c0e  LL    0xc (D 12)
00001080  0000009d  PSHA
00001084  fffe6805  JSR   0xfffffe68 (TO 0xef0)
00001088  00000801  ENT   0x8 (D 8)
0000108c  00001002  LEV   0x10 (D 16)
os.c  583: }
os.c  584: 
os.c  585: // copy modified memory inode to disk
os.c  586: iupdate(struct inode *ip)
00001090  00001002  LEV   0x10 (D 16)
os.c  587: {
os.c  588:   struct buf *bp;
os.c  589:   struct dinode *dip;
os.c  590: 
os.c  591:   bp = bread(ip->inum);
00001094  fffff801  ENT   0xfffffff8 (D -8)
00001098  0000100e  LL    0x10 (D 16)
0000109c  0000001c  LX  
000010a0  0000009d  PSHA
000010a4  fffa4c05  JSR   0xfffffa4c (TO 0xaf4)
000010a8  00000801  ENT   0x8 (D 8)
000010ac  00000440  SL    0x4 (D 4)
os.c  592:   dip = (struct dinode *)bp->data;
000010b0  0000040e  LL    0x4 (D 4)
000010b4  0000101c  LX    0x10 (D 16)
000010b8  00000040  SL    0x0 (D 0)
os.c  593:   dip->mode  = ip->mode;
000010bc  0000100e  LL    0x10 (D 16)
000010c0  00000c1e  LXH   0xc (D 12)
000010c4  00000026  LBL   0x0 (D 0)
000010c8  0000004b  SXH 
os.c  594:   dip->nlink = ip->nlink;
000010cc  0000000e  LL    0x0 (D 0)
000010d0  00000454  ADDI  0x4 (D 4)
000010d4  0000009d  PSHA
000010d8  0000180e  LL    0x18 (D 24)
000010dc  0000101c  LX    0x10 (D 16)
000010e0  000000a1  POPB
000010e4  0000004a  SX  
os.c  595:   dip->size = ip->size;
000010e8  0000000e  LL    0x0 (D 0)
000010ec  00000854  ADDI  0x8 (D 8)
000010f0  0000009d  PSHA
000010f4  0000180e  LL    0x18 (D 24)
000010f8  0000141c  LX    0x14 (D 20)
000010fc  000000a1  POPB
00001100  0000004a  SX  
os.c  596: //  printf("iupdate() memcpy(dip->dir, ip->dir, %d)\n",sizeof(ip->dir));
os.c  597:   memcpy(dip->dir, ip->dir, sizeof(ip->dir));
00001104  0007809e  PSHI  0x780 (D 1920)
00001108  0000180e  LL    0x18 (D 24)
0000110c  00001854  ADDI  0x18 (D 24)
00001110  0000009d  PSHA
00001114  0000100e  LL    0x10 (D 16)
00001118  00005054  ADDI  0x50 (D 80)
0000111c  0000009d  PSHA
00001120  ffeedc05  JSR   0xffffeedc (TO 0x0)
00001124  00001801  ENT   0x18 (D 24)
os.c  598:   memcpy(dip->idir, ip->idir, sizeof(ip->idir));
00001128  0008009e  PSHI  0x800 (D 2048)
0000112c  0000180e  LL    0x18 (D 24)
00001130  00079854  ADDI  0x798 (D 1944)
00001134  0000009d  PSHA
00001138  0000100e  LL    0x10 (D 16)
0000113c  0007d054  ADDI  0x7d0 (D 2000)
00001140  0000009d  PSHA
00001144  ffeeb805  JSR   0xffffeeb8 (TO 0x0)
00001148  00001801  ENT   0x18 (D 24)
os.c  599:   bwrite(bp);
0000114c  0000040e  LL    0x4 (D 4)
00001150  0000009d  PSHA
00001154  fff9e005  JSR   0xfffff9e0 (TO 0xb38)
00001158  00000801  ENT   0x8 (D 8)
os.c  600:   brelse(bp);
0000115c  0000040e  LL    0x4 (D 4)
00001160  0000009d  PSHA
00001164  fffa1805  JSR   0xfffffa18 (TO 0xb80)
00001168  00000801  ENT   0x8 (D 8)
os.c  601: }
os.c  602: 
os.c  603: // increment reference count for ip
os.c  604: idup(struct inode *ip)
0000116c  00000802  LEV   0x8 (D 8)
os.c  605: {
os.c  606:   int e = splhi();
os.c  607:   ip->ref++;
00001170  fffff801  ENT   0xfffffff8 (D -8)
00001174  ffef2805  JSR   0xffffef28 (TO 0xa0)
00001178  00000440  SL    0x4 (D 4)
0000117c  0000100e  LL    0x10 (D 16)
00001180  00000454  ADDI  0x4 (D 4)
00001184  0000003e  LBA 
00001188  0000001c  LX  
0000118c  ffffff57  SUBI  0xffffffff (D -1)
00001190  0000004a  SX  
os.c  608:   splx(e);
00001194  0000040e  LL    0x4 (D 4)
00001198  0000009d  PSHA
0000119c  ffef0805  JSR   0xffffef08 (TO 0xa8)
000011a0  00000801  ENT   0x8 (D 8)
os.c  609: }
os.c  610: 
os.c  611: // lock the given inode.  read the inode from disk if necessary
os.c  612: ilock(struct inode *ip)
000011a4  00000802  LEV   0x8 (D 8)
os.c  613: {
os.c  614:   struct buf *bp;
os.c  615:   struct dinode *dip;
os.c  616:   int e = splhi();
os.c  617: 
os.c  618:   if (!ip || ip->ref < 1) panic("ilock");
000011a8  fffff001  ENT   0xfffffff0 (D -16)
000011ac  ffeef005  JSR   0xffffeef0 (TO 0xa0)
000011b0  00000440  SL    0x4 (D 4)
000011b4  0000180e  LL    0x18 (D 24)
000011b8  00000084  BZ    <fwd>
000011bc  0000180e  LL    0x18 (D 24)
000011c0  0000041c  LX    0x4 (D 4)
000011c4  0000013b  LBI   0x1 (D 1)
000011c8  0000008f  BGE   <fwd>
000011cc  00010c08  LEAG  0x10c (D 268)
000011d0  0000009d  PSHA
000011d4  fff35c05  JSR   0xfffff35c (TO 0x534)
000011d8  00000801  ENT   0x8 (D 8)
os.c  619: 
os.c  620:   while (ip->flags & I_BUSY) sleep(ip);
000011dc  00000003  JMP   <fwd>
000011e0  0000180e  LL    0x18 (D 24)
000011e4  0000009d  PSHA
000011e8  000a5005  JSR   <fwd>
000011ec  00000801  ENT   0x8 (D 8)
os.c  621:   ip->flags |= I_BUSY;
000011f0  0000180e  LL    0x18 (D 24)
000011f4  0000081c  LX    0x8 (D 8)
000011f8  00000169  ANDI  0x1 (D 1)
000011fc  00000086  BNZ   <fwd>
00001200  0000180e  LL    0x18 (D 24)
00001204  00000854  ADDI  0x8 (D 8)
00001208  0000003e  LBA 
0000120c  0000001c  LX  
00001210  0000016c  ORI   0x1 (D 1)
00001214  0000004a  SX  
os.c  622:   splx(e);
00001218  0000040e  LL    0x4 (D 4)
0000121c  0000009d  PSHA
00001220  ffee8405  JSR   0xffffee84 (TO 0xa8)
00001224  00000801  ENT   0x8 (D 8)
os.c  623:   
os.c  624:   if (!(ip->flags & I_VALID)) {
00001228  0000180e  LL    0x18 (D 24)
0000122c  0000081c  LX    0x8 (D 8)
00001230  00000269  ANDI  0x2 (D 2)
00001234  00000086  BNZ   <fwd>
os.c  625:     bp = bread(ip->inum);
00001238  0000180e  LL    0x18 (D 24)
0000123c  0000001c  LX  
00001240  0000009d  PSHA
00001244  fff8ac05  JSR   0xfffff8ac (TO 0xaf4)
00001248  00000801  ENT   0x8 (D 8)
0000124c  00000c40  SL    0xc (D 12)
os.c  626:     dip = (struct dinode *)bp->data;
00001250  00000c0e  LL    0xc (D 12)
00001254  0000101c  LX    0x10 (D 16)
00001258  00000840  SL    0x8 (D 8)
os.c  627:     ip->mode  = dip->mode;
0000125c  0000180e  LL    0x18 (D 24)
00001260  00000c54  ADDI  0xc (D 12)
00001264  0000009d  PSHA
00001268  0000100e  LL    0x10 (D 16)
0000126c  0000001e  LXH 
00001270  000000a1  POPB
00001274  0000004b  SXH 
os.c  628:     ip->nlink = dip->nlink;
00001278  0000180e  LL    0x18 (D 24)
0000127c  00001054  ADDI  0x10 (D 16)
00001280  0000009d  PSHA
00001284  0000100e  LL    0x10 (D 16)
00001288  0000041c  LX    0x4 (D 4)
0000128c  000000a1  POPB
00001290  0000004a  SX  
os.c  629:     ip->size = dip->size;
00001294  0000180e  LL    0x18 (D 24)
00001298  00001454  ADDI  0x14 (D 20)
0000129c  0000009d  PSHA
000012a0  0000100e  LL    0x10 (D 16)
000012a4  0000081c  LX    0x8 (D 8)
000012a8  000000a1  POPB
000012ac  0000004a  SX  
os.c  630:     memcpy(ip->dir,  dip->dir,  sizeof(ip->dir));
000012b0  0007809e  PSHI  0x780 (D 1920)
000012b4  0000100e  LL    0x10 (D 16)
000012b8  00005054  ADDI  0x50 (D 80)
000012bc  0000009d  PSHA
000012c0  0000280e  LL    0x28 (D 40)
000012c4  00001854  ADDI  0x18 (D 24)
000012c8  0000009d  PSHA
000012cc  ffed3005  JSR   0xffffed30 (TO 0x0)
000012d0  00001801  ENT   0x18 (D 24)
os.c  631:     memcpy(ip->idir, dip->idir, sizeof(ip->idir));
000012d4  0008009e  PSHI  0x800 (D 2048)
000012d8  0000100e  LL    0x10 (D 16)
000012dc  0007d054  ADDI  0x7d0 (D 2000)
000012e0  0000009d  PSHA
000012e4  0000280e  LL    0x28 (D 40)
000012e8  00079854  ADDI  0x798 (D 1944)
000012ec  0000009d  PSHA
000012f0  ffed0c05  JSR   0xffffed0c (TO 0x0)
000012f4  00001801  ENT   0x18 (D 24)
os.c  632:     brelse(bp);
000012f8  00000c0e  LL    0xc (D 12)
000012fc  0000009d  PSHA
00001300  fff87c05  JSR   0xfffff87c (TO 0xb80)
00001304  00000801  ENT   0x8 (D 8)
os.c  633:     ip->flags |= I_VALID;
00001308  0000180e  LL    0x18 (D 24)
0000130c  00000854  ADDI  0x8 (D 8)
00001310  0000003e  LBA 
00001314  0000001c  LX  
00001318  0000026c  ORI   0x2 (D 2)
0000131c  0000004a  SX  
os.c  634:     if (!ip->mode) panic("ilock: no mode");
00001320  0000180e  LL    0x18 (D 24)
00001324  00000c1e  LXH   0xc (D 12)
00001328  00000086  BNZ   <fwd>
0000132c  00011208  LEAG  0x112 (D 274)
00001330  0000009d  PSHA
00001334  fff1fc05  JSR   0xfffff1fc (TO 0x534)
00001338  00000801  ENT   0x8 (D 8)
os.c  635:   }
os.c  636: }
os.c  637: 
os.c  638: // unlock the given inode
os.c  639: iunlock(struct inode *ip)
0000133c  00001002  LEV   0x10 (D 16)
os.c  640: {
os.c  641:   int e = splhi();
os.c  642:   if (!ip || !(ip->flags & I_BUSY) || ip->ref < 1) panic("iunlock");
00001340  fffff801  ENT   0xfffffff8 (D -8)
00001344  ffed5805  JSR   0xffffed58 (TO 0xa0)
00001348  00000440  SL    0x4 (D 4)
0000134c  0000100e  LL    0x10 (D 16)
00001350  00000084  BZ    <fwd>
00001354  0000100e  LL    0x10 (D 16)
00001358  0000081c  LX    0x8 (D 8)
0000135c  00000169  ANDI  0x1 (D 1)
00001360  00135084  BZ    <fwd>
00001364  0000100e  LL    0x10 (D 16)
00001368  0000041c  LX    0x4 (D 4)
0000136c  0000013b  LBI   0x1 (D 1)
00001370  0000008f  BGE   <fwd>
00001374  00012108  LEAG  0x121 (D 289)
00001378  0000009d  PSHA
0000137c  fff1b405  JSR   0xfffff1b4 (TO 0x534)
00001380  00000801  ENT   0x8 (D 8)
os.c  643: 
os.c  644:   ip->flags &= ~I_BUSY;
00001384  0000100e  LL    0x10 (D 16)
00001388  00000854  ADDI  0x8 (D 8)
0000138c  0000003e  LBA 
00001390  0000001c  LX  
00001394  fffffe69  ANDI  0xfffffffe (D -2)
00001398  0000004a  SX  
os.c  645:   wakeup(ip);
0000139c  0000100e  LL    0x10 (D 16)
000013a0  0000009d  PSHA
000013a4  000c5005  JSR   <fwd>
000013a8  00000801  ENT   0x8 (D 8)
os.c  646:   splx(e);
000013ac  0000040e  LL    0x4 (D 4)
000013b0  0000009d  PSHA
000013b4  ffecf005  JSR   0xffffecf0 (TO 0xa8)
000013b8  00000801  ENT   0x8 (D 8)
os.c  647: }
os.c  648: 
os.c  649: // drop a reference to an in-memory inode
os.c  650: // if that was the last reference, the inode cache entry can be recycled
os.c  651: // if that was the last reference and the inode has no links
os.c  652: // to it, free the inode (and its content) on disk
os.c  653: iput(struct inode *ip)
000013bc  00000802  LEV   0x8 (D 8)
os.c  654: {
os.c  655:   int e = splhi();
os.c  656:   if (ip->ref == 1 && (ip->flags & I_VALID) && !ip->nlink) {
000013c0  fffff801  ENT   0xfffffff8 (D -8)
000013c4  ffecd805  JSR   0xffffecd8 (TO 0xa0)
000013c8  00000440  SL    0x4 (D 4)
000013cc  0000100e  LL    0x10 (D 16)
000013d0  0000041c  LX    0x4 (D 4)
000013d4  0000013b  LBI   0x1 (D 1)
000013d8  0000008a  BNE   <fwd>
000013dc  0000100e  LL    0x10 (D 16)
000013e0  0000081c  LX    0x8 (D 8)
000013e4  00000269  ANDI  0x2 (D 2)
000013e8  0013d884  BZ    <fwd>
000013ec  0000100e  LL    0x10 (D 16)
000013f0  0000101c  LX    0x10 (D 16)
000013f4  0013e886  BNZ   <fwd>
os.c  657:     // inode has no links: truncate and free inode
os.c  658:     if (ip->flags & I_BUSY) panic("iput busy");
000013f8  0000100e  LL    0x10 (D 16)
000013fc  0000081c  LX    0x8 (D 8)
00001400  00000169  ANDI  0x1 (D 1)
00001404  00000084  BZ    <fwd>
00001408  00012908  LEAG  0x129 (D 297)
0000140c  0000009d  PSHA
00001410  fff12005  JSR   0xfffff120 (TO 0x534)
00001414  00000801  ENT   0x8 (D 8)
os.c  659:     ip->flags |= I_BUSY;
00001418  0000100e  LL    0x10 (D 16)
0000141c  00000854  ADDI  0x8 (D 8)
00001420  0000003e  LBA 
00001424  0000001c  LX  
00001428  0000016c  ORI   0x1 (D 1)
0000142c  0000004a  SX  
os.c  660:     splx(e);
00001430  0000040e  LL    0x4 (D 4)
00001434  0000009d  PSHA
00001438  ffec6c05  JSR   0xffffec6c (TO 0xa8)
0000143c  00000801  ENT   0x8 (D 8)
os.c  661:     itrunc(ip);
00001440  0000100e  LL    0x10 (D 16)
00001444  0000009d  PSHA
00001448  00000005  JSR   <fwd>
0000144c  00000801  ENT   0x8 (D 8)
os.c  662:     ip->mode = 0;
00001450  0000100e  LL    0x10 (D 16)
00001454  00000c54  ADDI  0xc (D 12)
00001458  0000003e  LBA 
0000145c  00000023  LI    0x0 (D 0)
00001460  0000004b  SXH 
os.c  663:     bfree(ip->inum); 
00001464  0000100e  LL    0x10 (D 16)
00001468  0000001c  LX  
0000146c  0000009d  PSHA
00001470  fff9b005  JSR   0xfffff9b0 (TO 0xe24)
00001474  00000801  ENT   0x8 (D 8)
os.c  664:     e = splhi();
00001478  ffec2405  JSR   0xffffec24 (TO 0xa0)
0000147c  00000440  SL    0x4 (D 4)
os.c  665:     ip->flags = 0;
00001480  0000100e  LL    0x10 (D 16)
00001484  00000854  ADDI  0x8 (D 8)
00001488  0000003e  LBA 
0000148c  00000023  LI    0x0 (D 0)
00001490  0000004a  SX  
os.c  666:     wakeup(ip);
00001494  0000100e  LL    0x10 (D 16)
00001498  0000009d  PSHA
0000149c  0013a405  JSR   <fwd>
000014a0  00000801  ENT   0x8 (D 8)
os.c  667:   }
os.c  668:   ip->ref--;
000014a4  0000100e  LL    0x10 (D 16)
000014a8  00000454  ADDI  0x4 (D 4)
000014ac  0000003e  LBA 
000014b0  0000001c  LX  
000014b4  00000157  SUBI  0x1 (D 1)
000014b8  0000004a  SX  
os.c  669:   splx(e);
000014bc  0000040e  LL    0x4 (D 4)
000014c0  0000009d  PSHA
000014c4  ffebe005  JSR   0xffffebe0 (TO 0xa8)
000014c8  00000801  ENT   0x8 (D 8)
os.c  670: }
os.c  671: 
os.c  672: // common idiom: unlock, then put
os.c  673: iunlockput(struct inode *ip)
000014cc  00000802  LEV   0x8 (D 8)
os.c  674: {
os.c  675:   iunlock(ip);
000014d0  0000080e  LL    0x8 (D 8)
000014d4  0000009d  PSHA
000014d8  fffe6405  JSR   0xfffffe64 (TO 0x1340)
000014dc  00000801  ENT   0x8 (D 8)
os.c  676:   iput(ip);
000014e0  0000080e  LL    0x8 (D 8)
000014e4  0000009d  PSHA
000014e8  fffed405  JSR   0xfffffed4 (TO 0x13c0)
000014ec  00000801  ENT   0x8 (D 8)
os.c  677: }
os.c  678: 
os.c  679: // Inode contents:
os.c  680: // The contents (data) associated with each inode is stored in a sequence of blocks on the disk.
os.c  681: // The first NDIR blocks are listed in ip->dir[].  The next NIDIR blocks are listed in the block ip->idir[].
os.c  682: // Return the disk block address of the nth block in inode ip. If there is no such block, bmap allocates one.
os.c  683: uint bmap(struct inode *ip, uint bn)
000014f0  00000002  LEV   0x0 (D 0)
os.c  684: {
os.c  685:   uint addr, *a;
os.c  686:   struct buf *bp;
os.c  687: 
os.c  688:   if (bn < NDIR) {
000014f4  fffff001  ENT   0xfffffff0 (D -16)
000014f8  0000200e  LL    0x20 (D 32)
000014fc  0001e03b  LBI   0x1e0 (D 480)
00001500  00000090  BGEU  <fwd>
os.c  689:     if (!(addr = ip->dir[bn])) ip->dir[bn] = addr = balloc();
00001504  0000180e  LL    0x18 (D 24)
00001508  00001854  ADDI  0x18 (D 24)
0000150c  0000009d  PSHA
00001510  0000280e  LL    0x28 (D 40)
00001514  0000045a  MULI  0x4 (D 4)
00001518  000000a1  POPB
0000151c  00000053  ADD 
00001520  0000001c  LX  
00001524  00000c40  SL    0xc (D 12)
00001528  00000086  BNZ   <fwd>
0000152c  0000180e  LL    0x18 (D 24)
00001530  00001854  ADDI  0x18 (D 24)
00001534  0000009d  PSHA
00001538  0000280e  LL    0x28 (D 40)
0000153c  0000045a  MULI  0x4 (D 4)
00001540  000000a1  POPB
00001544  00000053  ADD 
00001548  0000009d  PSHA
0000154c  fff77405  JSR   0xfffff774 (TO 0xcc4)
00001550  00001440  SL    0x14 (D 20)
00001554  000000a1  POPB
00001558  0000004a  SX  
os.c  690:     return addr;
0000155c  00000c0e  LL    0xc (D 12)
00001560  00001002  LEV   0x10 (D 16)
os.c  691:   }
os.c  692:   bn -= NDIR;
00001564  0000200e  LL    0x20 (D 32)
00001568  0001e057  SUBI  0x1e0 (D 480)
0000156c  00002040  SL    0x20 (D 32)
os.c  693:   if (bn >= NIDIR * 1024) panic("bmap: out of range");
00001570  0000200e  LL    0x20 (D 32)
00001574  0800003b  LBI   0x80000 (D 524288)
00001578  0000008d  BLTU  <fwd>
0000157c  00013308  LEAG  0x133 (D 307)
00001580  0000009d  PSHA
00001584  ffefac05  JSR   0xffffefac (TO 0x534)
00001588  00000801  ENT   0x8 (D 8)
os.c  694: 
os.c  695:   // load indirect block, allocating if necessary
os.c  696:   if (!(addr = ip->idir[bn / 1024])) ip->idir[bn / 1024] = addr = balloc();
0000158c  0000180e  LL    0x18 (D 24)
00001590  00079854  ADDI  0x798 (D 1944)
00001594  0000009d  PSHA
00001598  0000280e  LL    0x28 (D 40)
0000159c  00040060  DVUI  0x400 (D 1024)
000015a0  0000045a  MULI  0x4 (D 4)
000015a4  000000a1  POPB
000015a8  00000053  ADD 
000015ac  0000001c  LX  
000015b0  00000c40  SL    0xc (D 12)
000015b4  00000086  BNZ   <fwd>
000015b8  0000180e  LL    0x18 (D 24)
000015bc  00079854  ADDI  0x798 (D 1944)
000015c0  0000009d  PSHA
000015c4  0000280e  LL    0x28 (D 40)
000015c8  00040060  DVUI  0x400 (D 1024)
000015cc  0000045a  MULI  0x4 (D 4)
000015d0  000000a1  POPB
000015d4  00000053  ADD 
000015d8  0000009d  PSHA
000015dc  fff6e405  JSR   0xfffff6e4 (TO 0xcc4)
000015e0  00001440  SL    0x14 (D 20)
000015e4  000000a1  POPB
000015e8  0000004a  SX  
os.c  697:   bp = bread(addr);
000015ec  00000c0e  LL    0xc (D 12)
000015f0  0000009d  PSHA
000015f4  fff4fc05  JSR   0xfffff4fc (TO 0xaf4)
000015f8  00000801  ENT   0x8 (D 8)
000015fc  00000440  SL    0x4 (D 4)
os.c  698:   a = (uint *)bp->data;
00001600  0000040e  LL    0x4 (D 4)
00001604  0000101c  LX    0x10 (D 16)
00001608  00000840  SL    0x8 (D 8)
os.c  699:   if (!(addr = a[bn & 1023])) {
0000160c  0000200e  LL    0x20 (D 32)
00001610  0003ff69  ANDI  0x3ff (D 1023)
00001614  0000045a  MULI  0x4 (D 4)
00001618  00000855  ADDL  0x8 (D 8)
0000161c  0000001c  LX  
00001620  00000c40  SL    0xc (D 12)
00001624  00000086  BNZ   <fwd>
os.c  700:     a[bn & 1023] = addr = balloc();
00001628  0000200e  LL    0x20 (D 32)
0000162c  0003ff69  ANDI  0x3ff (D 1023)
00001630  0000045a  MULI  0x4 (D 4)
00001634  00000855  ADDL  0x8 (D 8)
00001638  0000009d  PSHA
0000163c  fff68405  JSR   0xfffff684 (TO 0xcc4)
00001640  00001440  SL    0x14 (D 20)
00001644  000000a1  POPB
00001648  0000004a  SX  
os.c  701:     bwrite(bp);
0000164c  0000040e  LL    0x4 (D 4)
00001650  0000009d  PSHA
00001654  fff4e005  JSR   0xfffff4e0 (TO 0xb38)
00001658  00000801  ENT   0x8 (D 8)
os.c  702:   }
os.c  703:   brelse(bp);
0000165c  0000040e  LL    0x4 (D 4)
00001660  0000009d  PSHA
00001664  fff51805  JSR   0xfffff518 (TO 0xb80)
00001668  00000801  ENT   0x8 (D 8)
os.c  704:   return addr;
0000166c  00000c0e  LL    0xc (D 12)
00001670  00001002  LEV   0x10 (D 16)
os.c  705: }
os.c  706: 
os.c  707: // truncate inode (discard contents)
os.c  708: // only called when the inode has no links to it (no directory entries referring to it)
os.c  709: // and has no in-memory reference to it (is not an open file or current directory)
os.c  710: itrunc(struct inode *ip)
00001674  00001002  LEV   0x10 (D 16)
os.c  711: {
os.c  712:   int i, j;
os.c  713:   struct buf *bp;
os.c  714:   uint *a;
os.c  715: 
os.c  716:   for (i = 0; i < NDIR; i++) {
00001678  fffff001  ENT   0xfffffff0 (D -16)
0000167c  00000023  LI    0x0 (D 0)
00001680  00000c40  SL    0xc (D 12)
00001684  00000003  JMP   <fwd>
os.c  717:     if (!ip->dir[i]) goto done;  // XXX done by ip->size?
00001688  0000180e  LL    0x18 (D 24)
0000168c  00001854  ADDI  0x18 (D 24)
00001690  0000009d  PSHA
00001694  0000140e  LL    0x14 (D 20)
00001698  0000045a  MULI  0x4 (D 4)
0000169c  000000a1  POPB
000016a0  00000053  ADD 
000016a4  0000001c  LX  
000016a8  00000086  BNZ   <fwd>
000016ac  00000003  JMP   <fwd>
os.c  718:     bfree(ip->dir[i]);
000016b0  0000180e  LL    0x18 (D 24)
000016b4  00001854  ADDI  0x18 (D 24)
000016b8  0000009d  PSHA
000016bc  0000140e  LL    0x14 (D 20)
000016c0  0000045a  MULI  0x4 (D 4)
000016c4  000000a1  POPB
000016c8  00000053  ADD 
000016cc  0000001c  LX  
000016d0  0000009d  PSHA
000016d4  fff74c05  JSR   0xfffff74c (TO 0xe24)
000016d8  00000801  ENT   0x8 (D 8)
os.c  719:     ip->dir[i] = 0;
000016dc  0000180e  LL    0x18 (D 24)
000016e0  00001854  ADDI  0x18 (D 24)
000016e4  0000009d  PSHA
000016e8  0000140e  LL    0x14 (D 20)
000016ec  0000045a  MULI  0x4 (D 4)
000016f0  000000a1  POPB
000016f4  00000053  ADD 
000016f8  0000003e  LBA 
000016fc  00000023  LI    0x0 (D 0)
00001700  0000004a  SX  
os.c  720:   }
os.c  721:   
os.c  722:   for (i = 0; i < NIDIR; i++) {
00001704  00000c0e  LL    0xc (D 12)
00001708  ffffff57  SUBI  0xffffffff (D -1)
0000170c  00000c40  SL    0xc (D 12)
00001710  00000c0e  LL    0xc (D 12)
00001714  0001e03b  LBI   0x1e0 (D 480)
00001718  0000008c  BLT   <fwd>
0000171c  00000023  LI    0x0 (D 0)
00001720  00000c40  SL    0xc (D 12)
00001724  00000003  JMP   <fwd>
os.c  723:     if (!ip->idir[i]) break;
00001728  0000180e  LL    0x18 (D 24)
0000172c  00079854  ADDI  0x798 (D 1944)
00001730  0000009d  PSHA
00001734  0000140e  LL    0x14 (D 20)
00001738  0000045a  MULI  0x4 (D 4)
0000173c  000000a1  POPB
00001740  00000053  ADD 
00001744  0000001c  LX  
00001748  00000086  BNZ   <fwd>
0000174c  00000003  JMP   <fwd>
os.c  724:     bp = bread(ip->idir[i]);
00001750  0000180e  LL    0x18 (D 24)
00001754  00079854  ADDI  0x798 (D 1944)
00001758  0000009d  PSHA
0000175c  0000140e  LL    0x14 (D 20)
00001760  0000045a  MULI  0x4 (D 4)
00001764  000000a1  POPB
00001768  00000053  ADD 
0000176c  0000001c  LX  
00001770  0000009d  PSHA
00001774  fff37c05  JSR   0xfffff37c (TO 0xaf4)
00001778  00000801  ENT   0x8 (D 8)
0000177c  00000440  SL    0x4 (D 4)
os.c  725:     a = (uint *)bp->data;
00001780  0000040e  LL    0x4 (D 4)
00001784  0000101c  LX    0x10 (D 16)
00001788  00000040  SL    0x0 (D 0)
os.c  726:     for (j = 0; j < 1024; j++) {
0000178c  00000023  LI    0x0 (D 0)
00001790  00000840  SL    0x8 (D 8)
00001794  00000003  JMP   <fwd>
os.c  727:       if (!a[j]) break;
00001798  0000080e  LL    0x8 (D 8)
0000179c  0000045a  MULI  0x4 (D 4)
000017a0  00000055  ADDL  0x0 (D 0)
000017a4  0000001c  LX  
000017a8  00000086  BNZ   <fwd>
000017ac  00000003  JMP   <fwd>
os.c  728:       bfree(a[j]);
000017b0  0000080e  LL    0x8 (D 8)
000017b4  0000045a  MULI  0x4 (D 4)
000017b8  00000055  ADDL  0x0 (D 0)
000017bc  0000001c  LX  
000017c0  0000009d  PSHA
000017c4  fff65c05  JSR   0xfffff65c (TO 0xe24)
000017c8  00000801  ENT   0x8 (D 8)
os.c  729:     }
os.c  730:     brelse(bp);
000017cc  0000080e  LL    0x8 (D 8)
000017d0  ffffff57  SUBI  0xffffffff (D -1)
000017d4  00000840  SL    0x8 (D 8)
000017d8  0000080e  LL    0x8 (D 8)
000017dc  0004003b  LBI   0x400 (D 1024)
000017e0  0000008c  BLT   <fwd>
000017e4  0000040e  LL    0x4 (D 4)
000017e8  0000009d  PSHA
000017ec  fff39005  JSR   0xfffff390 (TO 0xb80)
000017f0  00000801  ENT   0x8 (D 8)
os.c  731:     bfree(ip->idir[i]);
000017f4  0000180e  LL    0x18 (D 24)
000017f8  00079854  ADDI  0x798 (D 1944)
000017fc  0000009d  PSHA
00001800  0000140e  LL    0x14 (D 20)
00001804  0000045a  MULI  0x4 (D 4)
00001808  000000a1  POPB
0000180c  00000053  ADD 
00001810  0000001c  LX  
00001814  0000009d  PSHA
00001818  fff60805  JSR   0xfffff608 (TO 0xe24)
0000181c  00000801  ENT   0x8 (D 8)
os.c  732:     ip->idir[i] = 0;
00001820  0000180e  LL    0x18 (D 24)
00001824  00079854  ADDI  0x798 (D 1944)
00001828  0000009d  PSHA
0000182c  0000140e  LL    0x14 (D 20)
00001830  0000045a  MULI  0x4 (D 4)
00001834  000000a1  POPB
00001838  00000053  ADD 
0000183c  0000003e  LBA 
00001840  00000023  LI    0x0 (D 0)
00001844  0000004a  SX  
os.c  733:   }
os.c  734: 
os.c  735: done:
00001848  00000c0e  LL    0xc (D 12)
0000184c  ffffff57  SUBI  0xffffffff (D -1)
00001850  00000c40  SL    0xc (D 12)
00001854  00000c0e  LL    0xc (D 12)
00001858  0002003b  LBI   0x200 (D 512)
0000185c  0000008c  BLT   <fwd>
os.c  736:   ip->size = 0;
00001860  0000180e  LL    0x18 (D 24)
00001864  00001454  ADDI  0x14 (D 20)
00001868  0000003e  LBA 
0000186c  00000023  LI    0x0 (D 0)
00001870  0000004a  SX  
os.c  737:   iupdate(ip);
00001874  0000180e  LL    0x18 (D 24)
00001878  0000009d  PSHA
0000187c  fff81405  JSR   0xfffff814 (TO 0x1094)
00001880  00000801  ENT   0x8 (D 8)
os.c  738: }
os.c  739: 
os.c  740: // copy stat information from inode
os.c  741: stati(struct inode *ip, struct stat *st)
00001884  00001002  LEV   0x10 (D 16)
os.c  742: {
os.c  743:   st->st_dev   = 0; // XXX
00001888  00000023  LI    0x0 (D 0)
0000188c  00001026  LBL   0x10 (D 16)
00001890  0000004b  SXH 
os.c  744:   st->st_mode  = ip->mode;
00001894  0000100e  LL    0x10 (D 16)
00001898  00000254  ADDI  0x2 (D 2)
0000189c  0000009d  PSHA
000018a0  0000100e  LL    0x10 (D 16)
000018a4  00000c1e  LXH   0xc (D 12)
000018a8  000000a1  POPB
000018ac  0000004b  SXH 
os.c  745:   st->st_ino   = ip->inum;
000018b0  0000100e  LL    0x10 (D 16)
000018b4  00000454  ADDI  0x4 (D 4)
000018b8  0000009d  PSHA
000018bc  0000100e  LL    0x10 (D 16)
000018c0  0000001c  LX  
000018c4  000000a1  POPB
000018c8  0000004a  SX  
os.c  746:   st->st_nlink = ip->nlink;
000018cc  0000100e  LL    0x10 (D 16)
000018d0  00000854  ADDI  0x8 (D 8)
000018d4  0000009d  PSHA
000018d8  0000100e  LL    0x10 (D 16)
000018dc  0000101c  LX    0x10 (D 16)
000018e0  000000a1  POPB
000018e4  0000004a  SX  
os.c  747:   st->st_size  = ip->size;
000018e8  0000100e  LL    0x10 (D 16)
000018ec  00000c54  ADDI  0xc (D 12)
000018f0  0000009d  PSHA
000018f4  0000100e  LL    0x10 (D 16)
000018f8  0000141c  LX    0x14 (D 20)
000018fc  000000a1  POPB
00001900  0000004a  SX  
os.c  748: }
os.c  749: 
os.c  750: // read data from inode
os.c  751: int readi(struct inode *ip, char *dst, uint off, uint n)
00001904  00000002  LEV   0x0 (D 0)
os.c  752: {
os.c  753:   uint tot, m;
os.c  754:   struct buf *bp;
os.c  755: 
os.c  756:   if ((ip->mode & S_IFMT) == S_IFCHR) { // S_IFBLK ??
00001908  fffff001  ENT   0xfffffff0 (D -16)
0000190c  0000180e  LL    0x18 (D 24)
00001910  00000c1e  LXH   0xc (D 12)
00001914  00f00069  ANDI  0xf000 (D 61440)
00001918  0020003b  LBI   0x2000 (D 8192)
0000191c  0000008a  BNE   <fwd>
os.c  757: //    if (ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read) return -1;
os.c  758: //    return devsw[ip->major].read(ip, dst, n);
os.c  759:     if (ip->dir[0] >= NDEV || !devsw[ip->dir[0]].read) return -1; // XXX refactor
00001920  0000180e  LL    0x18 (D 24)
00001924  0000181c  LX    0x18 (D 24)
00001928  00000a3b  LBI   0xa (D 10)
0000192c  00000090  BGEU  <fwd>
00001930  00211808  LEAG  0x2118 (D 8472)
00001934  0000009d  PSHA
00001938  0000200e  LL    0x20 (D 32)
0000193c  0000181c  LX    0x18 (D 24)
00001940  0000085a  MULI  0x8 (D 8)
00001944  000000a1  POPB
00001948  00000053  ADD 
0000194c  0000001c  LX  
00001950  00000086  BNZ   <fwd>
00001954  ffffff23  LI    0xffffffff (D -1)
00001958  00001002  LEV   0x10 (D 16)
os.c  760:     return devsw[ip->dir[0]].read(ip, dst, n);
0000195c  0000300e  LL    0x30 (D 48)
00001960  0000009d  PSHA
00001964  0000280e  LL    0x28 (D 40)
00001968  0000009d  PSHA
0000196c  0000280e  LL    0x28 (D 40)
00001970  0000009d  PSHA
00001974  00211808  LEAG  0x2118 (D 8472)
00001978  0000009d  PSHA
0000197c  0000380e  LL    0x38 (D 56)
00001980  0000181c  LX    0x18 (D 24)
00001984  0000085a  MULI  0x8 (D 8)
00001988  000000a1  POPB
0000198c  00000053  ADD 
00001990  0000001c  LX  
00001994  00000006  JSRA
00001998  00001801  ENT   0x18 (D 24)
0000199c  00001002  LEV   0x10 (D 16)
os.c  761:   }
os.c  762: 
os.c  763:   if (off > ip->size || off + n < off) return -1;
000019a0  0000180e  LL    0x18 (D 24)
000019a4  0000141c  LX    0x14 (D 20)
000019a8  00002826  LBL   0x28 (D 40)
000019ac  0000008d  BLTU  <fwd>
000019b0  0000280e  LL    0x28 (D 40)
000019b4  00003055  ADDL  0x30 (D 48)
000019b8  00002826  LBL   0x28 (D 40)
000019bc  00000090  BGEU  <fwd>
000019c0  ffffff23  LI    0xffffffff (D -1)
000019c4  00001002  LEV   0x10 (D 16)
os.c  764:   if (off + n > ip->size) n = ip->size - off;
000019c8  0000280e  LL    0x28 (D 40)
000019cc  00003055  ADDL  0x30 (D 48)
000019d0  0000009d  PSHA
000019d4  0000200e  LL    0x20 (D 32)
000019d8  0000141c  LX    0x14 (D 20)
000019dc  000000a1  POPB
000019e0  00000090  BGEU  <fwd>
000019e4  0000180e  LL    0x18 (D 24)
000019e8  0000141c  LX    0x14 (D 20)
000019ec  00002858  SUBL  0x28 (D 40)
000019f0  00003040  SL    0x30 (D 48)
os.c  765: 
os.c  766:   for (tot = n; tot; tot -= m, off += m, dst += m) {
000019f4  0000300e  LL    0x30 (D 48)
000019f8  00000c40  SL    0xc (D 12)
000019fc  00000003  JMP   <fwd>
os.c  767:     bp = bread(bmap(ip, off/PAGE));
00001a00  0000280e  LL    0x28 (D 40)
00001a04  00100060  DVUI  0x1000 (D 4096)
00001a08  0000009d  PSHA
00001a0c  0000200e  LL    0x20 (D 32)
00001a10  0000009d  PSHA
00001a14  fffadc05  JSR   0xfffffadc (TO 0x14f4)
00001a18  00001001  ENT   0x10 (D 16)
00001a1c  0000009d  PSHA
00001a20  fff0d005  JSR   0xfffff0d0 (TO 0xaf4)
00001a24  00000801  ENT   0x8 (D 8)
00001a28  00000440  SL    0x4 (D 4)
os.c  768:     if ((m = PAGE - off%PAGE) > tot) m = tot;
00001a2c  0000280e  LL    0x28 (D 40)
00001a30  00100066  MDUI  0x1000 (D 4096)
00001a34  0000003e  LBA 
00001a38  00100023  LI    0x1000 (D 4096)
00001a3c  00000056  SUB 
00001a40  00000840  SL    0x8 (D 8)
00001a44  0000003e  LBA 
00001a48  00000c0e  LL    0xc (D 12)
00001a4c  00000090  BGEU  <fwd>
00001a50  00000c0e  LL    0xc (D 12)
00001a54  00000840  SL    0x8 (D 8)
os.c  769:     memcpy(dst, bp->data + off%PAGE, m);
00001a58  0000080e  LL    0x8 (D 8)
00001a5c  0000009d  PSHA
00001a60  00000c0e  LL    0xc (D 12)
00001a64  0000101c  LX    0x10 (D 16)
00001a68  0000009d  PSHA
00001a6c  0000380e  LL    0x38 (D 56)
00001a70  00100066  MDUI  0x1000 (D 4096)
00001a74  000000a1  POPB
00001a78  00000053  ADD 
00001a7c  0000009d  PSHA
00001a80  0000300e  LL    0x30 (D 48)
00001a84  0000009d  PSHA
00001a88  ffe57405  JSR   0xffffe574 (TO 0x0)
00001a8c  00001801  ENT   0x18 (D 24)
os.c  770:     brelse(bp);
00001a90  0000040e  LL    0x4 (D 4)
00001a94  0000009d  PSHA
00001a98  fff0e405  JSR   0xfffff0e4 (TO 0xb80)
00001a9c  00000801  ENT   0x8 (D 8)
os.c  771:   }
os.c  772:   return n;
00001aa0  00000c0e  LL    0xc (D 12)
00001aa4  00000858  SUBL  0x8 (D 8)
00001aa8  00000c40  SL    0xc (D 12)
00001aac  0000280e  LL    0x28 (D 40)
00001ab0  00000855  ADDL  0x8 (D 8)
00001ab4  00002840  SL    0x28 (D 40)
00001ab8  0000200e  LL    0x20 (D 32)
00001abc  00000855  ADDL  0x8 (D 8)
00001ac0  00002040  SL    0x20 (D 32)
00001ac4  00000c0e  LL    0xc (D 12)
00001ac8  00000086  BNZ   <fwd>
00001acc  0000300e  LL    0x30 (D 48)
00001ad0  00001002  LEV   0x10 (D 16)
os.c  773: }
os.c  774: 
os.c  775: // write data to inode
os.c  776: int writei(struct inode *ip, char *src, uint off, uint n)
00001ad4  00001002  LEV   0x10 (D 16)
os.c  777: {
os.c  778:   uint tot, m;
os.c  779:   struct buf *bp;
os.c  780: 
os.c  781:   if ((ip->mode & S_IFMT) == S_IFCHR) { // XXX S_IFBLK ??
00001ad8  fffff001  ENT   0xfffffff0 (D -16)
00001adc  0000180e  LL    0x18 (D 24)
00001ae0  00000c1e  LXH   0xc (D 12)
00001ae4  00f00069  ANDI  0xf000 (D 61440)
00001ae8  0020003b  LBI   0x2000 (D 8192)
00001aec  0000008a  BNE   <fwd>
os.c  782: //    if (ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write) return -1;
os.c  783: //    return devsw[ip->major].write(ip, src, n);
os.c  784:     if (ip->dir[0] >= NDEV || !devsw[ip->dir[0]].write) return -1; // XXX refactor
00001af0  0000180e  LL    0x18 (D 24)
00001af4  0000181c  LX    0x18 (D 24)
00001af8  00000a3b  LBI   0xa (D 10)
00001afc  00000090  BGEU  <fwd>
00001b00  00211808  LEAG  0x2118 (D 8472)
00001b04  0000009d  PSHA
00001b08  0000200e  LL    0x20 (D 32)
00001b0c  0000181c  LX    0x18 (D 24)
00001b10  0000085a  MULI  0x8 (D 8)
00001b14  000000a1  POPB
00001b18  00000053  ADD 
00001b1c  0000041c  LX    0x4 (D 4)
00001b20  00000086  BNZ   <fwd>
00001b24  ffffff23  LI    0xffffffff (D -1)
00001b28  00001002  LEV   0x10 (D 16)
os.c  785:     return devsw[ip->dir[0]].write(ip, src, n);
00001b2c  0000300e  LL    0x30 (D 48)
00001b30  0000009d  PSHA
00001b34  0000280e  LL    0x28 (D 40)
00001b38  0000009d  PSHA
00001b3c  0000280e  LL    0x28 (D 40)
00001b40  0000009d  PSHA
00001b44  00211808  LEAG  0x2118 (D 8472)
00001b48  0000009d  PSHA
00001b4c  0000380e  LL    0x38 (D 56)
00001b50  0000181c  LX    0x18 (D 24)
00001b54  0000085a  MULI  0x8 (D 8)
00001b58  000000a1  POPB
00001b5c  00000053  ADD 
00001b60  0000041c  LX    0x4 (D 4)
00001b64  00000006  JSRA
00001b68  00001801  ENT   0x18 (D 24)
00001b6c  00001002  LEV   0x10 (D 16)
os.c  786:   }
os.c  787:   if (off > ip->size || off + n < off) return -1;
00001b70  0000180e  LL    0x18 (D 24)
00001b74  0000141c  LX    0x14 (D 20)
00001b78  00002826  LBL   0x28 (D 40)
00001b7c  0000008d  BLTU  <fwd>
00001b80  0000280e  LL    0x28 (D 40)
00001b84  00003055  ADDL  0x30 (D 48)
00001b88  00002826  LBL   0x28 (D 40)
00001b8c  00000090  BGEU  <fwd>
00001b90  ffffff23  LI    0xffffffff (D -1)
00001b94  00001002  LEV   0x10 (D 16)
os.c  788:   if (off + n > (NDIR + NIDIR*1024)*PAGE) return -1;
00001b98  0000280e  LL    0x28 (D 40)
00001b9c  00003055  ADDL  0x30 (D 48)
00001ba0  0000003e  LBA 
00001ba4  ffff8023  LI    0xffffff80 (D -128)
00001ba8  1e000024  LHI   0x1e0000 (D 1966080)
00001bac  00000090  BGEU  <fwd>
00001bb0  ffffff23  LI    0xffffffff (D -1)
00001bb4  00001002  LEV   0x10 (D 16)
os.c  789: 
os.c  790:   for (tot = n; tot; tot -= m, off += m, src += m) {
00001bb8  0000300e  LL    0x30 (D 48)
00001bbc  00000c40  SL    0xc (D 12)
00001bc0  00000003  JMP   <fwd>
os.c  791:     bp = bread(bmap(ip, off/PAGE));
00001bc4  0000280e  LL    0x28 (D 40)
00001bc8  00100060  DVUI  0x1000 (D 4096)
00001bcc  0000009d  PSHA
00001bd0  0000200e  LL    0x20 (D 32)
00001bd4  0000009d  PSHA
00001bd8  fff91805  JSR   0xfffff918 (TO 0x14f4)
00001bdc  00001001  ENT   0x10 (D 16)
00001be0  0000009d  PSHA
00001be4  ffef0c05  JSR   0xffffef0c (TO 0xaf4)
00001be8  00000801  ENT   0x8 (D 8)
00001bec  00000440  SL    0x4 (D 4)
os.c  792:     if ((m = PAGE - off%PAGE) > tot) m = tot;
00001bf0  0000280e  LL    0x28 (D 40)
00001bf4  00100066  MDUI  0x1000 (D 4096)
00001bf8  0000003e  LBA 
00001bfc  00100023  LI    0x1000 (D 4096)
00001c00  00000056  SUB 
00001c04  00000840  SL    0x8 (D 8)
00001c08  0000003e  LBA 
00001c0c  00000c0e  LL    0xc (D 12)
00001c10  00000090  BGEU  <fwd>
00001c14  00000c0e  LL    0xc (D 12)
00001c18  00000840  SL    0x8 (D 8)
os.c  793:     memcpy(bp->data + off%PAGE, src, m);
00001c1c  0000080e  LL    0x8 (D 8)
00001c20  0000009d  PSHA
00001c24  0000280e  LL    0x28 (D 40)
00001c28  0000009d  PSHA
00001c2c  0000140e  LL    0x14 (D 20)
00001c30  0000101c  LX    0x10 (D 16)
00001c34  0000009d  PSHA
00001c38  0000400e  LL    0x40 (D 64)
00001c3c  00100066  MDUI  0x1000 (D 4096)
00001c40  000000a1  POPB
00001c44  00000053  ADD 
00001c48  0000009d  PSHA
00001c4c  ffe3b005  JSR   0xffffe3b0 (TO 0x0)
00001c50  00001801  ENT   0x18 (D 24)
os.c  794:     bwrite(bp);
00001c54  0000040e  LL    0x4 (D 4)
00001c58  0000009d  PSHA
00001c5c  ffeed805  JSR   0xffffeed8 (TO 0xb38)
00001c60  00000801  ENT   0x8 (D 8)
os.c  795:     brelse(bp);
00001c64  0000040e  LL    0x4 (D 4)
00001c68  0000009d  PSHA
00001c6c  ffef1005  JSR   0xffffef10 (TO 0xb80)
00001c70  00000801  ENT   0x8 (D 8)
os.c  796:   }
os.c  797:   if (n > 0 && off > ip->size) {
00001c74  00000c0e  LL    0xc (D 12)
00001c78  00000858  SUBL  0x8 (D 8)
00001c7c  00000c40  SL    0xc (D 12)
00001c80  0000280e  LL    0x28 (D 40)
00001c84  00000855  ADDL  0x8 (D 8)
00001c88  00002840  SL    0x28 (D 40)
00001c8c  0000200e  LL    0x20 (D 32)
00001c90  00000855  ADDL  0x8 (D 8)
00001c94  00002040  SL    0x20 (D 32)
00001c98  00000c0e  LL    0xc (D 12)
00001c9c  00000086  BNZ   <fwd>
00001ca0  00000023  LI    0x0 (D 0)
00001ca4  00003026  LBL   0x30 (D 48)
00001ca8  00000090  BGEU  <fwd>
00001cac  0000180e  LL    0x18 (D 24)
00001cb0  0000141c  LX    0x14 (D 20)
00001cb4  00002826  LBL   0x28 (D 40)
00001cb8  001ca890  BGEU  <fwd>
os.c  798:     ip->size = off;
00001cbc  0000180e  LL    0x18 (D 24)
00001cc0  00001454  ADDI  0x14 (D 20)
00001cc4  0000003e  LBA 
00001cc8  0000280e  LL    0x28 (D 40)
00001ccc  0000004a  SX  
os.c  799:     iupdate(ip);
00001cd0  0000180e  LL    0x18 (D 24)
00001cd4  0000009d  PSHA
00001cd8  fff3b805  JSR   0xfffff3b8 (TO 0x1094)
00001cdc  00000801  ENT   0x8 (D 8)
os.c  800:   }
os.c  801:   return n;
00001ce0  0000300e  LL    0x30 (D 48)
00001ce4  00001002  LEV   0x10 (D 16)
os.c  802: }
os.c  803: 
os.c  804: // directories:
os.c  805: int namecmp(char *p, char *q) 
00001ce8  00001002  LEV   0x10 (D 16)
os.c  806: {
os.c  807:   uint n = DIRSIZ;
os.c  808:   while (n) { if (!*p || *p != *q) return *p - *q; n--; p++; q++; } // XXX
00001cec  fffff801  ENT   0xfffffff8 (D -8)
00001cf0  0000fc23  LI    0xfc (D 252)
00001cf4  00000440  SL    0x4 (D 4)
00001cf8  00000003  JMP   <fwd>
00001cfc  0000100e  LL    0x10 (D 16)
00001d00  0000001f  LXC 
00001d04  00000084  BZ    <fwd>
00001d08  0000180e  LL    0x18 (D 24)
00001d0c  0000001f  LXC 
00001d10  0000009d  PSHA
00001d14  0000180e  LL    0x18 (D 24)
00001d18  0000001f  LXC 
00001d1c  000000a1  POPB
00001d20  00000088  BE    <fwd>
00001d24  0000180e  LL    0x18 (D 24)
00001d28  0000001f  LXC 
00001d2c  0000009d  PSHA
00001d30  0000180e  LL    0x18 (D 24)
00001d34  0000001f  LXC 
00001d38  000000a1  POPB
00001d3c  00000056  SUB 
00001d40  00000802  LEV   0x8 (D 8)
00001d44  0000040e  LL    0x4 (D 4)
00001d48  00000157  SUBI  0x1 (D 1)
00001d4c  00000440  SL    0x4 (D 4)
00001d50  0000100e  LL    0x10 (D 16)
00001d54  ffffff57  SUBI  0xffffffff (D -1)
00001d58  00001040  SL    0x10 (D 16)
00001d5c  0000180e  LL    0x18 (D 24)
00001d60  ffffff57  SUBI  0xffffffff (D -1)
00001d64  00001840  SL    0x18 (D 24)
os.c  809:   return 0;
00001d68  0000040e  LL    0x4 (D 4)
00001d6c  00000086  BNZ   <fwd>
00001d70  00000023  LI    0x0 (D 0)
00001d74  00000802  LEV   0x8 (D 8)
os.c  810: }
os.c  811: 
os.c  812: // look for a directory entry in a directory. If found, set *poff to byte offset of entry.
os.c  813: struct inode *dirlookup(struct inode *dp, char *name, uint *poff)
00001d78  00000802  LEV   0x8 (D 8)
os.c  814: {
os.c  815:   uint off; struct direct de;
os.c  816: 
os.c  817:   if ((dp->mode & S_IFMT) != S_IFDIR) panic("dirlookup not DIR");
00001d7c  fffef801  ENT   0xfffffef8 (D -264)
00001d80  0001100e  LL    0x110 (D 272)
00001d84  00000c1e  LXH   0xc (D 12)
00001d88  00f00069  ANDI  0xf000 (D 61440)
00001d8c  0040003b  LBI   0x4000 (D 16384)
00001d90  00000088  BE    <fwd>
00001d94  00014608  LEAG  0x146 (D 326)
00001d98  0000009d  PSHA
00001d9c  ffe79405  JSR   0xffffe794 (TO 0x534)
00001da0  00000801  ENT   0x8 (D 8)
os.c  818:   for (off = 0; off < dp->size; off += sizeof(de)) {
00001da4  00000023  LI    0x0 (D 0)
00001da8  00010440  SL    0x104 (D 260)
00001dac  00000003  JMP   <fwd>
os.c  819:     if (readi(dp, (char *)&de, off, sizeof(de)) != sizeof(de)) panic("dirlink read");
00001db0  0001009e  PSHI  0x100 (D 256)
00001db4  00010c0e  LL    0x10c (D 268)
00001db8  0000009d  PSHA
00001dbc  00001407  LEA   0x14 (D 20)
00001dc0  0000009d  PSHA
00001dc4  0001280e  LL    0x128 (D 296)
00001dc8  0000009d  PSHA
00001dcc  fffb3805  JSR   0xfffffb38 (TO 0x1908)
00001dd0  00002001  ENT   0x20 (D 32)
00001dd4  0001003b  LBI   0x100 (D 256)
00001dd8  00000088  BE    <fwd>
00001ddc  00015808  LEAG  0x158 (D 344)
00001de0  0000009d  PSHA
00001de4  ffe74c05  JSR   0xffffe74c (TO 0x534)
00001de8  00000801  ENT   0x8 (D 8)
os.c  820:     if (de.d_ino && !namecmp(name, de.d_name)) { // entry matches path element
00001dec  0000040e  LL    0x4 (D 4)
00001df0  00000084  BZ    <fwd>
00001df4  00000807  LEA   0x8 (D 8)
00001df8  0000009d  PSHA
00001dfc  0001200e  LL    0x120 (D 288)
00001e00  0000009d  PSHA
00001e04  fffee405  JSR   0xfffffee4 (TO 0x1cec)
00001e08  00001001  ENT   0x10 (D 16)
00001e0c  001df086  BNZ   <fwd>
os.c  821:       if (poff) *poff = off;
00001e10  0001200e  LL    0x120 (D 288)
00001e14  00000084  BZ    <fwd>
00001e18  0001040e  LL    0x104 (D 260)
00001e1c  00012026  LBL   0x120 (D 288)
00001e20  0000004a  SX  
os.c  822:       return iget(de.d_ino);
00001e24  0000040e  LL    0x4 (D 4)
00001e28  0000009d  PSHA
00001e2c  fff0c005  JSR   0xfffff0c0 (TO 0xef0)
00001e30  00000801  ENT   0x8 (D 8)
00001e34  00010802  LEV   0x108 (D 264)
os.c  823:     }
os.c  824:   }
os.c  825:   return 0;
00001e38  0001040e  LL    0x104 (D 260)
00001e3c  00010054  ADDI  0x100 (D 256)
00001e40  00010440  SL    0x104 (D 260)
00001e44  0001100e  LL    0x110 (D 272)
00001e48  0000141c  LX    0x14 (D 20)
00001e4c  0000003e  LBA 
00001e50  0001040e  LL    0x104 (D 260)
00001e54  0000008d  BLTU  <fwd>
00001e58  00000023  LI    0x0 (D 0)
00001e5c  00010802  LEV   0x108 (D 264)
os.c  826: }
os.c  827: 
os.c  828: // write a new directory entry (name, inum) into the directory dp
os.c  829: int dirlink(struct inode *dp, char *name, uint inum)
00001e60  00010802  LEV   0x108 (D 264)
os.c  830: {
os.c  831:   int off;
os.c  832:   struct direct de;
os.c  833:   struct inode *ip;
os.c  834: 
os.c  835:   // check that name is not present
os.c  836:   if (ip = dirlookup(dp, name, 0)) {
00001e64  fffef801  ENT   0xfffffef8 (D -264)
00001e68  0000009e  PSHI  0x0 (D 0)
00001e6c  0001200e  LL    0x120 (D 288)
00001e70  0000009d  PSHA
00001e74  0001200e  LL    0x120 (D 288)
00001e78  0000009d  PSHA
00001e7c  fffefc05  JSR   0xfffffefc (TO 0x1d7c)
00001e80  00001801  ENT   0x18 (D 24)
00001e84  00000040  SL    0x0 (D 0)
00001e88  00000084  BZ    <fwd>
os.c  837:     iput(ip);
00001e8c  0000000e  LL    0x0 (D 0)
00001e90  0000009d  PSHA
00001e94  fff52805  JSR   0xfffff528 (TO 0x13c0)
00001e98  00000801  ENT   0x8 (D 8)
os.c  838:     return -1;
00001e9c  ffffff23  LI    0xffffffff (D -1)
00001ea0  00010802  LEV   0x108 (D 264)
os.c  839:   }
os.c  840:   // look for an empty direct
os.c  841:   for (off = 0; off < dp->size; off += sizeof(de)) {
00001ea4  00000023  LI    0x0 (D 0)
00001ea8  00010440  SL    0x104 (D 260)
00001eac  00000003  JMP   <fwd>
os.c  842:     if (readi(dp, (char *)&de, off, sizeof(de)) != sizeof(de)) panic("dirlink read");
00001eb0  0001009e  PSHI  0x100 (D 256)
00001eb4  00010c0e  LL    0x10c (D 268)
00001eb8  0000009d  PSHA
00001ebc  00001407  LEA   0x14 (D 20)
00001ec0  0000009d  PSHA
00001ec4  0001280e  LL    0x128 (D 296)
00001ec8  0000009d  PSHA
00001ecc  fffa3805  JSR   0xfffffa38 (TO 0x1908)
00001ed0  00002001  ENT   0x20 (D 32)
00001ed4  0001003b  LBI   0x100 (D 256)
00001ed8  00000088  BE    <fwd>
00001edc  00016508  LEAG  0x165 (D 357)
00001ee0  0000009d  PSHA
00001ee4  ffe64c05  JSR   0xffffe64c (TO 0x534)
00001ee8  00000801  ENT   0x8 (D 8)
os.c  843:     if (!de.d_ino) break;
00001eec  0000040e  LL    0x4 (D 4)
00001ef0  00000086  BNZ   <fwd>
00001ef4  00000003  JMP   <fwd>
os.c  844:   }
os.c  845:   xstrncpy(de.d_name, name, DIRSIZ);
00001ef8  0001040e  LL    0x104 (D 260)
00001efc  00010054  ADDI  0x100 (D 256)
00001f00  00010440  SL    0x104 (D 260)
00001f04  0001100e  LL    0x110 (D 272)
00001f08  0000141c  LX    0x14 (D 20)
00001f0c  0000003e  LBA 
00001f10  0001040e  LL    0x104 (D 260)
00001f14  0000008d  BLTU  <fwd>
00001f18  0000fc9e  PSHI  0xfc (D 252)
00001f1c  0001200e  LL    0x120 (D 288)
00001f20  0000009d  PSHA
00001f24  00001807  LEA   0x18 (D 24)
00001f28  0000009d  PSHA
00001f2c  ffe1b005  JSR   0xffffe1b0 (TO 0xe0)
00001f30  00001801  ENT   0x18 (D 24)
os.c  846:   de.d_ino = inum;
00001f34  0001200e  LL    0x120 (D 288)
00001f38  00000440  SL    0x4 (D 4)
os.c  847:   if (writei(dp, (char *)&de, off, sizeof(de)) != sizeof(de)) panic("dirlink");
00001f3c  0001009e  PSHI  0x100 (D 256)
00001f40  00010c0e  LL    0x10c (D 268)
00001f44  0000009d  PSHA
00001f48  00001407  LEA   0x14 (D 20)
00001f4c  0000009d  PSHA
00001f50  0001280e  LL    0x128 (D 296)
00001f54  0000009d  PSHA
00001f58  fffb7c05  JSR   0xfffffb7c (TO 0x1ad8)
00001f5c  00002001  ENT   0x20 (D 32)
00001f60  0001003b  LBI   0x100 (D 256)
00001f64  00000088  BE    <fwd>
00001f68  00017208  LEAG  0x172 (D 370)
00001f6c  0000009d  PSHA
00001f70  ffe5c005  JSR   0xffffe5c0 (TO 0x534)
00001f74  00000801  ENT   0x8 (D 8)
os.c  848:   
os.c  849:   return 0;
00001f78  00000023  LI    0x0 (D 0)
00001f7c  00010802  LEV   0x108 (D 264)
os.c  850: }
os.c  851: 
os.c  852: // is the directory dp empty except for "." and ".." ?
os.c  853: int isdirempty(struct inode *dp)
00001f80  00010802  LEV   0x108 (D 264)
os.c  854: {
os.c  855:   int off;
os.c  856:   struct direct de;
os.c  857: 
os.c  858:   for (off=2*sizeof(de); off<dp->size; off+=sizeof(de)) {
00001f84  fffef801  ENT   0xfffffef8 (D -264)
00001f88  00020023  LI    0x200 (D 512)
00001f8c  00010440  SL    0x104 (D 260)
00001f90  00000003  JMP   <fwd>
os.c  859:     if (readi(dp, (char *)&de, off, sizeof(de)) != sizeof(de)) panic("isdirempty: readi");
00001f94  0001009e  PSHI  0x100 (D 256)
00001f98  00010c0e  LL    0x10c (D 268)
00001f9c  0000009d  PSHA
00001fa0  00001407  LEA   0x14 (D 20)
00001fa4  0000009d  PSHA
00001fa8  0001280e  LL    0x128 (D 296)
00001fac  0000009d  PSHA
00001fb0  fff95405  JSR   0xfffff954 (TO 0x1908)
00001fb4  00002001  ENT   0x20 (D 32)
00001fb8  0001003b  LBI   0x100 (D 256)
00001fbc  00000088  BE    <fwd>
00001fc0  00017a08  LEAG  0x17a (D 378)
00001fc4  0000009d  PSHA
00001fc8  ffe56805  JSR   0xffffe568 (TO 0x534)
00001fcc  00000801  ENT   0x8 (D 8)
os.c  860:     if (de.d_ino) return 0;
00001fd0  0000040e  LL    0x4 (D 4)
00001fd4  00000084  BZ    <fwd>
00001fd8  00000023  LI    0x0 (D 0)
00001fdc  00010802  LEV   0x108 (D 264)
os.c  861:   }
os.c  862:   return 1;
00001fe0  0001040e  LL    0x104 (D 260)
00001fe4  00010054  ADDI  0x100 (D 256)
00001fe8  00010440  SL    0x104 (D 260)
00001fec  0001100e  LL    0x110 (D 272)
00001ff0  0000141c  LX    0x14 (D 20)
00001ff4  0000003e  LBA 
00001ff8  0001040e  LL    0x104 (D 260)
00001ffc  0000008d  BLTU  <fwd>
00002000  00000123  LI    0x1 (D 1)
00002004  00010802  LEV   0x108 (D 264)
os.c  863: }
os.c  864: 
os.c  865: // paths:
os.c  866: // Copy the next path element from path into name.  Return a pointer to the element following the copied one.
os.c  867: // The returned path has no leading slashes, so the caller can check *path=='\0' to see if the name is the last one.
os.c  868: // If no name to remove, return 0.
os.c  869: //
os.c  870: // Examples:
os.c  871: //   skipelem("a/bb/c", name) = "bb/c", setting name = "a"
os.c  872: //   skipelem("///a//bb", name) = "bb", setting name = "a"
os.c  873: //   skipelem("a", name) = "", setting name = "a"
os.c  874: //   skipelem("", name) = skipelem("////", name) = 0
os.c  875: //
os.c  876: char *skipelem(char *path, char *name)
00002008  00010802  LEV   0x108 (D 264)
os.c  877: {
os.c  878:   char *s;
os.c  879:   int len;
os.c  880: 
os.c  881:   while (*path == '/') path++;
0000200c  fffff801  ENT   0xfffffff8 (D -8)
00002010  00000003  JMP   <fwd>
00002014  0000100e  LL    0x10 (D 16)
00002018  ffffff57  SUBI  0xffffffff (D -1)
0000201c  00001040  SL    0x10 (D 16)
os.c  882:   if (!*path) return 0;
00002020  0000100e  LL    0x10 (D 16)
00002024  0000001f  LXC 
00002028  00002f3b  LBI   0x2f (D 47)
0000202c  00000088  BE    <fwd>
00002030  0000100e  LL    0x10 (D 16)
00002034  0000001f  LXC 
00002038  00000086  BNZ   <fwd>
0000203c  00000023  LI    0x0 (D 0)
00002040  00000802  LEV   0x8 (D 8)
os.c  883:   s = path;
00002044  0000100e  LL    0x10 (D 16)
00002048  00000440  SL    0x4 (D 4)
os.c  884:   while (*path != '/' && *path) path++;
0000204c  00000003  JMP   <fwd>
00002050  0000100e  LL    0x10 (D 16)
00002054  ffffff57  SUBI  0xffffffff (D -1)
00002058  00001040  SL    0x10 (D 16)
os.c  885:   len = path - s;
0000205c  0000100e  LL    0x10 (D 16)
00002060  0000001f  LXC 
00002064  00002f3b  LBI   0x2f (D 47)
00002068  00000088  BE    <fwd>
0000206c  0000100e  LL    0x10 (D 16)
00002070  0000001f  LXC 
00002074  00000086  BNZ   <fwd>
00002078  0000100e  LL    0x10 (D 16)
0000207c  00000458  SUBL  0x4 (D 4)
00002080  0000015d  DIVI  0x1 (D 1)
00002084  00000040  SL    0x0 (D 0)
os.c  886:   if (len >= DIRSIZ) memcpy(name, s, DIRSIZ);
00002088  0000000e  LL    0x0 (D 0)
0000208c  0000fc3b  LBI   0xfc (D 252)
00002090  0000008c  BLT   <fwd>
00002094  0000fc9e  PSHI  0xfc (D 252)
00002098  00000c0e  LL    0xc (D 12)
0000209c  0000009d  PSHA
000020a0  0000280e  LL    0x28 (D 40)
000020a4  0000009d  PSHA
000020a8  ffdf5405  JSR   0xffffdf54 (TO 0x0)
000020ac  00001801  ENT   0x18 (D 24)
os.c  887:   else {
000020b0  00000003  JMP   <fwd>
os.c  888:     memcpy(name, s, len);
000020b4  0000000e  LL    0x0 (D 0)
000020b8  0000009d  PSHA
000020bc  00000c0e  LL    0xc (D 12)
000020c0  0000009d  PSHA
000020c4  0000280e  LL    0x28 (D 40)
000020c8  0000009d  PSHA
000020cc  ffdf3005  JSR   0xffffdf30 (TO 0x0)
000020d0  00001801  ENT   0x18 (D 24)
os.c  889:     name[len] = 0;
000020d4  0000180e  LL    0x18 (D 24)
000020d8  00000055  ADDL  0x0 (D 0)
000020dc  0000003e  LBA 
000020e0  00000023  LI    0x0 (D 0)
000020e4  0000004c  SXB 
os.c  890:   }
os.c  891:   while (*path == '/') path++;
000020e8  00000003  JMP   <fwd>
000020ec  0000100e  LL    0x10 (D 16)
000020f0  ffffff57  SUBI  0xffffffff (D -1)
000020f4  00001040  SL    0x10 (D 16)
os.c  892:   return path;
000020f8  0000100e  LL    0x10 (D 16)
000020fc  0000001f  LXC 
00002100  00002f3b  LBI   0x2f (D 47)
00002104  00000088  BE    <fwd>
00002108  0000100e  LL    0x10 (D 16)
0000210c  00000802  LEV   0x8 (D 8)
os.c  893: }
os.c  894: 
os.c  895: // Look up and return the inode for a path name
os.c  896: struct inode *namei(char *path)
00002110  00000802  LEV   0x8 (D 8)
os.c  897: {
os.c  898:   char name[DIRSIZ];
os.c  899:   struct inode *ip, *next;
os.c  900: 
os.c  901:   if (*path == '/') ip = iget(ROOTINO); else idup(ip = u->cwd);
00002114  fffef801  ENT   0xfffffef8 (D -264)
00002118  0001100e  LL    0x110 (D 272)
0000211c  0000001f  LXC 
00002120  00002f3b  LBI   0x2f (D 47)
00002124  0000008a  BNE   <fwd>
00002128  0000109e  PSHI  0x10 (D 16)
0000212c  ffedc005  JSR   0xffffedc0 (TO 0xef0)
00002130  00000801  ENT   0x8 (D 8)
00002134  00000840  SL    0x8 (D 8)
00002138  00000003  JMP   <fwd>
0000213c  00210015  LG    0x2100 (D 8448)
00002140  0000701c  LX    0x70 (D 112)
00002144  00000840  SL    0x8 (D 8)
00002148  0000009d  PSHA
0000214c  fff02005  JSR   0xfffff020 (TO 0x1170)
00002150  00000801  ENT   0x8 (D 8)
os.c  902:   
os.c  903:   while (path = skipelem(path, name)) {
00002154  00000003  JMP   <fwd>
os.c  904:     ilock(ip);
00002158  0000080e  LL    0x8 (D 8)
0000215c  0000009d  PSHA
00002160  fff04405  JSR   0xfffff044 (TO 0x11a8)
00002164  00000801  ENT   0x8 (D 8)
os.c  905:     if ((ip->mode & S_IFMT) != S_IFDIR || !(next = dirlookup(ip, name, 0))) {
00002168  0000080e  LL    0x8 (D 8)
0000216c  00000c1e  LXH   0xc (D 12)
00002170  00f00069  ANDI  0xf000 (D 61440)
00002174  0040003b  LBI   0x4000 (D 16384)
00002178  0000008a  BNE   <fwd>
0000217c  0000009e  PSHI  0x0 (D 0)
00002180  00001407  LEA   0x14 (D 20)
00002184  0000009d  PSHA
00002188  0000180e  LL    0x18 (D 24)
0000218c  0000009d  PSHA
00002190  fffbe805  JSR   0xfffffbe8 (TO 0x1d7c)
00002194  00001801  ENT   0x18 (D 24)
00002198  00000440  SL    0x4 (D 4)
0000219c  00000086  BNZ   <fwd>
os.c  906:       iunlockput(ip);
000021a0  0000080e  LL    0x8 (D 8)
000021a4  0000009d  PSHA
000021a8  fff32405  JSR   0xfffff324 (TO 0x14d0)
000021ac  00000801  ENT   0x8 (D 8)
os.c  907:       return 0;
000021b0  00000023  LI    0x0 (D 0)
000021b4  00010802  LEV   0x108 (D 264)
os.c  908:     }
os.c  909:     iunlockput(ip);
000021b8  0000080e  LL    0x8 (D 8)
000021bc  0000009d  PSHA
000021c0  fff30c05  JSR   0xfffff30c (TO 0x14d0)
000021c4  00000801  ENT   0x8 (D 8)
os.c  910:     ip = next;
000021c8  0000040e  LL    0x4 (D 4)
000021cc  00000840  SL    0x8 (D 8)
os.c  911:   }
os.c  912:   return ip;
000021d0  00000c07  LEA   0xc (D 12)
000021d4  0000009d  PSHA
000021d8  0001180e  LL    0x118 (D 280)
000021dc  0000009d  PSHA
000021e0  fffe2805  JSR   0xfffffe28 (TO 0x200c)
000021e4  00001001  ENT   0x10 (D 16)
000021e8  00011040  SL    0x110 (D 272)
000021ec  00000086  BNZ   <fwd>
000021f0  0000080e  LL    0x8 (D 8)
000021f4  00010802  LEV   0x108 (D 264)
os.c  913: }
os.c  914: // return the inode for the parent and copy the final path element into name, which must have room for DIRSIZ bytes.
os.c  915: struct inode *nameiparent(char *path, char *name)
000021f8  00010802  LEV   0x108 (D 264)
os.c  916: {
os.c  917:   struct inode *ip, *next;
os.c  918: 
os.c  919:   if (*path == '/') ip = iget(ROOTINO); else idup(ip = u->cwd);
000021fc  fffff801  ENT   0xfffffff8 (D -8)
00002200  0000100e  LL    0x10 (D 16)
00002204  0000001f  LXC 
00002208  00002f3b  LBI   0x2f (D 47)
0000220c  0000008a  BNE   <fwd>
00002210  0000109e  PSHI  0x10 (D 16)
00002214  ffecd805  JSR   0xffffecd8 (TO 0xef0)
00002218  00000801  ENT   0x8 (D 8)
0000221c  00000440  SL    0x4 (D 4)
00002220  00000003  JMP   <fwd>
00002224  00210015  LG    0x2100 (D 8448)
00002228  0000701c  LX    0x70 (D 112)
0000222c  00000440  SL    0x4 (D 4)
00002230  0000009d  PSHA
00002234  ffef3805  JSR   0xffffef38 (TO 0x1170)
00002238  00000801  ENT   0x8 (D 8)
os.c  920:   
os.c  921:   while (path = skipelem(path, name)) {
0000223c  00000003  JMP   <fwd>
os.c  922:     ilock(ip);
00002240  0000040e  LL    0x4 (D 4)
00002244  0000009d  PSHA
00002248  ffef5c05  JSR   0xffffef5c (TO 0x11a8)
0000224c  00000801  ENT   0x8 (D 8)
os.c  923:     if ((ip->mode & S_IFMT) != S_IFDIR) {
00002250  0000040e  LL    0x4 (D 4)
00002254  00000c1e  LXH   0xc (D 12)
00002258  00f00069  ANDI  0xf000 (D 61440)
0000225c  0040003b  LBI   0x4000 (D 16384)
00002260  00000088  BE    <fwd>
os.c  924:       iunlockput(ip);
00002264  0000040e  LL    0x4 (D 4)
00002268  0000009d  PSHA
0000226c  fff26005  JSR   0xfffff260 (TO 0x14d0)
00002270  00000801  ENT   0x8 (D 8)
os.c  925:       return 0;
00002274  00000023  LI    0x0 (D 0)
00002278  00000802  LEV   0x8 (D 8)
os.c  926:     }
os.c  927:     if (!*path) { // stop one level early
0000227c  0000100e  LL    0x10 (D 16)
00002280  0000001f  LXC 
00002284  00000086  BNZ   <fwd>
os.c  928:       iunlock(ip);
00002288  0000040e  LL    0x4 (D 4)
0000228c  0000009d  PSHA
00002290  fff0ac05  JSR   0xfffff0ac (TO 0x1340)
00002294  00000801  ENT   0x8 (D 8)
os.c  929:       return ip;
00002298  0000040e  LL    0x4 (D 4)
0000229c  00000802  LEV   0x8 (D 8)
os.c  930:     }
os.c  931:     if (!(next = dirlookup(ip, name, 0))) {
000022a0  0000009e  PSHI  0x0 (D 0)
000022a4  0000200e  LL    0x20 (D 32)
000022a8  0000009d  PSHA
000022ac  0000140e  LL    0x14 (D 20)
000022b0  0000009d  PSHA
000022b4  fffac405  JSR   0xfffffac4 (TO 0x1d7c)
000022b8  00001801  ENT   0x18 (D 24)
000022bc  00000040  SL    0x0 (D 0)
000022c0  00000086  BNZ   <fwd>
os.c  932:       iunlockput(ip);
000022c4  0000040e  LL    0x4 (D 4)
000022c8  0000009d  PSHA
000022cc  fff20005  JSR   0xfffff200 (TO 0x14d0)
000022d0  00000801  ENT   0x8 (D 8)
os.c  933:       return 0;
000022d4  00000023  LI    0x0 (D 0)
000022d8  00000802  LEV   0x8 (D 8)
os.c  934:     }
os.c  935:     iunlockput(ip);
000022dc  0000040e  LL    0x4 (D 4)
000022e0  0000009d  PSHA
000022e4  fff1e805  JSR   0xfffff1e8 (TO 0x14d0)
000022e8  00000801  ENT   0x8 (D 8)
os.c  936:     ip = next;
000022ec  0000000e  LL    0x0 (D 0)
000022f0  00000440  SL    0x4 (D 4)
os.c  937:   }
os.c  938:   iput(ip);
000022f4  0000180e  LL    0x18 (D 24)
000022f8  0000009d  PSHA
000022fc  0000180e  LL    0x18 (D 24)
00002300  0000009d  PSHA
00002304  fffd0405  JSR   0xfffffd04 (TO 0x200c)
00002308  00001001  ENT   0x10 (D 16)
0000230c  00001040  SL    0x10 (D 16)
00002310  00000086  BNZ   <fwd>
00002314  0000040e  LL    0x4 (D 4)
00002318  0000009d  PSHA
0000231c  fff0a005  JSR   0xfffff0a0 (TO 0x13c0)
00002320  00000801  ENT   0x8 (D 8)
os.c  939:   return 0;
00002324  00000023  LI    0x0 (D 0)
00002328  00000802  LEV   0x8 (D 8)
os.c  940: }
os.c  941: 
os.c  942: // pipes:
os.c  943: void pipeclose(struct pipe *p, int writable)
0000232c  00000802  LEV   0x8 (D 8)
os.c  944: {
os.c  945:   int e = splhi();
os.c  946:   if (writable) {
00002330  fffff801  ENT   0xfffffff8 (D -8)
00002334  ffdd6805  JSR   0xffffdd68 (TO 0xa0)
00002338  00000440  SL    0x4 (D 4)
0000233c  0000180e  LL    0x18 (D 24)
00002340  00000084  BZ    <fwd>
os.c  947:     p->writeopen = 0;
00002344  0000100e  LL    0x10 (D 16)
00002348  000fac54  ADDI  0xfac (D 4012)
0000234c  0000003e  LBA 
00002350  00000023  LI    0x0 (D 0)
00002354  0000004a  SX  
os.c  948:     wakeup(&p->nread);
00002358  0000100e  LL    0x10 (D 16)
0000235c  000fa054  ADDI  0xfa0 (D 4000)
00002360  0000009d  PSHA
00002364  00149c05  JSR   <fwd>
00002368  00000801  ENT   0x8 (D 8)
os.c  949:   } else {
0000236c  00000003  JMP   <fwd>
os.c  950:     p->readopen = 0;
00002370  0000100e  LL    0x10 (D 16)
00002374  000fa854  ADDI  0xfa8 (D 4008)
00002378  0000003e  LBA 
0000237c  00000023  LI    0x0 (D 0)
00002380  0000004a  SX  
os.c  951:     wakeup(&p->nwrite);
00002384  0000100e  LL    0x10 (D 16)
00002388  000fa454  ADDI  0xfa4 (D 4004)
0000238c  0000009d  PSHA
00002390  00236405  JSR   <fwd>
00002394  00000801  ENT   0x8 (D 8)
os.c  952:   }
os.c  953:   if (!p->readopen && !p->writeopen) kfree(p);
00002398  0000100e  LL    0x10 (D 16)
0000239c  000fa81c  LX    0xfa8 (D 4008)
000023a0  00000086  BNZ   <fwd>
000023a4  0000100e  LL    0x10 (D 16)
000023a8  000fac1c  LX    0xfac (D 4012)
000023ac  0023a086  BNZ   <fwd>
000023b0  0000100e  LL    0x10 (D 16)
000023b4  0000009d  PSHA
000023b8  ffdebc05  JSR   0xffffdebc (TO 0x278)
000023bc  00000801  ENT   0x8 (D 8)
os.c  954:   splx(e);
000023c0  0000040e  LL    0x4 (D 4)
000023c4  0000009d  PSHA
000023c8  ffdcdc05  JSR   0xffffdcdc (TO 0xa8)
000023cc  00000801  ENT   0x8 (D 8)
os.c  955: }
os.c  956: 
os.c  957: int pipewrite(struct pipe *p, char *addr, int n)
000023d0  00000802  LEV   0x8 (D 8)
os.c  958: {
os.c  959:   int i, e = splhi();
os.c  960: 
os.c  961:   for (i = 0; i < n; i++) {
000023d4  fffff801  ENT   0xfffffff8 (D -8)
000023d8  ffdcc405  JSR   0xffffdcc4 (TO 0xa0)
000023dc  00000040  SL    0x0 (D 0)
000023e0  00000023  LI    0x0 (D 0)
000023e4  00000440  SL    0x4 (D 4)
000023e8  00000003  JMP   <fwd>
os.c  962:     while (p->nwrite == p->nread + PIPESIZE) {  // XXX DOC: pipewrite-full
000023ec  00000003  JMP   <fwd>
os.c  963:       if (!p->readopen || u->killed) {
000023f0  0000100e  LL    0x10 (D 16)
000023f4  000fa81c  LX    0xfa8 (D 4008)
000023f8  00000084  BZ    <fwd>
000023fc  00210015  LG    0x2100 (D 8448)
00002400  00002c1c  LX    0x2c (D 44)
00002404  00000084  BZ    <fwd>
os.c  964:         splx(e);
00002408  0000000e  LL    0x0 (D 0)
0000240c  0000009d  PSHA
00002410  ffdc9405  JSR   0xffffdc94 (TO 0xa8)
00002414  00000801  ENT   0x8 (D 8)
os.c  965:         return -1;
00002418  ffffff23  LI    0xffffffff (D -1)
0000241c  00000802  LEV   0x8 (D 8)
os.c  966:       }
os.c  967:       wakeup(&p->nread);
00002420  0000100e  LL    0x10 (D 16)
00002424  000fa054  ADDI  0xfa0 (D 4000)
00002428  0000009d  PSHA
0000242c  00239005  JSR   <fwd>
00002430  00000801  ENT   0x8 (D 8)
os.c  968:       sleep(&p->nwrite);  // XXX DOC: pipewrite-sleep
00002434  0000100e  LL    0x10 (D 16)
00002438  000fa454  ADDI  0xfa4 (D 4004)
0000243c  0000009d  PSHA
00002440  0011e805  JSR   <fwd>
00002444  00000801  ENT   0x8 (D 8)
os.c  969:     }
os.c  970:     p->data[p->nwrite++ % PIPESIZE] = addr[i]; // XXX pagefault possible in cli (use inode locks instead?)
00002448  0000100e  LL    0x10 (D 16)
0000244c  000fa41c  LX    0xfa4 (D 4004)
00002450  0000009d  PSHA
00002454  0000180e  LL    0x18 (D 24)
00002458  000fa01c  LX    0xfa0 (D 4000)
0000245c  000fa054  ADDI  0xfa0 (D 4000)
00002460  000000a1  POPB
00002464  00000088  BE    <fwd>
00002468  0000100e  LL    0x10 (D 16)
0000246c  000fa454  ADDI  0xfa4 (D 4004)
00002470  0000003e  LBA 
00002474  0000001c  LX  
00002478  ffffff57  SUBI  0xffffffff (D -1)
0000247c  0000004a  SX  
00002480  ffffff54  ADDI  0xffffffff (D -1)
00002484  000fa066  MDUI  0xfa0 (D 4000)
00002488  00001055  ADDL  0x10 (D 16)
0000248c  0000009d  PSHA
00002490  0000200e  LL    0x20 (D 32)
00002494  00000c55  ADDL  0xc (D 12)
00002498  0000001f  LXC 
0000249c  000000a1  POPB
000024a0  0000004c  SXB 
os.c  971:   }
os.c  972:   wakeup(&p->nread);  // XXX DOC: pipewrite-wakeup
000024a4  0000040e  LL    0x4 (D 4)
000024a8  ffffff57  SUBI  0xffffffff (D -1)
000024ac  00000440  SL    0x4 (D 4)
000024b0  0000040e  LL    0x4 (D 4)
000024b4  00002026  LBL   0x20 (D 32)
000024b8  0000008c  BLT   <fwd>
000024bc  0000100e  LL    0x10 (D 16)
000024c0  000fa054  ADDI  0xfa0 (D 4000)
000024c4  0000009d  PSHA
000024c8  00242c05  JSR   <fwd>
000024cc  00000801  ENT   0x8 (D 8)
os.c  973:   splx(e);
000024d0  0000000e  LL    0x0 (D 0)
000024d4  0000009d  PSHA
000024d8  ffdbcc05  JSR   0xffffdbcc (TO 0xa8)
000024dc  00000801  ENT   0x8 (D 8)
os.c  974:   return n;
000024e0  0000200e  LL    0x20 (D 32)
000024e4  00000802  LEV   0x8 (D 8)
os.c  975: }
os.c  976: 
os.c  977: int piperead(struct pipe *p, char *addr, int n)
000024e8  00000802  LEV   0x8 (D 8)
os.c  978: {
os.c  979:   int i, e = splhi();
os.c  980: 
os.c  981:   while (p->nread == p->nwrite && p->writeopen) {  // XXX DOC: pipe-empty
000024ec  fffff801  ENT   0xfffffff8 (D -8)
000024f0  ffdbac05  JSR   0xffffdbac (TO 0xa0)
000024f4  00000040  SL    0x0 (D 0)
000024f8  00000003  JMP   <fwd>
os.c  982:     if (u->killed) {
000024fc  00210015  LG    0x2100 (D 8448)
00002500  00002c1c  LX    0x2c (D 44)
00002504  00000084  BZ    <fwd>
os.c  983:       splx(e);
00002508  0000000e  LL    0x0 (D 0)
0000250c  0000009d  PSHA
00002510  ffdb9405  JSR   0xffffdb94 (TO 0xa8)
00002514  00000801  ENT   0x8 (D 8)
os.c  984:       return -1;
00002518  ffffff23  LI    0xffffffff (D -1)
0000251c  00000802  LEV   0x8 (D 8)
os.c  985:     }
os.c  986:     sleep(&p->nread); // XXX DOC: piperead-sleep
00002520  0000100e  LL    0x10 (D 16)
00002524  000fa054  ADDI  0xfa0 (D 4000)
00002528  0000009d  PSHA
0000252c  00244005  JSR   <fwd>
00002530  00000801  ENT   0x8 (D 8)
os.c  987:   }
os.c  988:   for (i = 0; i < n; i++) {  // XXX DOC: piperead-copy
00002534  0000100e  LL    0x10 (D 16)
00002538  000fa41c  LX    0xfa4 (D 4004)
0000253c  0000009d  PSHA
00002540  0000180e  LL    0x18 (D 24)
00002544  000fa01c  LX    0xfa0 (D 4000)
00002548  000000a1  POPB
0000254c  0000008a  BNE   <fwd>
00002550  0000100e  LL    0x10 (D 16)
00002554  000fac1c  LX    0xfac (D 4012)
00002558  00000086  BNZ   <fwd>
0000255c  00000023  LI    0x0 (D 0)
00002560  00000440  SL    0x4 (D 4)
00002564  00000003  JMP   <fwd>
os.c  989:     if (p->nread == p->nwrite) break;
00002568  0000100e  LL    0x10 (D 16)
0000256c  000fa41c  LX    0xfa4 (D 4004)
00002570  0000009d  PSHA
00002574  0000180e  LL    0x18 (D 24)
00002578  000fa01c  LX    0xfa0 (D 4000)
0000257c  000000a1  POPB
00002580  0000008a  BNE   <fwd>
00002584  00000003  JMP   <fwd>
os.c  990:     addr[i] = p->data[p->nread++ % PIPESIZE]; // XXX pagefault possible in cli (use inode locks instead?)
00002588  0000180e  LL    0x18 (D 24)
0000258c  00000455  ADDL  0x4 (D 4)
00002590  0000009d  PSHA
00002594  0000180e  LL    0x18 (D 24)
00002598  000fa054  ADDI  0xfa0 (D 4000)
0000259c  0000003e  LBA 
000025a0  0000001c  LX  
000025a4  ffffff57  SUBI  0xffffffff (D -1)
000025a8  0000004a  SX  
000025ac  ffffff54  ADDI  0xffffffff (D -1)
000025b0  000fa066  MDUI  0xfa0 (D 4000)
000025b4  00001855  ADDL  0x18 (D 24)
000025b8  0000001f  LXC 
000025bc  000000a1  POPB
000025c0  0000004c  SXB 
os.c  991:   }
os.c  992:   wakeup(&p->nwrite);  // XXX DOC: piperead-wakeup
000025c4  0000040e  LL    0x4 (D 4)
000025c8  ffffff57  SUBI  0xffffffff (D -1)
000025cc  00000440  SL    0x4 (D 4)
000025d0  0000040e  LL    0x4 (D 4)
000025d4  00002026  LBL   0x20 (D 32)
000025d8  0000008c  BLT   <fwd>
000025dc  0000100e  LL    0x10 (D 16)
000025e0  000fa454  ADDI  0xfa4 (D 4004)
000025e4  0000009d  PSHA
000025e8  0024c805  JSR   <fwd>
000025ec  00000801  ENT   0x8 (D 8)
os.c  993:   splx(e);
000025f0  0000000e  LL    0x0 (D 0)
000025f4  0000009d  PSHA
000025f8  ffdaac05  JSR   0xffffdaac (TO 0xa8)
000025fc  00000801  ENT   0x8 (D 8)
os.c  994:   return i;
00002600  0000040e  LL    0x4 (D 4)
00002604  00000802  LEV   0x8 (D 8)
os.c  995: }
os.c  996: 
os.c  997: // allocate a file structure
os.c  998: struct file *filealloc()
00002608  00000802  LEV   0x8 (D 8)
os.c  999: {
os.c  1000:   struct file *f; int e = splhi();
os.c  1001: 
os.c  1002:   for (f = file; f < file + NFILE; f++) {
0000260c  fffff801  ENT   0xfffffff8 (D -8)
00002610  ffda8c05  JSR   0xffffda8c (TO 0xa0)
00002614  00000040  SL    0x0 (D 0)
00002618  032e8808  LEAG  0x32e88 (D 208520)
0000261c  00000440  SL    0x4 (D 4)
00002620  00000003  JMP   <fwd>
os.c  1003:     if (!f->ref) {
00002624  0000040e  LL    0x4 (D 4)
00002628  0000041c  LX    0x4 (D 4)
0000262c  00000086  BNZ   <fwd>
os.c  1004:       f->ref = 1;
00002630  0000040e  LL    0x4 (D 4)
00002634  00000454  ADDI  0x4 (D 4)
00002638  0000003e  LBA 
0000263c  00000123  LI    0x1 (D 1)
00002640  0000004a  SX  
os.c  1005:       splx(e);
00002644  0000000e  LL    0x0 (D 0)
00002648  0000009d  PSHA
0000264c  ffda5805  JSR   0xffffda58 (TO 0xa8)
00002650  00000801  ENT   0x8 (D 8)
os.c  1006:       return f;
00002654  0000040e  LL    0x4 (D 4)
00002658  00000802  LEV   0x8 (D 8)
os.c  1007:     }
os.c  1008:   }
os.c  1009:   splx(e);
0000265c  0000040e  LL    0x4 (D 4)
00002660  ffffe857  SUBI  0xffffffe8 (D -24)
00002664  00000440  SL    0x4 (D 4)
00002668  0337e808  LEAG  0x337e8 (D 210920)
0000266c  0000003e  LBA 
00002670  0000040e  LL    0x4 (D 4)
00002674  0000008d  BLTU  <fwd>
00002678  0000000e  LL    0x0 (D 0)
0000267c  0000009d  PSHA
00002680  ffda2405  JSR   0xffffda24 (TO 0xa8)
00002684  00000801  ENT   0x8 (D 8)
os.c  1010:   return 0;
00002688  00000023  LI    0x0 (D 0)
0000268c  00000802  LEV   0x8 (D 8)
os.c  1011: }
os.c  1012: 
os.c  1013: // increment ref count for file
os.c  1014: struct file *filedup(struct file *f)
00002690  00000802  LEV   0x8 (D 8)
os.c  1015: {
os.c  1016:   int e = splhi();
os.c  1017:   if (f->ref < 1) panic("filedup");
00002694  fffff801  ENT   0xfffffff8 (D -8)
00002698  ffda0405  JSR   0xffffda04 (TO 0xa0)
0000269c  00000440  SL    0x4 (D 4)
000026a0  0000100e  LL    0x10 (D 16)
000026a4  0000041c  LX    0x4 (D 4)
000026a8  0000013b  LBI   0x1 (D 1)
000026ac  0000008f  BGE   <fwd>
000026b0  00018c08  LEAG  0x18c (D 396)
000026b4  0000009d  PSHA
000026b8  ffde7805  JSR   0xffffde78 (TO 0x534)
000026bc  00000801  ENT   0x8 (D 8)
os.c  1018:   f->ref++;
000026c0  0000100e  LL    0x10 (D 16)
000026c4  00000454  ADDI  0x4 (D 4)
000026c8  0000003e  LBA 
000026cc  0000001c  LX  
000026d0  ffffff57  SUBI  0xffffffff (D -1)
000026d4  0000004a  SX  
os.c  1019:   splx(e);
000026d8  0000040e  LL    0x4 (D 4)
000026dc  0000009d  PSHA
000026e0  ffd9c405  JSR   0xffffd9c4 (TO 0xa8)
000026e4  00000801  ENT   0x8 (D 8)
os.c  1020:   return f;
000026e8  0000100e  LL    0x10 (D 16)
000026ec  00000802  LEV   0x8 (D 8)
os.c  1021: }
os.c  1022: 
os.c  1023: // allocate a file descriptor for the given file.  Takes over file reference from caller on success.
os.c  1024: int fdalloc(struct file *f)
000026f0  00000802  LEV   0x8 (D 8)
os.c  1025: {
os.c  1026:   int fd;
os.c  1027: 
os.c  1028:   for (fd = 0; fd < NOFILE; fd++) {
000026f4  fffff801  ENT   0xfffffff8 (D -8)
000026f8  00000023  LI    0x0 (D 0)
000026fc  00000440  SL    0x4 (D 4)
00002700  00000003  JMP   <fwd>
os.c  1029:     if (!u->ofile[fd]) {
00002704  00210015  LG    0x2100 (D 8448)
00002708  00003054  ADDI  0x30 (D 48)
0000270c  0000009d  PSHA
00002710  00000c0e  LL    0xc (D 12)
00002714  0000045a  MULI  0x4 (D 4)
00002718  000000a1  POPB
0000271c  00000053  ADD 
00002720  0000001c  LX  
00002724  00000086  BNZ   <fwd>
os.c  1030:       u->ofile[fd] = f;
00002728  00210015  LG    0x2100 (D 8448)
0000272c  00003054  ADDI  0x30 (D 48)
00002730  0000009d  PSHA
00002734  00000c0e  LL    0xc (D 12)
00002738  0000045a  MULI  0x4 (D 4)
0000273c  000000a1  POPB
00002740  00000053  ADD 
00002744  0000003e  LBA 
00002748  0000100e  LL    0x10 (D 16)
0000274c  0000004a  SX  
os.c  1031:       return fd;
00002750  0000040e  LL    0x4 (D 4)
00002754  00000802  LEV   0x8 (D 8)
os.c  1032:     }
os.c  1033:   }
os.c  1034:   return -1;
00002758  0000040e  LL    0x4 (D 4)
0000275c  ffffff57  SUBI  0xffffffff (D -1)
00002760  00000440  SL    0x4 (D 4)
00002764  0000040e  LL    0x4 (D 4)
00002768  0000103b  LBI   0x10 (D 16)
0000276c  0000008c  BLT   <fwd>
00002770  ffffff23  LI    0xffffffff (D -1)
00002774  00000802  LEV   0x8 (D 8)
os.c  1035: }
os.c  1036: 
os.c  1037: struct inode *create(char *path, ushort mode, int dev)
00002778  00000802  LEV   0x8 (D 8)
os.c  1038: {
os.c  1039:   struct inode *ip, *dp;
os.c  1040:   char name[DIRSIZ];
os.c  1041: 
os.c  1042:   if (!(dp = nameiparent(path, name))) return 0;
0000277c  fffef801  ENT   0xfffffef8 (D -264)
00002780  00000407  LEA   0x4 (D 4)
00002784  0000009d  PSHA
00002788  0001180e  LL    0x118 (D 280)
0000278c  0000009d  PSHA
00002790  fffa6805  JSR   0xfffffa68 (TO 0x21fc)
00002794  00001001  ENT   0x10 (D 16)
00002798  00010040  SL    0x100 (D 256)
0000279c  00000086  BNZ   <fwd>
000027a0  00000023  LI    0x0 (D 0)
000027a4  00010802  LEV   0x108 (D 264)
os.c  1043:   ilock(dp);
000027a8  0001000e  LL    0x100 (D 256)
000027ac  0000009d  PSHA
000027b0  ffe9f405  JSR   0xffffe9f4 (TO 0x11a8)
000027b4  00000801  ENT   0x8 (D 8)
os.c  1044: 
os.c  1045:   if (ip = dirlookup(dp, name, 0)) {
000027b8  0000009e  PSHI  0x0 (D 0)
000027bc  00000c07  LEA   0xc (D 12)
000027c0  0000009d  PSHA
000027c4  0001100e  LL    0x110 (D 272)
000027c8  0000009d  PSHA
000027cc  fff5ac05  JSR   0xfffff5ac (TO 0x1d7c)
000027d0  00001801  ENT   0x18 (D 24)
000027d4  00010440  SL    0x104 (D 260)
000027d8  00000084  BZ    <fwd>
os.c  1046:     iunlockput(dp);
000027dc  0001000e  LL    0x100 (D 256)
000027e0  0000009d  PSHA
000027e4  ffece805  JSR   0xffffece8 (TO 0x14d0)
000027e8  00000801  ENT   0x8 (D 8)
os.c  1047:     ilock(ip);
000027ec  0001040e  LL    0x104 (D 260)
000027f0  0000009d  PSHA
000027f4  ffe9b005  JSR   0xffffe9b0 (TO 0x11a8)
000027f8  00000801  ENT   0x8 (D 8)
os.c  1048:     if ((mode & S_IFMT) == S_IFREG && (ip->mode & S_IFMT) == S_IFREG) return ip;
000027fc  00011810  LLH   0x118 (D 280)
00002800  00f00069  ANDI  0xf000 (D 61440)
00002804  0080003b  LBI   0x8000 (D 32768)
00002808  0000008a  BNE   <fwd>
0000280c  0001040e  LL    0x104 (D 260)
00002810  00000c1e  LXH   0xc (D 12)
00002814  00f00069  ANDI  0xf000 (D 61440)
00002818  0080003b  LBI   0x8000 (D 32768)
0000281c  0028088a  BNE   <fwd>
00002820  0001040e  LL    0x104 (D 260)
00002824  00010802  LEV   0x108 (D 264)
os.c  1049:     iunlockput(ip);
00002828  0001040e  LL    0x104 (D 260)
0000282c  0000009d  PSHA
00002830  ffec9c05  JSR   0xffffec9c (TO 0x14d0)
00002834  00000801  ENT   0x8 (D 8)
os.c  1050:     return 0;
00002838  00000023  LI    0x0 (D 0)
0000283c  00010802  LEV   0x108 (D 264)
os.c  1051:   }
os.c  1052: 
os.c  1053:   if (!(ip = ialloc(mode))) panic("create: ialloc");
00002840  00011810  LLH   0x118 (D 280)
00002844  0000009d  PSHA
00002848  ffe7c005  JSR   0xffffe7c0 (TO 0x100c)
0000284c  00000801  ENT   0x8 (D 8)
00002850  00010440  SL    0x104 (D 260)
00002854  00000086  BNZ   <fwd>
00002858  00019408  LEAG  0x194 (D 404)
0000285c  0000009d  PSHA
00002860  ffdcd005  JSR   0xffffdcd0 (TO 0x534)
00002864  00000801  ENT   0x8 (D 8)
os.c  1054: 
os.c  1055:   ilock(ip);
00002868  0001040e  LL    0x104 (D 260)
0000286c  0000009d  PSHA
00002870  ffe93405  JSR   0xffffe934 (TO 0x11a8)
00002874  00000801  ENT   0x8 (D 8)
os.c  1056:   if ((mode & S_IFMT) == S_IFCHR || (ip->mode & S_IFMT) == S_IFBLK) {
00002878  00011810  LLH   0x118 (D 280)
0000287c  00f00069  ANDI  0xf000 (D 61440)
00002880  0020003b  LBI   0x2000 (D 8192)
00002884  00000088  BE    <fwd>
00002888  0001040e  LL    0x104 (D 260)
0000288c  00000c1e  LXH   0xc (D 12)
00002890  00f00069  ANDI  0xf000 (D 61440)
00002894  0030003b  LBI   0x3000 (D 12288)
00002898  0000008a  BNE   <fwd>
os.c  1057:     ip->dir[0] = (dev >> 8) & 0xff;
0000289c  0001040e  LL    0x104 (D 260)
000028a0  00001854  ADDI  0x18 (D 24)
000028a4  0000009d  PSHA
000028a8  0001280e  LL    0x128 (D 296)
000028ac  00000875  SHRI  0x8 (D 8)
000028b0  0000ff69  ANDI  0xff (D 255)
000028b4  000000a1  POPB
000028b8  0000004a  SX  
os.c  1058:     ip->dir[1] = dev & 0xff;
000028bc  0001040e  LL    0x104 (D 260)
000028c0  00001854  ADDI  0x18 (D 24)
000028c4  00000454  ADDI  0x4 (D 4)
000028c8  0000009d  PSHA
000028cc  0001280e  LL    0x128 (D 296)
000028d0  0000ff69  ANDI  0xff (D 255)
000028d4  000000a1  POPB
000028d8  0000004a  SX  
os.c  1059:   }
os.c  1060:   ip->nlink = 1;
000028dc  0001040e  LL    0x104 (D 260)
000028e0  00001054  ADDI  0x10 (D 16)
000028e4  0000003e  LBA 
000028e8  00000123  LI    0x1 (D 1)
000028ec  0000004a  SX  
os.c  1061:   iupdate(ip);
000028f0  0001040e  LL    0x104 (D 260)
000028f4  0000009d  PSHA
000028f8  ffe79805  JSR   0xffffe798 (TO 0x1094)
000028fc  00000801  ENT   0x8 (D 8)
os.c  1062: 
os.c  1063:   if ((mode & S_IFMT) == S_IFDIR) {  // create . and .. entries
00002900  00011810  LLH   0x118 (D 280)
00002904  00f00069  ANDI  0xf000 (D 61440)
00002908  0040003b  LBI   0x4000 (D 16384)
0000290c  0000008a  BNE   <fwd>
os.c  1064:     dp->nlink++;  // for ".."
00002910  0001000e  LL    0x100 (D 256)
00002914  00001054  ADDI  0x10 (D 16)
00002918  0000003e  LBA 
0000291c  0000001c  LX  
00002920  ffffff57  SUBI  0xffffffff (D -1)
00002924  0000004a  SX  
os.c  1065:     iupdate(dp);
00002928  0001000e  LL    0x100 (D 256)
0000292c  0000009d  PSHA
00002930  ffe76005  JSR   0xffffe760 (TO 0x1094)
00002934  00000801  ENT   0x8 (D 8)
os.c  1066:     // no ip->nlink++ for ".": avoid cyclic ref count
os.c  1067:     if (dirlink(ip, ".", ip->inum) || dirlink(ip, "..", dp->inum)) panic("create dots");
00002938  0001040e  LL    0x104 (D 260)
0000293c  0000001c  LX  
00002940  0000009d  PSHA
00002944  0001a308  LEAG  0x1a3 (D 419)
00002948  0000009d  PSHA
0000294c  0001140e  LL    0x114 (D 276)
00002950  0000009d  PSHA
00002954  fff50c05  JSR   0xfffff50c (TO 0x1e64)
00002958  00001801  ENT   0x18 (D 24)
0000295c  00000086  BNZ   <fwd>
00002960  0001000e  LL    0x100 (D 256)
00002964  0000001c  LX  
00002968  0000009d  PSHA
0000296c  0001a508  LEAG  0x1a5 (D 421)
00002970  0000009d  PSHA
00002974  0001140e  LL    0x114 (D 276)
00002978  0000009d  PSHA
0000297c  fff4e405  JSR   0xfffff4e4 (TO 0x1e64)
00002980  00001801  ENT   0x18 (D 24)
00002984  00000084  BZ    <fwd>
00002988  0001a808  LEAG  0x1a8 (D 424)
0000298c  0000009d  PSHA
00002990  ffdba005  JSR   0xffffdba0 (TO 0x534)
00002994  00000801  ENT   0x8 (D 8)
os.c  1068:   }
os.c  1069: 
os.c  1070:   if (dirlink(dp, name, ip->inum)) panic("create: dirlink");
00002998  0001040e  LL    0x104 (D 260)
0000299c  0000001c  LX  
000029a0  0000009d  PSHA
000029a4  00000c07  LEA   0xc (D 12)
000029a8  0000009d  PSHA
000029ac  0001100e  LL    0x110 (D 272)
000029b0  0000009d  PSHA
000029b4  fff4ac05  JSR   0xfffff4ac (TO 0x1e64)
000029b8  00001801  ENT   0x18 (D 24)
000029bc  00000084  BZ    <fwd>
000029c0  0001b408  LEAG  0x1b4 (D 436)
000029c4  0000009d  PSHA
000029c8  ffdb6805  JSR   0xffffdb68 (TO 0x534)
000029cc  00000801  ENT   0x8 (D 8)
os.c  1071: 
os.c  1072:   iunlockput(dp);
000029d0  0001000e  LL    0x100 (D 256)
000029d4  0000009d  PSHA
000029d8  ffeaf405  JSR   0xffffeaf4 (TO 0x14d0)
000029dc  00000801  ENT   0x8 (D 8)
os.c  1073:   return ip;
000029e0  0001040e  LL    0x104 (D 260)
000029e4  00010802  LEV   0x108 (D 264)
os.c  1074: }
os.c  1075: 
os.c  1076: // *** syscalls ***
os.c  1077: int svalid(uint s) { return (s < u->sz) && memchr(s, 0, u->sz - s); }
000029e8  00010802  LEV   0x108 (D 264)
000029ec  00210015  LG    0x2100 (D 8448)
000029f0  0000081c  LX    0x8 (D 8)
000029f4  0000003e  LBA 
000029f8  0000080e  LL    0x8 (D 8)
000029fc  00000090  BGEU  <fwd>
00002a00  00210015  LG    0x2100 (D 8448)
00002a04  0000081c  LX    0x8 (D 8)
00002a08  00000858  SUBL  0x8 (D 8)
00002a0c  0000009d  PSHA
00002a10  0000009e  PSHI  0x0 (D 0)
00002a14  0000180e  LL    0x18 (D 24)
00002a18  0000009d  PSHA
00002a1c  ffd61005  JSR   0xffffd610 (TO 0x30)
00002a20  00001801  ENT   0x18 (D 24)
00002a24  0029fc84  BZ    <fwd>
00002a28  00000123  LI    0x1 (D 1)
00002a2c  00000003  JMP   <fwd>
00002a30  00000023  LI    0x0 (D 0)
00002a34  00000002  LEV   0x0 (D 0)
os.c  1078: int mvalid(uint a, int n) { return a <= u->sz && a+n <= u->sz; }
00002a38  00000002  LEV   0x0 (D 0)
00002a3c  00210015  LG    0x2100 (D 8448)
00002a40  0000081c  LX    0x8 (D 8)
00002a44  00000826  LBL   0x8 (D 8)
00002a48  0000008d  BLTU  <fwd>
00002a4c  0000080e  LL    0x8 (D 8)
00002a50  00001055  ADDL  0x10 (D 16)
00002a54  0000009d  PSHA
00002a58  00210015  LG    0x2100 (D 8448)
00002a5c  0000081c  LX    0x8 (D 8)
00002a60  000000a1  POPB
00002a64  002a488d  BLTU  <fwd>
00002a68  00000123  LI    0x1 (D 1)
00002a6c  00000003  JMP   <fwd>
00002a70  00000023  LI    0x0 (D 0)
00002a74  00000002  LEV   0x0 (D 0)
os.c  1079: struct file *getf(uint fd) { return (fd < NOFILE) ? u->ofile[fd] : 0; }
00002a78  00000002  LEV   0x0 (D 0)
00002a7c  0000080e  LL    0x8 (D 8)
00002a80  0000103b  LBI   0x10 (D 16)
00002a84  00000090  BGEU  <fwd>
00002a88  00210015  LG    0x2100 (D 8448)
00002a8c  00003054  ADDI  0x30 (D 48)
00002a90  0000009d  PSHA
00002a94  0000100e  LL    0x10 (D 16)
00002a98  0000045a  MULI  0x4 (D 4)
00002a9c  000000a1  POPB
00002aa0  00000053  ADD 
00002aa4  0000001c  LX  
00002aa8  00000003  JMP   <fwd>
00002aac  00000023  LI    0x0 (D 0)
00002ab0  00000002  LEV   0x0 (D 0)
os.c  1080: 
os.c  1081: int sockopen(int family, int type, int protocol) { asm(LL,8); asm(LBL,16); asm(LCL,24); asm(NET1); }  
00002ab4  00000002  LEV   0x0 (D 0)
00002ab8  0000080e  LL    0x8 (D 8)
00002abc  00001026  LBL   0x10 (D 16)
00002ac0  000018ac  LCL   0x18 (D 24)
00002ac4  000000b3  NET1
os.c  1082: sockclose(int sd) { asm(LL,8); asm(NET2); } // XXX
00002ac8  00000002  LEV   0x0 (D 0)
00002acc  0000080e  LL    0x8 (D 8)
00002ad0  000000b4  NET2
os.c  1083: int sockconnect(int fd, uint family_port, uint addr) { asm(LL, 8); asm(LBL,16); asm(LCL,24); asm(NET3); }
00002ad4  00000002  LEV   0x0 (D 0)
00002ad8  0000080e  LL    0x8 (D 8)
00002adc  00001026  LBL   0x10 (D 16)
00002ae0  000018ac  LCL   0x18 (D 24)
00002ae4  000000b5  NET3
os.c  1084: int sockread (int sd, char *addr, int n) { asm(LL,8); asm(LBL,16); asm(LCL,24); asm(NET4); }
00002ae8  00000002  LEV   0x0 (D 0)
00002aec  0000080e  LL    0x8 (D 8)
00002af0  00001026  LBL   0x10 (D 16)
00002af4  000018ac  LCL   0x18 (D 24)
00002af8  000000b6  NET4
os.c  1085: int sockwrite(int sd, char *addr, int n) { asm(LL,8); asm(LBL,16); asm(LCL,24); asm(NET5); }
00002afc  00000002  LEV   0x0 (D 0)
00002b00  0000080e  LL    0x8 (D 8)
00002b04  00001026  LBL   0x10 (D 16)
00002b08  000018ac  LCL   0x18 (D 24)
00002b0c  000000b7  NET5
os.c  1086: int sockpoll(int sd) { asm(LL, 8); asm(NET6); }
00002b10  00000002  LEV   0x0 (D 0)
00002b14  0000080e  LL    0x8 (D 8)
00002b18  000000b8  NET6
os.c  1087: enum { M_OPEN, M_CLOSE, M_READ, M_WRITE, M_SEEK, M_FSTAT, M_SYNC };
00002b1c  00000002  LEV   0x0 (D 0)
os.c  1088: 
os.c  1089: int socktx(int sd, void *p, int n)
os.c  1090: {
os.c  1091:   int r;
os.c  1092:   while (n > 0) {
00002b20  fffff801  ENT   0xfffffff8 (D -8)
00002b24  00000003  JMP   <fwd>
os.c  1093:     if ((r = sockwrite(sd, p, n)) <= 0) return -1;  // XXX need some kind of ready to write? XXX <= 0?
00002b28  0000200e  LL    0x20 (D 32)
00002b2c  0000009d  PSHA
00002b30  0000200e  LL    0x20 (D 32)
00002b34  0000009d  PSHA
00002b38  0000200e  LL    0x20 (D 32)
00002b3c  0000009d  PSHA
00002b40  ffffbc05  JSR   0xffffffbc (TO 0x2b00)
00002b44  00001801  ENT   0x18 (D 24)
00002b48  00000440  SL    0x4 (D 4)
00002b4c  0000003e  LBA 
00002b50  00000023  LI    0x0 (D 0)
00002b54  0000008c  BLT   <fwd>
00002b58  ffffff23  LI    0xffffffff (D -1)
00002b5c  00000802  LEV   0x8 (D 8)
os.c  1094:     n -= r;
00002b60  0000200e  LL    0x20 (D 32)
00002b64  00000458  SUBL  0x4 (D 4)
00002b68  00002040  SL    0x20 (D 32)
os.c  1095:     p += r;
00002b6c  0000180e  LL    0x18 (D 24)
00002b70  00000455  ADDL  0x4 (D 4)
00002b74  00001840  SL    0x18 (D 24)
os.c  1096:   }
os.c  1097:   return 0;
00002b78  00000023  LI    0x0 (D 0)
00002b7c  00002026  LBL   0x20 (D 32)
00002b80  0000008c  BLT   <fwd>
00002b84  00000023  LI    0x0 (D 0)
00002b88  00000802  LEV   0x8 (D 8)
os.c  1098: }
os.c  1099: // int cyc() { asm(CYC); } XXX
os.c  1100: int sockrx(int sd, void *p, int n) // XXX this is always going to be slow until I fix the sockpoll (since ssleep waits for a comparitively long time (timer vs. em delta))
00002b8c  00000802  LEV   0x8 (D 8)
os.c  1101: {
os.c  1102:   int r; // uint cy, nyc;
os.c  1103:   while (n > 0) {
00002b90  fffff801  ENT   0xfffffff8 (D -8)
00002b94  00000003  JMP   <fwd>
os.c  1104:     while (!sockpoll(sd)) ssleep(1); // XXX needs to block properly XXX should I lock the inode?
00002b98  00000003  JMP   <fwd>
00002b9c  0000019e  PSHI  0x1 (D 1)
00002ba0  00000005  JSR   <fwd>
00002ba4  00000801  ENT   0x8 (D 8)
os.c  1105: //    while (!sockpoll(sd)) { printf("x"); ssleep(1); } // XXX needs to block properly XXX should I lock the inode?
os.c  1106: //    while (!sockpoll(sd)) { cy = cyc(); for (r = 0; r < 10; r++) { nyc = cyc(); printf("[%d]",nyc - cy); cy = nyc; ssleep(100); } } // XXX needs to block properly XXX should I lock the inode?
os.c  1107: //    while (!sockpoll(sd)) { cy = cyc(); for (r = 0; r < 10; r++) { nyc = cyc(); printf("[%d]",nyc - cy); cy = nyc; ssleep(1); } } // XXX needs to block properly XXX should I lock the inode?
os.c  1108:     if ((r = sockread(sd, p, n)) <= 0) { printf("sockrx() sockread()\n"); return -1; } //  XXX <= 0?
00002ba8  0000100e  LL    0x10 (D 16)
00002bac  0000009d  PSHA
00002bb0  ffff6005  JSR   0xffffff60 (TO 0x2b14)
00002bb4  00000801  ENT   0x8 (D 8)
00002bb8  00000084  BZ    <fwd>
00002bbc  0000200e  LL    0x20 (D 32)
00002bc0  0000009d  PSHA
00002bc4  0000200e  LL    0x20 (D 32)
00002bc8  0000009d  PSHA
00002bcc  0000200e  LL    0x20 (D 32)
00002bd0  0000009d  PSHA
00002bd4  ffff1405  JSR   0xffffff14 (TO 0x2aec)
00002bd8  00001801  ENT   0x18 (D 24)
00002bdc  00000440  SL    0x4 (D 4)
00002be0  0000003e  LBA 
00002be4  00000023  LI    0x0 (D 0)
00002be8  0000008c  BLT   <fwd>
00002bec  0001c408  LEAG  0x1c4 (D 452)
00002bf0  0000009d  PSHA
00002bf4  ffd7c005  JSR   0xffffd7c0 (TO 0x3b8)
00002bf8  00000801  ENT   0x8 (D 8)
00002bfc  ffffff23  LI    0xffffffff (D -1)
00002c00  00000802  LEV   0x8 (D 8)
os.c  1109:     n -= r;
00002c04  0000200e  LL    0x20 (D 32)
00002c08  00000458  SUBL  0x4 (D 4)
00002c0c  00002040  SL    0x20 (D 32)
os.c  1110:     p += r; 
00002c10  0000180e  LL    0x18 (D 24)
00002c14  00000455  ADDL  0x4 (D 4)
00002c18  00001840  SL    0x18 (D 24)
os.c  1111:   }
os.c  1112:   return 0;
00002c1c  00000023  LI    0x0 (D 0)
00002c20  00002026  LBL   0x20 (D 32)
00002c24  0000008c  BLT   <fwd>
00002c28  00000023  LI    0x0 (D 0)
00002c2c  00000802  LEV   0x8 (D 8)
os.c  1113: }
os.c  1114: 
os.c  1115: fileclose(struct file *f)
00002c30  00000802  LEV   0x8 (D 8)
os.c  1116: {
os.c  1117:   struct file ff; int e = splhi();
os.c  1118: 
os.c  1119:   if (f->ref < 1) panic("close");
00002c34  ffffe001  ENT   0xffffffe0 (D -32)
00002c38  ffd46405  JSR   0xffffd464 (TO 0xa0)
00002c3c  00000440  SL    0x4 (D 4)
00002c40  0000280e  LL    0x28 (D 40)
00002c44  0000041c  LX    0x4 (D 4)
00002c48  0000013b  LBI   0x1 (D 1)
00002c4c  0000008f  BGE   <fwd>
00002c50  0001d908  LEAG  0x1d9 (D 473)
00002c54  0000009d  PSHA
00002c58  ffd8d805  JSR   0xffffd8d8 (TO 0x534)
00002c5c  00000801  ENT   0x8 (D 8)
os.c  1120:   if (--f->ref > 0) {
00002c60  0000280e  LL    0x28 (D 40)
00002c64  00000454  ADDI  0x4 (D 4)
00002c68  0000003e  LBA 
00002c6c  0000001c  LX  
00002c70  00000157  SUBI  0x1 (D 1)
00002c74  0000004a  SX  
00002c78  0000003e  LBA 
00002c7c  00000023  LI    0x0 (D 0)
00002c80  0000008f  BGE   <fwd>
os.c  1121:     splx(e);
00002c84  0000040e  LL    0x4 (D 4)
00002c88  0000009d  PSHA
00002c8c  ffd41805  JSR   0xffffd418 (TO 0xa8)
00002c90  00000801  ENT   0x8 (D 8)
os.c  1122:     return;
00002c94  00002002  LEV   0x20 (D 32)
os.c  1123:   }
os.c  1124:   memcpy(&ff, f, sizeof(struct file)); //XXX  ff = *f;
00002c98  0000189e  PSHI  0x18 (D 24)
00002c9c  0000300e  LL    0x30 (D 48)
00002ca0  0000009d  PSHA
00002ca4  00001807  LEA   0x18 (D 24)
00002ca8  0000009d  PSHA
00002cac  ffd35005  JSR   0xffffd350 (TO 0x0)
00002cb0  00001801  ENT   0x18 (D 24)
os.c  1125:   f->ref = 0;
00002cb4  0000280e  LL    0x28 (D 40)
00002cb8  00000454  ADDI  0x4 (D 4)
00002cbc  0000003e  LBA 
00002cc0  00000023  LI    0x0 (D 0)
00002cc4  0000004a  SX  
os.c  1126:   f->type = FD_NONE;
00002cc8  00000023  LI    0x0 (D 0)
00002ccc  00002826  LBL   0x28 (D 40)
00002cd0  0000004a  SX  
os.c  1127:   splx(e);
00002cd4  0000040e  LL    0x4 (D 4)
00002cd8  0000009d  PSHA
00002cdc  ffd3c805  JSR   0xffffd3c8 (TO 0xa8)
00002ce0  00000801  ENT   0x8 (D 8)
os.c  1128:   
os.c  1129:   switch (ff.type) {
00002ce4  0000080e  LL    0x8 (D 8)
00002ce8  00000003  JMP   <fwd>
os.c  1130:   case FD_PIPE:   pipeclose(ff.pipe, ff.writable); break;
00002cec  00001111  LLC   0x11 (D 17)
00002cf0  0000009d  PSHA
00002cf4  00001c0e  LL    0x1c (D 28)
00002cf8  0000009d  PSHA
00002cfc  fff63005  JSR   0xfffff630 (TO 0x2330)
00002d00  00001001  ENT   0x10 (D 16)
00002d04  00000003  JMP   <fwd>
os.c  1131:   case FD_INODE:  iput(ff.ip); break;
00002d08  0000180e  LL    0x18 (D 24)
00002d0c  0000009d  PSHA
00002d10  ffe6ac05  JSR   0xffffe6ac (TO 0x13c0)
00002d14  00000801  ENT   0x8 (D 8)
00002d18  002d0403  JMP   <fwd>
os.c  1132:   case FD_SOCKET:
os.c  1133:   case FD_RFS:    sockclose(ff.off);
00002d1c  00001c0e  LL    0x1c (D 28)
00002d20  0000009d  PSHA
00002d24  fffda405  JSR   0xfffffda4 (TO 0x2acc)
00002d28  00000801  ENT   0x8 (D 8)
os.c  1134:   }
os.c  1135: }
00002d2c  002d1803  JMP   <fwd>
00002d30  0000053b  LBI   0x5 (D 5)
00002d34  002d2c90  BGEU  <fwd>
00002d38  0001e004  JMPI  0x1e0 (D 480)
os.c  1136: 
os.c  1137: int close(int fd)
00002d3c  00002002  LEV   0x20 (D 32)
os.c  1138: {
os.c  1139:   struct file *f;
os.c  1140:   if (!(f = getf(fd))) return -1;
00002d40  fffff801  ENT   0xfffffff8 (D -8)
00002d44  0000100e  LL    0x10 (D 16)
00002d48  0000009d  PSHA
00002d4c  fffd2c05  JSR   0xfffffd2c (TO 0x2a7c)
00002d50  00000801  ENT   0x8 (D 8)
00002d54  00000440  SL    0x4 (D 4)
00002d58  00000086  BNZ   <fwd>
00002d5c  ffffff23  LI    0xffffffff (D -1)
00002d60  00000802  LEV   0x8 (D 8)
os.c  1141:   u->ofile[fd] = 0;
00002d64  00210015  LG    0x2100 (D 8448)
00002d68  00003054  ADDI  0x30 (D 48)
00002d6c  0000009d  PSHA
00002d70  0000180e  LL    0x18 (D 24)
00002d74  0000045a  MULI  0x4 (D 4)
00002d78  000000a1  POPB
00002d7c  00000053  ADD 
00002d80  0000003e  LBA 
00002d84  00000023  LI    0x0 (D 0)
00002d88  0000004a  SX  
os.c  1142:   fileclose(f);
00002d8c  0000040e  LL    0x4 (D 4)
00002d90  0000009d  PSHA
00002d94  fffe9c05  JSR   0xfffffe9c (TO 0x2c34)
00002d98  00000801  ENT   0x8 (D 8)
os.c  1143:   return 0;
00002d9c  00000023  LI    0x0 (D 0)
00002da0  00000802  LEV   0x8 (D 8)
os.c  1144: }
os.c  1145: 
os.c  1146: int fstat(int fd, struct stat *st)
00002da4  00000802  LEV   0x8 (D 8)
os.c  1147: {
os.c  1148:   int r; struct file *f;
os.c  1149:   if (!(f = getf(fd)) || !mvalid(st, sizeof(struct stat))) return -1;
00002da8  fffff801  ENT   0xfffffff8 (D -8)
00002dac  0000100e  LL    0x10 (D 16)
00002db0  0000009d  PSHA
00002db4  fffcc405  JSR   0xfffffcc4 (TO 0x2a7c)
00002db8  00000801  ENT   0x8 (D 8)
00002dbc  00000040  SL    0x0 (D 0)
00002dc0  00000084  BZ    <fwd>
00002dc4  0000109e  PSHI  0x10 (D 16)
00002dc8  0000200e  LL    0x20 (D 32)
00002dcc  0000009d  PSHA
00002dd0  fffc6805  JSR   0xfffffc68 (TO 0x2a3c)
00002dd4  00001001  ENT   0x10 (D 16)
00002dd8  00000086  BNZ   <fwd>
00002ddc  ffffff23  LI    0xffffffff (D -1)
00002de0  00000802  LEV   0x8 (D 8)
os.c  1150:   switch (f->type) {
00002de4  0000000e  LL    0x0 (D 0)
00002de8  0000001c  LX  
00002dec  00000003  JMP   <fwd>
os.c  1151:   case FD_INODE:
os.c  1152:     ilock(f->ip);
00002df0  0000000e  LL    0x0 (D 0)
00002df4  0000101c  LX    0x10 (D 16)
00002df8  0000009d  PSHA
00002dfc  ffe3a805  JSR   0xffffe3a8 (TO 0x11a8)
00002e00  00000801  ENT   0x8 (D 8)
os.c  1153:     stati(f->ip, st);
00002e04  0000180e  LL    0x18 (D 24)
00002e08  0000009d  PSHA
00002e0c  0000080e  LL    0x8 (D 8)
00002e10  0000101c  LX    0x10 (D 16)
00002e14  0000009d  PSHA
00002e18  ffea6c05  JSR   0xffffea6c (TO 0x1888)
00002e1c  00001001  ENT   0x10 (D 16)
os.c  1154:     iunlock(f->ip);
00002e20  0000000e  LL    0x0 (D 0)
00002e24  0000101c  LX    0x10 (D 16)
00002e28  0000009d  PSHA
00002e2c  ffe51005  JSR   0xffffe510 (TO 0x1340)
00002e30  00000801  ENT   0x8 (D 8)
os.c  1155:     return 0;
00002e34  00000023  LI    0x0 (D 0)
00002e38  00000802  LEV   0x8 (D 8)
os.c  1156:  case FD_RFS:
os.c  1157:     r = M_FSTAT;
00002e3c  00000523  LI    0x5 (D 5)
00002e40  00000440  SL    0x4 (D 4)
os.c  1158:     if (socktx(f->off, &r, 4) || sockrx(f->off, &r, 4) || (r == 0 && sockrx(f->off, st, sizeof(struct stat)))) return -1;
00002e44  0000049e  PSHI  0x4 (D 4)
00002e48  00000c07  LEA   0xc (D 12)
00002e4c  0000009d  PSHA
00002e50  0000100e  LL    0x10 (D 16)
00002e54  0000141c  LX    0x14 (D 20)
00002e58  0000009d  PSHA
00002e5c  fffcc005  JSR   0xfffffcc0 (TO 0x2b20)
00002e60  00001801  ENT   0x18 (D 24)
00002e64  00000086  BNZ   <fwd>
00002e68  0000049e  PSHI  0x4 (D 4)
00002e6c  00000c07  LEA   0xc (D 12)
00002e70  0000009d  PSHA
00002e74  0000100e  LL    0x10 (D 16)
00002e78  0000141c  LX    0x14 (D 20)
00002e7c  0000009d  PSHA
00002e80  fffd0c05  JSR   0xfffffd0c (TO 0x2b90)
00002e84  00001801  ENT   0x18 (D 24)
00002e88  002e6486  BNZ   <fwd>
00002e8c  0000040e  LL    0x4 (D 4)
00002e90  0000003b  LBI   0x0 (D 0)
00002e94  0000008a  BNE   <fwd>
00002e98  0000109e  PSHI  0x10 (D 16)
00002e9c  0000200e  LL    0x20 (D 32)
00002ea0  0000009d  PSHA
00002ea4  0000100e  LL    0x10 (D 16)
00002ea8  0000141c  LX    0x14 (D 20)
00002eac  0000009d  PSHA
00002eb0  fffcdc05  JSR   0xfffffcdc (TO 0x2b90)
00002eb4  00001801  ENT   0x18 (D 24)
00002eb8  002e9484  BZ    <fwd>
00002ebc  ffffff23  LI    0xffffffff (D -1)
00002ec0  00000802  LEV   0x8 (D 8)
os.c  1159:     return r;
00002ec4  0000040e  LL    0x4 (D 4)
00002ec8  00000802  LEV   0x8 (D 8)
os.c  1160:   }
os.c  1161:   return -1;
00002ecc  00000003  JMP   <fwd>
00002ed0  0000053b  LBI   0x5 (D 5)
00002ed4  002ecc90  BGEU  <fwd>
00002ed8  0001f404  JMPI  0x1f4 (D 500)
00002edc  ffffff23  LI    0xffffffff (D -1)
00002ee0  00000802  LEV   0x8 (D 8)
os.c  1162: }
os.c  1163: 
os.c  1164: int read(int fd, char *addr, int n)
00002ee4  00000802  LEV   0x8 (D 8)
os.c  1165: {
os.c  1166:   int r; int h[2]; struct file *f;
os.c  1167:   if (!(f = getf(fd)) || !f->readable || !mvalid(addr, n)) return -1;
00002ee8  fffff001  ENT   0xfffffff0 (D -16)
00002eec  0000180e  LL    0x18 (D 24)
00002ef0  0000009d  PSHA
00002ef4  fffb8405  JSR   0xfffffb84 (TO 0x2a7c)
00002ef8  00000801  ENT   0x8 (D 8)
00002efc  00000040  SL    0x0 (D 0)
00002f00  00000084  BZ    <fwd>
00002f04  0000000e  LL    0x0 (D 0)
00002f08  0000081f  LXC   0x8 (D 8)
00002f0c  002f0084  BZ    <fwd>
00002f10  0000280e  LL    0x28 (D 40)
00002f14  0000009d  PSHA
00002f18  0000280e  LL    0x28 (D 40)
00002f1c  0000009d  PSHA
00002f20  fffb1805  JSR   0xfffffb18 (TO 0x2a3c)
00002f24  00001001  ENT   0x10 (D 16)
00002f28  00000086  BNZ   <fwd>
00002f2c  ffffff23  LI    0xffffffff (D -1)
00002f30  00001002  LEV   0x10 (D 16)
os.c  1168:   switch (f->type) {
00002f34  0000000e  LL    0x0 (D 0)
00002f38  0000001c  LX  
00002f3c  00000003  JMP   <fwd>
os.c  1169:   case FD_PIPE: return piperead(f->pipe, addr, n);
00002f40  0000280e  LL    0x28 (D 40)
00002f44  0000009d  PSHA
00002f48  0000280e  LL    0x28 (D 40)
00002f4c  0000009d  PSHA
00002f50  0000100e  LL    0x10 (D 16)
00002f54  00000c1c  LX    0xc (D 12)
00002f58  0000009d  PSHA
00002f5c  fff58c05  JSR   0xfffff58c (TO 0x24ec)
00002f60  00001801  ENT   0x18 (D 24)
00002f64  00001002  LEV   0x10 (D 16)
os.c  1170:   case FD_SOCKET:
os.c  1171:     while (!sockpoll(f->off)) ssleep(1); // XXX needs to block properly XXX should I lock the inode? (right now there isn't an inode!)
00002f68  00000003  JMP   <fwd>
00002f6c  0000019e  PSHI  0x1 (D 1)
00002f70  002ba005  JSR   <fwd>
00002f74  00000801  ENT   0x8 (D 8)
os.c  1172:     return sockread(f->off, addr, n);
00002f78  0000000e  LL    0x0 (D 0)
00002f7c  0000141c  LX    0x14 (D 20)
00002f80  0000009d  PSHA
00002f84  fffb8c05  JSR   0xfffffb8c (TO 0x2b14)
00002f88  00000801  ENT   0x8 (D 8)
00002f8c  00000084  BZ    <fwd>
00002f90  0000280e  LL    0x28 (D 40)
00002f94  0000009d  PSHA
00002f98  0000280e  LL    0x28 (D 40)
00002f9c  0000009d  PSHA
00002fa0  0000100e  LL    0x10 (D 16)
00002fa4  0000141c  LX    0x14 (D 20)
00002fa8  0000009d  PSHA
00002fac  fffb3c05  JSR   0xfffffb3c (TO 0x2aec)
00002fb0  00001801  ENT   0x18 (D 24)
00002fb4  00001002  LEV   0x10 (D 16)
os.c  1173:   case FD_INODE:
os.c  1174:     ilock(f->ip);
00002fb8  0000000e  LL    0x0 (D 0)
00002fbc  0000101c  LX    0x10 (D 16)
00002fc0  0000009d  PSHA
00002fc4  ffe1e005  JSR   0xffffe1e0 (TO 0x11a8)
00002fc8  00000801  ENT   0x8 (D 8)
os.c  1175:     if ((r = readi(f->ip, addr, f->off, n)) > 0) f->off += r;
00002fcc  0000280e  LL    0x28 (D 40)
00002fd0  0000009d  PSHA
00002fd4  0000080e  LL    0x8 (D 8)
00002fd8  0000141c  LX    0x14 (D 20)
00002fdc  0000009d  PSHA
00002fe0  0000300e  LL    0x30 (D 48)
00002fe4  0000009d  PSHA
00002fe8  0000180e  LL    0x18 (D 24)
00002fec  0000101c  LX    0x10 (D 16)
00002ff0  0000009d  PSHA
00002ff4  ffe91005  JSR   0xffffe910 (TO 0x1908)
00002ff8  00002001  ENT   0x20 (D 32)
00002ffc  00000c40  SL    0xc (D 12)
00003000  0000003e  LBA 
00003004  00000023  LI    0x0 (D 0)
00003008  0000008f  BGE   <fwd>
0000300c  0000000e  LL    0x0 (D 0)
00003010  00001454  ADDI  0x14 (D 20)
00003014  0000003e  LBA 
00003018  0000001c  LX  
0000301c  00000c55  ADDL  0xc (D 12)
00003020  0000004a  SX  
os.c  1176:     iunlock(f->ip);
00003024  0000000e  LL    0x0 (D 0)
00003028  0000101c  LX    0x10 (D 16)
0000302c  0000009d  PSHA
00003030  ffe30c05  JSR   0xffffe30c (TO 0x1340)
00003034  00000801  ENT   0x8 (D 8)
os.c  1177:     return r;
00003038  00000c0e  LL    0xc (D 12)
0000303c  00001002  LEV   0x10 (D 16)
os.c  1178:   case FD_RFS:
os.c  1179:     h[0] = M_READ; // XXX lock the inode
00003040  00000223  LI    0x2 (D 2)
00003044  00000440  SL    0x4 (D 4)
os.c  1180:     h[1] = n;
00003048  0000280e  LL    0x28 (D 40)
0000304c  00000840  SL    0x8 (D 8)
os.c  1181:     if (socktx(f->off, h, 8) || sockrx(f->off, &r, 4) || ((uint)r <= n && sockrx(f->off, addr, r))) return -1; // XXX need to zortch the file  is this correct for zero?
00003050  0000089e  PSHI  0x8 (D 8)
00003054  00000c07  LEA   0xc (D 12)
00003058  0000009d  PSHA
0000305c  0000100e  LL    0x10 (D 16)
00003060  0000141c  LX    0x14 (D 20)
00003064  0000009d  PSHA
00003068  fffab405  JSR   0xfffffab4 (TO 0x2b20)
0000306c  00001801  ENT   0x18 (D 24)
00003070  00000086  BNZ   <fwd>
00003074  0000049e  PSHI  0x4 (D 4)
00003078  00001407  LEA   0x14 (D 20)
0000307c  0000009d  PSHA
00003080  0000100e  LL    0x10 (D 16)
00003084  0000141c  LX    0x14 (D 20)
00003088  0000009d  PSHA
0000308c  fffb0005  JSR   0xfffffb00 (TO 0x2b90)
00003090  00001801  ENT   0x18 (D 24)
00003094  00307086  BNZ   <fwd>
00003098  0000280e  LL    0x28 (D 40)
0000309c  00000c26  LBL   0xc (D 12)
000030a0  0000008d  BLTU  <fwd>
000030a4  00000c0e  LL    0xc (D 12)
000030a8  0000009d  PSHA
000030ac  0000280e  LL    0x28 (D 40)
000030b0  0000009d  PSHA
000030b4  0000100e  LL    0x10 (D 16)
000030b8  0000141c  LX    0x14 (D 20)
000030bc  0000009d  PSHA
000030c0  fffacc05  JSR   0xfffffacc (TO 0x2b90)
000030c4  00001801  ENT   0x18 (D 24)
000030c8  0030a084  BZ    <fwd>
000030cc  ffffff23  LI    0xffffffff (D -1)
000030d0  00001002  LEV   0x10 (D 16)
os.c  1182:     return r;
000030d4  00000c0e  LL    0xc (D 12)
000030d8  00001002  LEV   0x10 (D 16)
os.c  1183:   }
os.c  1184:   panic("read");
000030dc  00000003  JMP   <fwd>
000030e0  0000053b  LBI   0x5 (D 5)
000030e4  0030dc90  BGEU  <fwd>
000030e8  00020804  JMPI  0x208 (D 520)
000030ec  00021c08  LEAG  0x21c (D 540)
000030f0  0000009d  PSHA
000030f4  ffd43c05  JSR   0xffffd43c (TO 0x534)
000030f8  00000801  ENT   0x8 (D 8)
os.c  1185: }
os.c  1186: int write(int fd, char *addr, int n)
000030fc  00001002  LEV   0x10 (D 16)
os.c  1187: {
os.c  1188:   int r, h[2]; struct file *f;
os.c  1189:   if (!(f = getf(fd)) || !f->writable || !mvalid(addr, n)) return -1;
00003100  fffff001  ENT   0xfffffff0 (D -16)
00003104  0000180e  LL    0x18 (D 24)
00003108  0000009d  PSHA
0000310c  fff96c05  JSR   0xfffff96c (TO 0x2a7c)
00003110  00000801  ENT   0x8 (D 8)
00003114  00000040  SL    0x0 (D 0)
00003118  00000084  BZ    <fwd>
0000311c  0000000e  LL    0x0 (D 0)
00003120  0000091f  LXC   0x9 (D 9)
00003124  00311884  BZ    <fwd>
00003128  0000280e  LL    0x28 (D 40)
0000312c  0000009d  PSHA
00003130  0000280e  LL    0x28 (D 40)
00003134  0000009d  PSHA
00003138  fff90005  JSR   0xfffff900 (TO 0x2a3c)
0000313c  00001001  ENT   0x10 (D 16)
00003140  00000086  BNZ   <fwd>
00003144  ffffff23  LI    0xffffffff (D -1)
00003148  00001002  LEV   0x10 (D 16)
os.c  1190:   switch (f->type) {
0000314c  0000000e  LL    0x0 (D 0)
00003150  0000001c  LX  
00003154  00000003  JMP   <fwd>
os.c  1191:   case FD_PIPE: return pipewrite(f->pipe, addr, n);
00003158  0000280e  LL    0x28 (D 40)
0000315c  0000009d  PSHA
00003160  0000280e  LL    0x28 (D 40)
00003164  0000009d  PSHA
00003168  0000100e  LL    0x10 (D 16)
0000316c  00000c1c  LX    0xc (D 12)
00003170  0000009d  PSHA
00003174  fff25c05  JSR   0xfffff25c (TO 0x23d4)
00003178  00001801  ENT   0x18 (D 24)
0000317c  00001002  LEV   0x10 (D 16)
os.c  1192:   case FD_SOCKET: return sockwrite(f->off, addr, n); // XXX needs to block
00003180  0000280e  LL    0x28 (D 40)
00003184  0000009d  PSHA
00003188  0000280e  LL    0x28 (D 40)
0000318c  0000009d  PSHA
00003190  0000100e  LL    0x10 (D 16)
00003194  0000141c  LX    0x14 (D 20)
00003198  0000009d  PSHA
0000319c  fff96005  JSR   0xfffff960 (TO 0x2b00)
000031a0  00001801  ENT   0x18 (D 24)
000031a4  00001002  LEV   0x10 (D 16)
os.c  1193:   case FD_INODE:
os.c  1194:     ilock(f->ip);
000031a8  0000000e  LL    0x0 (D 0)
000031ac  0000101c  LX    0x10 (D 16)
000031b0  0000009d  PSHA
000031b4  ffdff005  JSR   0xffffdff0 (TO 0x11a8)
000031b8  00000801  ENT   0x8 (D 8)
os.c  1195:     if ((r = writei(f->ip, addr, f->off, n)) > 0) f->off += r;
000031bc  0000280e  LL    0x28 (D 40)
000031c0  0000009d  PSHA
000031c4  0000080e  LL    0x8 (D 8)
000031c8  0000141c  LX    0x14 (D 20)
000031cc  0000009d  PSHA
000031d0  0000300e  LL    0x30 (D 48)
000031d4  0000009d  PSHA
000031d8  0000180e  LL    0x18 (D 24)
000031dc  0000101c  LX    0x10 (D 16)
000031e0  0000009d  PSHA
000031e4  ffe8f005  JSR   0xffffe8f0 (TO 0x1ad8)
000031e8  00002001  ENT   0x20 (D 32)
000031ec  00000c40  SL    0xc (D 12)
000031f0  0000003e  LBA 
000031f4  00000023  LI    0x0 (D 0)
000031f8  0000008f  BGE   <fwd>
000031fc  0000000e  LL    0x0 (D 0)
00003200  00001454  ADDI  0x14 (D 20)
00003204  0000003e  LBA 
00003208  0000001c  LX  
0000320c  00000c55  ADDL  0xc (D 12)
00003210  0000004a  SX  
os.c  1196:     iunlock(f->ip);
00003214  0000000e  LL    0x0 (D 0)
00003218  0000101c  LX    0x10 (D 16)
0000321c  0000009d  PSHA
00003220  ffe11c05  JSR   0xffffe11c (TO 0x1340)
00003224  00000801  ENT   0x8 (D 8)
os.c  1197:     return r;
00003228  00000c0e  LL    0xc (D 12)
0000322c  00001002  LEV   0x10 (D 16)
os.c  1198:   case FD_RFS:
os.c  1199:     h[0] = M_WRITE; // XXX lock the inode
00003230  00000323  LI    0x3 (D 3)
00003234  00000440  SL    0x4 (D 4)
os.c  1200:     h[1] = n;
00003238  0000280e  LL    0x28 (D 40)
0000323c  00000840  SL    0x8 (D 8)
os.c  1201:     if (socktx(f->off, h, 8) || (n > 0 && socktx(f->off, addr, n))) return -1; // XXX need to zortch the file
00003240  0000089e  PSHI  0x8 (D 8)
00003244  00000c07  LEA   0xc (D 12)
00003248  0000009d  PSHA
0000324c  0000100e  LL    0x10 (D 16)
00003250  0000141c  LX    0x14 (D 20)
00003254  0000009d  PSHA
00003258  fff8c405  JSR   0xfffff8c4 (TO 0x2b20)
0000325c  00001801  ENT   0x18 (D 24)
00003260  00000086  BNZ   <fwd>
00003264  00000023  LI    0x0 (D 0)
00003268  00002826  LBL   0x28 (D 40)
0000326c  0000008f  BGE   <fwd>
00003270  0000280e  LL    0x28 (D 40)
00003274  0000009d  PSHA
00003278  0000280e  LL    0x28 (D 40)
0000327c  0000009d  PSHA
00003280  0000100e  LL    0x10 (D 16)
00003284  0000141c  LX    0x14 (D 20)
00003288  0000009d  PSHA
0000328c  fff89005  JSR   0xfffff890 (TO 0x2b20)
00003290  00001801  ENT   0x18 (D 24)
00003294  00326c84  BZ    <fwd>
00003298  ffffff23  LI    0xffffffff (D -1)
0000329c  00001002  LEV   0x10 (D 16)
os.c  1202:     return n;
000032a0  0000280e  LL    0x28 (D 40)
000032a4  00001002  LEV   0x10 (D 16)
os.c  1203:   }
os.c  1204:   panic("write");
000032a8  00000003  JMP   <fwd>
000032ac  0000053b  LBI   0x5 (D 5)
000032b0  0032a890  BGEU  <fwd>
000032b4  00022404  JMPI  0x224 (D 548)
000032b8  00023808  LEAG  0x238 (D 568)
000032bc  0000009d  PSHA
000032c0  ffd27005  JSR   0xffffd270 (TO 0x534)
000032c4  00000801  ENT   0x8 (D 8)
os.c  1205: }
os.c  1206: 
os.c  1207: int lseek(int fd, int offset, uint whence)
000032c8  00001002  LEV   0x10 (D 16)
os.c  1208: {
os.c  1209:   int r, h[3]; struct file *f;
os.c  1210:   if (!(f = getf(fd)) || whence > SEEK_END) return -1;
000032cc  ffffe801  ENT   0xffffffe8 (D -24)
000032d0  0000200e  LL    0x20 (D 32)
000032d4  0000009d  PSHA
000032d8  fff7a005  JSR   0xfffff7a0 (TO 0x2a7c)
000032dc  00000801  ENT   0x8 (D 8)
000032e0  00000440  SL    0x4 (D 4)
000032e4  00000084  BZ    <fwd>
000032e8  00000223  LI    0x2 (D 2)
000032ec  00003026  LBL   0x30 (D 48)
000032f0  00000090  BGEU  <fwd>
000032f4  ffffff23  LI    0xffffffff (D -1)
000032f8  00001802  LEV   0x18 (D 24)
os.c  1211:   switch (f->type) {
000032fc  0000040e  LL    0x4 (D 4)
00003300  0000001c  LX  
00003304  00000003  JMP   <fwd>
os.c  1212:   case FD_INODE:
os.c  1213:     ilock(f->ip);
00003308  0000040e  LL    0x4 (D 4)
0000330c  0000101c  LX    0x10 (D 16)
00003310  0000009d  PSHA
00003314  ffde9005  JSR   0xffffde90 (TO 0x11a8)
00003318  00000801  ENT   0x8 (D 8)
os.c  1214:     switch (whence) {
0000331c  0000300e  LL    0x30 (D 48)
00003320  00000003  JMP   <fwd>
os.c  1215:     case SEEK_SET: r = f->off = offset; break;
00003324  0000040e  LL    0x4 (D 4)
00003328  00001454  ADDI  0x14 (D 20)
0000332c  0000003e  LBA 
00003330  0000280e  LL    0x28 (D 40)
00003334  0000004a  SX  
00003338  00001440  SL    0x14 (D 20)
0000333c  00000003  JMP   <fwd>
os.c  1216:     case SEEK_CUR: r = f->off += offset; break;
00003340  0000040e  LL    0x4 (D 4)
00003344  00001454  ADDI  0x14 (D 20)
00003348  0000003e  LBA 
0000334c  0000001c  LX  
00003350  00002855  ADDL  0x28 (D 40)
00003354  0000004a  SX  
00003358  00001440  SL    0x14 (D 20)
0000335c  00333c03  JMP   <fwd>
os.c  1217:     case SEEK_END: r = f->off = f->ip->size - offset; break; // XXX verify
00003360  0000040e  LL    0x4 (D 4)
00003364  00001454  ADDI  0x14 (D 20)
00003368  0000009d  PSHA
0000336c  00000c0e  LL    0xc (D 12)
00003370  0000101c  LX    0x10 (D 16)
00003374  0000141c  LX    0x14 (D 20)
00003378  00003058  SUBL  0x30 (D 48)
0000337c  000000a1  POPB
00003380  0000004a  SX  
00003384  00001440  SL    0x14 (D 20)
00003388  00335c03  JMP   <fwd>
os.c  1218:     }
os.c  1219:     iunlock(f->ip);
0000338c  00338803  JMP   <fwd>
00003390  0000033b  LBI   0x3 (D 3)
00003394  00338c90  BGEU  <fwd>
00003398  00024004  JMPI  0x240 (D 576)
0000339c  0000040e  LL    0x4 (D 4)
000033a0  0000101c  LX    0x10 (D 16)
000033a4  0000009d  PSHA
000033a8  ffdf9405  JSR   0xffffdf94 (TO 0x1340)
000033ac  00000801  ENT   0x8 (D 8)
os.c  1220:     return r;
000033b0  0000140e  LL    0x14 (D 20)
000033b4  00001802  LEV   0x18 (D 24)
os.c  1221:   case FD_RFS:
os.c  1222:     h[0] = M_SEEK;
000033b8  00000423  LI    0x4 (D 4)
000033bc  00000840  SL    0x8 (D 8)
os.c  1223:     h[1] = offset;
000033c0  0000280e  LL    0x28 (D 40)
000033c4  00000c40  SL    0xc (D 12)
os.c  1224:     h[2] = whence;
000033c8  0000300e  LL    0x30 (D 48)
000033cc  00001040  SL    0x10 (D 16)
os.c  1225:     if (socktx(f->off, h, 12) || sockrx(f->off, &r, 4)) return -1;
000033d0  00000c9e  PSHI  0xc (D 12)
000033d4  00001007  LEA   0x10 (D 16)
000033d8  0000009d  PSHA
000033dc  0000140e  LL    0x14 (D 20)
000033e0  0000141c  LX    0x14 (D 20)
000033e4  0000009d  PSHA
000033e8  fff73405  JSR   0xfffff734 (TO 0x2b20)
000033ec  00001801  ENT   0x18 (D 24)
000033f0  00000086  BNZ   <fwd>
000033f4  0000049e  PSHI  0x4 (D 4)
000033f8  00001c07  LEA   0x1c (D 28)
000033fc  0000009d  PSHA
00003400  0000140e  LL    0x14 (D 20)
00003404  0000141c  LX    0x14 (D 20)
00003408  0000009d  PSHA
0000340c  fff78005  JSR   0xfffff780 (TO 0x2b90)
00003410  00001801  ENT   0x18 (D 24)
00003414  00000084  BZ    <fwd>
00003418  ffffff23  LI    0xffffffff (D -1)
0000341c  00001802  LEV   0x18 (D 24)
os.c  1226:     return r;
00003420  0000140e  LL    0x14 (D 20)
00003424  00001802  LEV   0x18 (D 24)
os.c  1227:   }
os.c  1228:   return -1;
00003428  00000003  JMP   <fwd>
0000342c  0000053b  LBI   0x5 (D 5)
00003430  00342890  BGEU  <fwd>
00003434  00024c04  JMPI  0x24c (D 588)
00003438  ffffff23  LI    0xffffffff (D -1)
0000343c  00001802  LEV   0x18 (D 24)
os.c  1229: }
os.c  1230: 
os.c  1231: int dup2(int fd, int d)
00003440  00001802  LEV   0x18 (D 24)
os.c  1232: {
os.c  1233:   struct file *f;
os.c  1234:   if (!(f = getf(fd)) || (uint)d >= NOFILE) return -1;
00003444  fffff801  ENT   0xfffffff8 (D -8)
00003448  0000100e  LL    0x10 (D 16)
0000344c  0000009d  PSHA
00003450  fff62805  JSR   0xfffff628 (TO 0x2a7c)
00003454  00000801  ENT   0x8 (D 8)
00003458  00000440  SL    0x4 (D 4)
0000345c  00000084  BZ    <fwd>
00003460  0000180e  LL    0x18 (D 24)
00003464  0000103b  LBI   0x10 (D 16)
00003468  0000008d  BLTU  <fwd>
0000346c  ffffff23  LI    0xffffffff (D -1)
00003470  00000802  LEV   0x8 (D 8)
os.c  1235:   close(d);
00003474  0000180e  LL    0x18 (D 24)
00003478  0000009d  PSHA
0000347c  fff8c005  JSR   0xfffff8c0 (TO 0x2d40)
00003480  00000801  ENT   0x8 (D 8)
os.c  1236:   u->ofile[d] = filedup(f);
00003484  00210015  LG    0x2100 (D 8448)
00003488  00003054  ADDI  0x30 (D 48)
0000348c  0000009d  PSHA
00003490  0000200e  LL    0x20 (D 32)
00003494  0000045a  MULI  0x4 (D 4)
00003498  000000a1  POPB
0000349c  00000053  ADD 
000034a0  0000009d  PSHA
000034a4  00000c0e  LL    0xc (D 12)
000034a8  0000009d  PSHA
000034ac  fff1e405  JSR   0xfffff1e4 (TO 0x2694)
000034b0  00000801  ENT   0x8 (D 8)
000034b4  000000a1  POPB
000034b8  0000004a  SX  
os.c  1237:   return d;
000034bc  0000180e  LL    0x18 (D 24)
000034c0  00000802  LEV   0x8 (D 8)
os.c  1238: }
os.c  1239: 
os.c  1240: int link(char *old, char *new)
000034c4  00000802  LEV   0x8 (D 8)
os.c  1241: {
os.c  1242:   char name[DIRSIZ];
os.c  1243:   struct inode *dp, *ip;
os.c  1244: 
os.c  1245:   if (!svalid(old) || !svalid(new) || !(ip = namei(old))) return -1;
000034c8  fffef801  ENT   0xfffffef8 (D -264)
000034cc  0001100e  LL    0x110 (D 272)
000034d0  0000009d  PSHA
000034d4  fff51405  JSR   0xfffff514 (TO 0x29ec)
000034d8  00000801  ENT   0x8 (D 8)
000034dc  00000084  BZ    <fwd>
000034e0  0001180e  LL    0x118 (D 280)
000034e4  0000009d  PSHA
000034e8  fff50005  JSR   0xfffff500 (TO 0x29ec)
000034ec  00000801  ENT   0x8 (D 8)
000034f0  0034dc84  BZ    <fwd>
000034f4  0001100e  LL    0x110 (D 272)
000034f8  0000009d  PSHA
000034fc  ffec1405  JSR   0xffffec14 (TO 0x2114)
00003500  00000801  ENT   0x8 (D 8)
00003504  00000440  SL    0x4 (D 4)
00003508  00000086  BNZ   <fwd>
0000350c  ffffff23  LI    0xffffffff (D -1)
00003510  00010802  LEV   0x108 (D 264)
os.c  1246:   ilock(ip);
00003514  0000040e  LL    0x4 (D 4)
00003518  0000009d  PSHA
0000351c  ffdc8805  JSR   0xffffdc88 (TO 0x11a8)
00003520  00000801  ENT   0x8 (D 8)
os.c  1247:   if ((ip->mode & S_IFMT) == S_IFDIR) {
00003524  0000040e  LL    0x4 (D 4)
00003528  00000c1e  LXH   0xc (D 12)
0000352c  00f00069  ANDI  0xf000 (D 61440)
00003530  0040003b  LBI   0x4000 (D 16384)
00003534  0000008a  BNE   <fwd>
os.c  1248:     iunlockput(ip);
00003538  0000040e  LL    0x4 (D 4)
0000353c  0000009d  PSHA
00003540  ffdf8c05  JSR   0xffffdf8c (TO 0x14d0)
00003544  00000801  ENT   0x8 (D 8)
os.c  1249:     return -1;
00003548  ffffff23  LI    0xffffffff (D -1)
0000354c  00010802  LEV   0x108 (D 264)
os.c  1250:   }
os.c  1251:   ip->nlink++;
00003550  0000040e  LL    0x4 (D 4)
00003554  00001054  ADDI  0x10 (D 16)
00003558  0000003e  LBA 
0000355c  0000001c  LX  
00003560  ffffff57  SUBI  0xffffffff (D -1)
00003564  0000004a  SX  
os.c  1252:   iupdate(ip);
00003568  0000040e  LL    0x4 (D 4)
0000356c  0000009d  PSHA
00003570  ffdb2005  JSR   0xffffdb20 (TO 0x1094)
00003574  00000801  ENT   0x8 (D 8)
os.c  1253:   iunlock(ip);
00003578  0000040e  LL    0x4 (D 4)
0000357c  0000009d  PSHA
00003580  ffddbc05  JSR   0xffffddbc (TO 0x1340)
00003584  00000801  ENT   0x8 (D 8)
os.c  1254: 
os.c  1255:   if (!(dp = nameiparent(new, name))) goto bad;
00003588  00000c07  LEA   0xc (D 12)
0000358c  0000009d  PSHA
00003590  0001200e  LL    0x120 (D 288)
00003594  0000009d  PSHA
00003598  ffec6005  JSR   0xffffec60 (TO 0x21fc)
0000359c  00001001  ENT   0x10 (D 16)
000035a0  00000840  SL    0x8 (D 8)
000035a4  00000086  BNZ   <fwd>
000035a8  00000003  JMP   <fwd>
os.c  1256:   ilock(dp);
000035ac  0000080e  LL    0x8 (D 8)
000035b0  0000009d  PSHA
000035b4  ffdbf005  JSR   0xffffdbf0 (TO 0x11a8)
000035b8  00000801  ENT   0x8 (D 8)
os.c  1257:   if (dirlink(dp, name, ip->inum)) {
000035bc  0000040e  LL    0x4 (D 4)
000035c0  0000001c  LX  
000035c4  0000009d  PSHA
000035c8  00001407  LEA   0x14 (D 20)
000035cc  0000009d  PSHA
000035d0  0000180e  LL    0x18 (D 24)
000035d4  0000009d  PSHA
000035d8  ffe88805  JSR   0xffffe888 (TO 0x1e64)
000035dc  00001801  ENT   0x18 (D 24)
000035e0  00000084  BZ    <fwd>
os.c  1258:     iunlockput(dp);
000035e4  0000080e  LL    0x8 (D 8)
000035e8  0000009d  PSHA
000035ec  ffdee005  JSR   0xffffdee0 (TO 0x14d0)
000035f0  00000801  ENT   0x8 (D 8)
os.c  1259: bad:
os.c  1260:     ilock(ip);
000035f4  0000040e  LL    0x4 (D 4)
000035f8  0000009d  PSHA
000035fc  ffdba805  JSR   0xffffdba8 (TO 0x11a8)
00003600  00000801  ENT   0x8 (D 8)
os.c  1261:     ip->nlink--;
00003604  0000040e  LL    0x4 (D 4)
00003608  00001054  ADDI  0x10 (D 16)
0000360c  0000003e  LBA 
00003610  0000001c  LX  
00003614  00000157  SUBI  0x1 (D 1)
00003618  0000004a  SX  
os.c  1262:     iupdate(ip);
0000361c  0000040e  LL    0x4 (D 4)
00003620  0000009d  PSHA
00003624  ffda6c05  JSR   0xffffda6c (TO 0x1094)
00003628  00000801  ENT   0x8 (D 8)
os.c  1263:     iunlockput(ip);
0000362c  0000040e  LL    0x4 (D 4)
00003630  0000009d  PSHA
00003634  ffde9805  JSR   0xffffde98 (TO 0x14d0)
00003638  00000801  ENT   0x8 (D 8)
os.c  1264:     return -1;
0000363c  ffffff23  LI    0xffffffff (D -1)
00003640  00010802  LEV   0x108 (D 264)
os.c  1265:   }
os.c  1266:   iunlockput(dp);
00003644  0000080e  LL    0x8 (D 8)
00003648  0000009d  PSHA
0000364c  ffde8005  JSR   0xffffde80 (TO 0x14d0)
00003650  00000801  ENT   0x8 (D 8)
os.c  1267:   iput(ip);
00003654  0000040e  LL    0x4 (D 4)
00003658  0000009d  PSHA
0000365c  ffdd6005  JSR   0xffffdd60 (TO 0x13c0)
00003660  00000801  ENT   0x8 (D 8)
os.c  1268:   return 0;
00003664  00000023  LI    0x0 (D 0)
00003668  00010802  LEV   0x108 (D 264)
os.c  1269: }
os.c  1270: 
os.c  1271: int unlink(char *path)
0000366c  00010802  LEV   0x108 (D 264)
os.c  1272: {
os.c  1273:   struct inode *ip, *dp;
os.c  1274:   struct direct de;
os.c  1275:   char name[DIRSIZ];
os.c  1276:   uint off;
os.c  1277:   
os.c  1278:   if (!svalid(path) || !(dp = nameiparent(path, name))) return -1;
00003670  fffdf801  ENT   0xfffffdf8 (D -520)
00003674  0002100e  LL    0x210 (D 528)
00003678  0000009d  PSHA
0000367c  fff36c05  JSR   0xfffff36c (TO 0x29ec)
00003680  00000801  ENT   0x8 (D 8)
00003684  00000084  BZ    <fwd>
00003688  00000407  LEA   0x4 (D 4)
0000368c  0000009d  PSHA
00003690  0002180e  LL    0x218 (D 536)
00003694  0000009d  PSHA
00003698  ffeb6005  JSR   0xffffeb60 (TO 0x21fc)
0000369c  00001001  ENT   0x10 (D 16)
000036a0  00020040  SL    0x200 (D 512)
000036a4  00000086  BNZ   <fwd>
000036a8  ffffff23  LI    0xffffffff (D -1)
000036ac  00020802  LEV   0x208 (D 520)
os.c  1279:   ilock(dp);
000036b0  0002000e  LL    0x200 (D 512)
000036b4  0000009d  PSHA
000036b8  ffdaec05  JSR   0xffffdaec (TO 0x11a8)
000036bc  00000801  ENT   0x8 (D 8)
os.c  1280: 
os.c  1281:   // Cannot unlink "." or "..".
os.c  1282:   if (!namecmp(name, ".") || !namecmp(name, "..") || !(ip = dirlookup(dp, name, &off))) goto bad;
000036c0  00026008  LEAG  0x260 (D 608)
000036c4  0000009d  PSHA
000036c8  00000c07  LEA   0xc (D 12)
000036cc  0000009d  PSHA
000036d0  ffe61805  JSR   0xffffe618 (TO 0x1cec)
000036d4  00001001  ENT   0x10 (D 16)
000036d8  00000084  BZ    <fwd>
000036dc  00026208  LEAG  0x262 (D 610)
000036e0  0000009d  PSHA
000036e4  00000c07  LEA   0xc (D 12)
000036e8  0000009d  PSHA
000036ec  ffe5fc05  JSR   0xffffe5fc (TO 0x1cec)
000036f0  00001001  ENT   0x10 (D 16)
000036f4  0036d884  BZ    <fwd>
000036f8  00000007  LEA   0x0 (D 0)
000036fc  0000009d  PSHA
00003700  00000c07  LEA   0xc (D 12)
00003704  0000009d  PSHA
00003708  0002100e  LL    0x210 (D 528)
0000370c  0000009d  PSHA
00003710  ffe66805  JSR   0xffffe668 (TO 0x1d7c)
00003714  00001801  ENT   0x18 (D 24)
00003718  00020440  SL    0x204 (D 516)
0000371c  00000086  BNZ   <fwd>
00003720  00000003  JMP   <fwd>
os.c  1283:   ilock(ip);
00003724  0002040e  LL    0x204 (D 516)
00003728  0000009d  PSHA
0000372c  ffda7805  JSR   0xffffda78 (TO 0x11a8)
00003730  00000801  ENT   0x8 (D 8)
os.c  1284:   if (!ip->nlink) panic("unlink: nlink == 0");
00003734  0002040e  LL    0x204 (D 516)
00003738  0000101c  LX    0x10 (D 16)
0000373c  00000086  BNZ   <fwd>
00003740  00026508  LEAG  0x265 (D 613)
00003744  0000009d  PSHA
00003748  ffcde805  JSR   0xffffcde8 (TO 0x534)
0000374c  00000801  ENT   0x8 (D 8)
os.c  1285:   if ((ip->mode & S_IFMT) == S_IFDIR && !isdirempty(ip)) {
00003750  0002040e  LL    0x204 (D 516)
00003754  00000c1e  LXH   0xc (D 12)
00003758  00f00069  ANDI  0xf000 (D 61440)
0000375c  0040003b  LBI   0x4000 (D 16384)
00003760  0000008a  BNE   <fwd>
00003764  0002040e  LL    0x204 (D 516)
00003768  0000009d  PSHA
0000376c  ffe81405  JSR   0xffffe814 (TO 0x1f84)
00003770  00000801  ENT   0x8 (D 8)
00003774  00376086  BNZ   <fwd>
os.c  1286:     iunlockput(ip);
00003778  0002040e  LL    0x204 (D 516)
0000377c  0000009d  PSHA
00003780  ffdd4c05  JSR   0xffffdd4c (TO 0x14d0)
00003784  00000801  ENT   0x8 (D 8)
os.c  1287: bad:
os.c  1288:     iunlockput(dp);
00003788  0002000e  LL    0x200 (D 512)
0000378c  0000009d  PSHA
00003790  ffdd3c05  JSR   0xffffdd3c (TO 0x14d0)
00003794  00000801  ENT   0x8 (D 8)
os.c  1289:     return -1;
00003798  ffffff23  LI    0xffffffff (D -1)
0000379c  00020802  LEV   0x208 (D 520)
os.c  1290:   }
os.c  1291: 
os.c  1292:   memset(&de, 0, sizeof(de));
000037a0  0001009e  PSHI  0x100 (D 256)
000037a4  0000009e  PSHI  0x0 (D 0)
000037a8  00011007  LEA   0x110 (D 272)
000037ac  0000009d  PSHA
000037b0  ffc86405  JSR   0xffffc864 (TO 0x18)
000037b4  00001801  ENT   0x18 (D 24)
os.c  1293:   if (writei(dp, (char *)&de, off, sizeof(de)) != sizeof(de)) panic("unlink: writei");
000037b8  0001009e  PSHI  0x100 (D 256)
000037bc  0000080e  LL    0x8 (D 8)
000037c0  0000009d  PSHA
000037c4  00011007  LEA   0x110 (D 272)
000037c8  0000009d  PSHA
000037cc  0002180e  LL    0x218 (D 536)
000037d0  0000009d  PSHA
000037d4  ffe30005  JSR   0xffffe300 (TO 0x1ad8)
000037d8  00002001  ENT   0x20 (D 32)
000037dc  0001003b  LBI   0x100 (D 256)
000037e0  00000088  BE    <fwd>
000037e4  00027808  LEAG  0x278 (D 632)
000037e8  0000009d  PSHA
000037ec  ffcd4405  JSR   0xffffcd44 (TO 0x534)
000037f0  00000801  ENT   0x8 (D 8)
os.c  1294:   if ((ip->mode & S_IFMT) == S_IFDIR) {
000037f4  0002040e  LL    0x204 (D 516)
000037f8  00000c1e  LXH   0xc (D 12)
000037fc  00f00069  ANDI  0xf000 (D 61440)
00003800  0040003b  LBI   0x4000 (D 16384)
00003804  0000008a  BNE   <fwd>
os.c  1295:     dp->nlink--;
00003808  0002000e  LL    0x200 (D 512)
0000380c  00001054  ADDI  0x10 (D 16)
00003810  0000003e  LBA 
00003814  0000001c  LX  
00003818  00000157  SUBI  0x1 (D 1)
0000381c  0000004a  SX  
os.c  1296:     iupdate(dp);
00003820  0002000e  LL    0x200 (D 512)
00003824  0000009d  PSHA
00003828  ffd86805  JSR   0xffffd868 (TO 0x1094)
0000382c  00000801  ENT   0x8 (D 8)
os.c  1297:   }
os.c  1298:   
os.c  1299:   iunlockput(dp);
00003830  0002000e  LL    0x200 (D 512)
00003834  0000009d  PSHA
00003838  ffdc9405  JSR   0xffffdc94 (TO 0x14d0)
0000383c  00000801  ENT   0x8 (D 8)
os.c  1300: 
os.c  1301:   ip->nlink--;
00003840  0002040e  LL    0x204 (D 516)
00003844  00001054  ADDI  0x10 (D 16)
00003848  0000003e  LBA 
0000384c  0000001c  LX  
00003850  00000157  SUBI  0x1 (D 1)
00003854  0000004a  SX  
os.c  1302:   iupdate(ip);
00003858  0002040e  LL    0x204 (D 516)
0000385c  0000009d  PSHA
00003860  ffd83005  JSR   0xffffd830 (TO 0x1094)
00003864  00000801  ENT   0x8 (D 8)
os.c  1303:   iunlockput(ip);
00003868  0002040e  LL    0x204 (D 516)
0000386c  0000009d  PSHA
00003870  ffdc5c05  JSR   0xffffdc5c (TO 0x14d0)
00003874  00000801  ENT   0x8 (D 8)
os.c  1304:   return 0;
00003878  00000023  LI    0x0 (D 0)
0000387c  00020802  LEV   0x208 (D 520)
os.c  1305: }
os.c  1306: 
os.c  1307: uint htonl(uint a) { return (a >> 24) | ((a >> 8) & 0xff00) | ((a << 8) & 0xff0000) | (a << 24); } // XXX eliminate
00003880  00020802  LEV   0x208 (D 520)
00003884  0000080e  LL    0x8 (D 8)
00003888  00001878  SRUI  0x18 (D 24)
0000388c  0000009d  PSHA
00003890  0000100e  LL    0x10 (D 16)
00003894  00000878  SRUI  0x8 (D 8)
00003898  00ff0069  ANDI  0xff00 (D 65280)
0000389c  000000a1  POPB
000038a0  0000006b  OR  
000038a4  0000009d  PSHA
000038a8  0000100e  LL    0x10 (D 16)
000038ac  00000872  SHLI  0x8 (D 8)
000038b0  0000003b  LBI   0x0 (D 0)
000038b4  ff00003c  LBHI  0xffff0000 (D -65536)
000038b8  00000068  AND 
000038bc  000000a1  POPB
000038c0  0000006b  OR  
000038c4  0000009d  PSHA
000038c8  0000100e  LL    0x10 (D 16)
000038cc  00001872  SHLI  0x18 (D 24)
000038d0  000000a1  POPB
000038d4  0000006b  OR  
000038d8  00000002  LEV   0x0 (D 0)
os.c  1308: ushort htons(ushort a) { return (a >> 8) | (a << 8); } // XXX eliminate
000038dc  00000002  LEV   0x0 (D 0)
000038e0  00000810  LLH   0x8 (D 8)
000038e4  00000872  SHLI  0x8 (D 8)
000038e8  0000009d  PSHA
000038ec  00001010  LLH   0x10 (D 16)
000038f0  00000875  SHRI  0x8 (D 8)
000038f4  000000a1  POPB
000038f8  0000006b  OR  
000038fc  00ffff69  ANDI  0xffff (D 65535)
00003900  00000002  LEV   0x0 (D 0)
os.c  1309: int memcmp() { asm(LL,8); asm(LBL, 16); asm(LCL,24); asm(MCMP); } // XXX eliminate
00003904  00000002  LEV   0x0 (D 0)
00003908  0000080e  LL    0x8 (D 8)
0000390c  00001026  LBL   0x10 (D 16)
00003910  000018ac  LCL   0x18 (D 24)
00003914  0000000b  MCMP
os.c  1310: int open(char *path, int oflag) // XXX, int mode)
00003918  00000002  LEV   0x0 (D 0)
os.c  1311: {
os.c  1312:   int fd, r; int h[4];
os.c  1313:   struct file *f;
os.c  1314:   struct inode *ip;
os.c  1315: 
os.c  1316:   if (!svalid(path)) return -1;
0000391c  ffffe001  ENT   0xffffffe0 (D -32)
00003920  0000280e  LL    0x28 (D 40)
00003924  0000009d  PSHA
00003928  fff0c005  JSR   0xfffff0c0 (TO 0x29ec)
0000392c  00000801  ENT   0x8 (D 8)
00003930  00000086  BNZ   <fwd>
00003934  ffffff23  LI    0xffffffff (D -1)
00003938  00002002  LEV   0x20 (D 32)
os.c  1317: //  if (!namecmp(path, "rfs.txt")) {
os.c  1318:   if (!memcmp(path,"rfs/",4)) {
0000393c  0000049e  PSHI  0x4 (D 4)
00003940  00028708  LEAG  0x287 (D 647)
00003944  0000009d  PSHA
00003948  0000380e  LL    0x38 (D 56)
0000394c  0000009d  PSHA
00003950  ffffb405  JSR   0xffffffb4 (TO 0x3908)
00003954  00001801  ENT   0x18 (D 24)
00003958  00000086  BNZ   <fwd>
os.c  1319:     path += 4;
0000395c  0000280e  LL    0x28 (D 40)
00003960  00000454  ADDI  0x4 (D 4)
00003964  00002840  SL    0x28 (D 40)
os.c  1320:     if ((fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) return -1; // XXX reuse?
00003968  0000009e  PSHI  0x0 (D 0)
0000396c  0000019e  PSHI  0x1 (D 1)
00003970  0000029e  PSHI  0x2 (D 2)
00003974  00000005  JSR   <fwd>
00003978  00001801  ENT   0x18 (D 24)
0000397c  00001c40  SL    0x1c (D 28)
00003980  0000003b  LBI   0x0 (D 0)
00003984  0000008f  BGE   <fwd>
00003988  ffffff23  LI    0xffffffff (D -1)
0000398c  00002002  LEV   0x20 (D 32)
os.c  1321:     f = getf(fd);
00003990  00001c0e  LL    0x1c (D 28)
00003994  0000009d  PSHA
00003998  fff0e005  JSR   0xfffff0e0 (TO 0x2a7c)
0000399c  00000801  ENT   0x8 (D 8)
000039a0  00000440  SL    0x4 (D 4)
os.c  1322:     if (sockconnect(f->off, AF_INET | (htons(5003) << 16), htonl(0x7f000001))) return -1; // XXX close?
000039a4  00007f23  LI    0x7f (D 127)
000039a8  00000124  LHI   0x1 (D 1)
000039ac  0000009d  PSHA
000039b0  fffed005  JSR   0xfffffed0 (TO 0x3884)
000039b4  00000801  ENT   0x8 (D 8)
000039b8  0000009d  PSHA
000039bc  00138b9e  PSHI  0x138b (D 5003)
000039c0  ffff1c05  JSR   0xffffff1c (TO 0x38e0)
000039c4  00000801  ENT   0x8 (D 8)
000039c8  00001072  SHLI  0x10 (D 16)
000039cc  0000026c  ORI   0x2 (D 2)
000039d0  0000009d  PSHA
000039d4  0000140e  LL    0x14 (D 20)
000039d8  0000141c  LX    0x14 (D 20)
000039dc  0000009d  PSHA
000039e0  fff0f405  JSR   0xfffff0f4 (TO 0x2ad8)
000039e4  00001801  ENT   0x18 (D 24)
000039e8  00000084  BZ    <fwd>
000039ec  ffffff23  LI    0xffffffff (D -1)
000039f0  00002002  LEV   0x20 (D 32)
os.c  1323:     f->type = FD_RFS;
000039f4  00000423  LI    0x4 (D 4)
000039f8  00000426  LBL   0x4 (D 4)
000039fc  0000004a  SX  
os.c  1324:     h[0] = M_OPEN;
00003a00  00000023  LI    0x0 (D 0)
00003a04  00000840  SL    0x8 (D 8)
os.c  1325:     h[1] = oflag;
00003a08  0000300e  LL    0x30 (D 48)
00003a0c  00000c40  SL    0xc (D 12)
os.c  1326:     h[2] = 0; //mode;
00003a10  00000023  LI    0x0 (D 0)
00003a14  00001040  SL    0x10 (D 16)
os.c  1327:     h[3] = strlen(path) + 1;
00003a18  0000280e  LL    0x28 (D 40)
00003a1c  0000009d  PSHA
00003a20  ffc69405  JSR   0xffffc694 (TO 0xb8)
00003a24  00000801  ENT   0x8 (D 8)
00003a28  00000154  ADDI  0x1 (D 1)
00003a2c  00001440  SL    0x14 (D 20)
os.c  1328:     if (socktx(f->off, h, 16) || socktx(f->off, path, h[3]) || sockrx(f->off, &r, 4) || r < 0) return -1; // XXX sockclose?
00003a30  0000109e  PSHI  0x10 (D 16)
00003a34  00001007  LEA   0x10 (D 16)
00003a38  0000009d  PSHA
00003a3c  0000140e  LL    0x14 (D 20)
00003a40  0000141c  LX    0x14 (D 20)
00003a44  0000009d  PSHA
00003a48  fff0d405  JSR   0xfffff0d4 (TO 0x2b20)
00003a4c  00001801  ENT   0x18 (D 24)
00003a50  00000086  BNZ   <fwd>
00003a54  0000140e  LL    0x14 (D 20)
00003a58  0000009d  PSHA
00003a5c  0000300e  LL    0x30 (D 48)
00003a60  0000009d  PSHA
00003a64  0000140e  LL    0x14 (D 20)
00003a68  0000141c  LX    0x14 (D 20)
00003a6c  0000009d  PSHA
00003a70  fff0ac05  JSR   0xfffff0ac (TO 0x2b20)
00003a74  00001801  ENT   0x18 (D 24)
00003a78  003a5086  BNZ   <fwd>
00003a7c  0000049e  PSHI  0x4 (D 4)
00003a80  00002007  LEA   0x20 (D 32)
00003a84  0000009d  PSHA
00003a88  0000140e  LL    0x14 (D 20)
00003a8c  0000141c  LX    0x14 (D 20)
00003a90  0000009d  PSHA
00003a94  fff0f805  JSR   0xfffff0f8 (TO 0x2b90)
00003a98  00001801  ENT   0x18 (D 24)
00003a9c  003a7886  BNZ   <fwd>
00003aa0  0000180e  LL    0x18 (D 24)
00003aa4  0000003b  LBI   0x0 (D 0)
00003aa8  0000008f  BGE   <fwd>
00003aac  ffffff23  LI    0xffffffff (D -1)
00003ab0  00002002  LEV   0x20 (D 32)
os.c  1329:     return fd;
00003ab4  00001c0e  LL    0x1c (D 28)
00003ab8  00002002  LEV   0x20 (D 32)
os.c  1330:   } else if (oflag & O_CREAT) {
00003abc  00000003  JMP   <fwd>
00003ac0  0000300e  LL    0x30 (D 48)
00003ac4  00010069  ANDI  0x100 (D 256)
00003ac8  00000084  BZ    <fwd>
os.c  1331:     if (!(ip = create(path, S_IFREG, 0))) return -1;
00003acc  0000009e  PSHI  0x0 (D 0)
00003ad0  0080009e  PSHI  0x8000 (D 32768)
00003ad4  0000380e  LL    0x38 (D 56)
00003ad8  0000009d  PSHA
00003adc  ffec9c05  JSR   0xffffec9c (TO 0x277c)
00003ae0  00001801  ENT   0x18 (D 24)
00003ae4  00000040  SL    0x0 (D 0)
00003ae8  00000086  BNZ   <fwd>
00003aec  ffffff23  LI    0xffffffff (D -1)
00003af0  00002002  LEV   0x20 (D 32)
os.c  1332:   } else {
00003af4  00000003  JMP   <fwd>
os.c  1333:     if (!(ip = namei(path))) return -1;
00003af8  0000280e  LL    0x28 (D 40)
00003afc  0000009d  PSHA
00003b00  ffe61005  JSR   0xffffe610 (TO 0x2114)
00003b04  00000801  ENT   0x8 (D 8)
00003b08  00000040  SL    0x0 (D 0)
00003b0c  00000086  BNZ   <fwd>
00003b10  ffffff23  LI    0xffffffff (D -1)
00003b14  00002002  LEV   0x20 (D 32)
os.c  1334:     ilock(ip);
00003b18  0000000e  LL    0x0 (D 0)
00003b1c  0000009d  PSHA
00003b20  ffd68405  JSR   0xffffd684 (TO 0x11a8)
00003b24  00000801  ENT   0x8 (D 8)
os.c  1335:     if ((ip->mode & S_IFMT) == S_IFDIR && oflag != O_RDONLY) {
00003b28  0000000e  LL    0x0 (D 0)
00003b2c  00000c1e  LXH   0xc (D 12)
00003b30  00f00069  ANDI  0xf000 (D 61440)
00003b34  0040003b  LBI   0x4000 (D 16384)
00003b38  0000008a  BNE   <fwd>
00003b3c  0000300e  LL    0x30 (D 48)
00003b40  0000003b  LBI   0x0 (D 0)
00003b44  003b3888  BE    <fwd>
os.c  1336:       iunlockput(ip);
00003b48  0000000e  LL    0x0 (D 0)
00003b4c  0000009d  PSHA
00003b50  ffd97c05  JSR   0xffffd97c (TO 0x14d0)
00003b54  00000801  ENT   0x8 (D 8)
os.c  1337:       return -1;
00003b58  ffffff23  LI    0xffffffff (D -1)
00003b5c  00002002  LEV   0x20 (D 32)
os.c  1338:     }
os.c  1339:   }
os.c  1340: 
os.c  1341:   if (!(f = filealloc()) || (fd = fdalloc(f)) < 0) {
00003b60  ffeaa805  JSR   0xffffeaa8 (TO 0x260c)
00003b64  00000440  SL    0x4 (D 4)
00003b68  00000084  BZ    <fwd>
00003b6c  0000040e  LL    0x4 (D 4)
00003b70  0000009d  PSHA
00003b74  ffeb7c05  JSR   0xffffeb7c (TO 0x26f4)
00003b78  00000801  ENT   0x8 (D 8)
00003b7c  00001c40  SL    0x1c (D 28)
00003b80  0000003b  LBI   0x0 (D 0)
00003b84  0000008f  BGE   <fwd>
os.c  1342:     if (f) fileclose(f);
00003b88  0000040e  LL    0x4 (D 4)
00003b8c  00000084  BZ    <fwd>
00003b90  0000040e  LL    0x4 (D 4)
00003b94  0000009d  PSHA
00003b98  fff09805  JSR   0xfffff098 (TO 0x2c34)
00003b9c  00000801  ENT   0x8 (D 8)
os.c  1343:     iunlockput(ip);
00003ba0  0000000e  LL    0x0 (D 0)
00003ba4  0000009d  PSHA
00003ba8  ffd92405  JSR   0xffffd924 (TO 0x14d0)
00003bac  00000801  ENT   0x8 (D 8)
os.c  1344:     return -1;
00003bb0  ffffff23  LI    0xffffffff (D -1)
00003bb4  00002002  LEV   0x20 (D 32)
os.c  1345:   }
os.c  1346: 
os.c  1347:   if (oflag & O_TRUNC)
00003bb8  0000300e  LL    0x30 (D 48)
00003bbc  00020069  ANDI  0x200 (D 512)
00003bc0  00000084  BZ    <fwd>
os.c  1348:     itrunc(ip);
00003bc4  0000000e  LL    0x0 (D 0)
00003bc8  0000009d  PSHA
00003bcc  ffdaa805  JSR   0xffffdaa8 (TO 0x1678)
00003bd0  00000801  ENT   0x8 (D 8)
os.c  1349: 
os.c  1350:   iunlock(ip);
00003bd4  0000000e  LL    0x0 (D 0)
00003bd8  0000009d  PSHA
00003bdc  ffd76005  JSR   0xffffd760 (TO 0x1340)
00003be0  00000801  ENT   0x8 (D 8)
os.c  1351: 
os.c  1352:   f->type = FD_INODE;
00003be4  00000223  LI    0x2 (D 2)
00003be8  00000426  LBL   0x4 (D 4)
00003bec  0000004a  SX  
os.c  1353:   f->ip = ip;
00003bf0  0000040e  LL    0x4 (D 4)
00003bf4  00001054  ADDI  0x10 (D 16)
00003bf8  0000003e  LBA 
00003bfc  0000000e  LL    0x0 (D 0)
00003c00  0000004a  SX  
os.c  1354:   f->off = 0;
00003c04  0000040e  LL    0x4 (D 4)
00003c08  00001454  ADDI  0x14 (D 20)
00003c0c  0000003e  LBA 
00003c10  00000023  LI    0x0 (D 0)
00003c14  0000004a  SX  
os.c  1355:   f->readable = !(oflag & O_WRONLY);
00003c18  0000040e  LL    0x4 (D 4)
00003c1c  00000854  ADDI  0x8 (D 8)
00003c20  0000009d  PSHA
00003c24  0000380e  LL    0x38 (D 56)
00003c28  00000169  ANDI  0x1 (D 1)
00003c2c  0000003b  LBI   0x0 (D 0)
00003c30  0000007a  EQ  
00003c34  000000a1  POPB
00003c38  0000004c  SXB 
os.c  1356:   f->writable = (oflag & O_WRONLY) || (oflag & O_RDWR);
00003c3c  0000040e  LL    0x4 (D 4)
00003c40  00000954  ADDI  0x9 (D 9)
00003c44  0000009d  PSHA
00003c48  0000380e  LL    0x38 (D 56)
00003c4c  00000169  ANDI  0x1 (D 1)
00003c50  00000086  BNZ   <fwd>
00003c54  0000380e  LL    0x38 (D 56)
00003c58  00000269  ANDI  0x2 (D 2)
00003c5c  003c5086  BNZ   <fwd>
00003c60  00000023  LI    0x0 (D 0)
00003c64  00000003  JMP   <fwd>
00003c68  00000123  LI    0x1 (D 1)
00003c6c  000000a1  POPB
00003c70  0000004c  SXB 
os.c  1357:   return fd;
00003c74  00001c0e  LL    0x1c (D 28)
00003c78  00002002  LEV   0x20 (D 32)
os.c  1358: }
os.c  1359: 
os.c  1360: int mkdir(char *path)
00003c7c  00002002  LEV   0x20 (D 32)
os.c  1361: {
os.c  1362:   struct inode *ip;
os.c  1363:   if (!svalid(path) || !(ip = create(path, S_IFDIR, 0))) return -1;
00003c80  fffff801  ENT   0xfffffff8 (D -8)
00003c84  0000100e  LL    0x10 (D 16)
00003c88  0000009d  PSHA
00003c8c  ffed5c05  JSR   0xffffed5c (TO 0x29ec)
00003c90  00000801  ENT   0x8 (D 8)
00003c94  00000084  BZ    <fwd>
00003c98  0000009e  PSHI  0x0 (D 0)
00003c9c  0040009e  PSHI  0x4000 (D 16384)
00003ca0  0000200e  LL    0x20 (D 32)
00003ca4  0000009d  PSHA
00003ca8  ffead005  JSR   0xffffead0 (TO 0x277c)
00003cac  00001801  ENT   0x18 (D 24)
00003cb0  00000440  SL    0x4 (D 4)
00003cb4  00000086  BNZ   <fwd>
00003cb8  ffffff23  LI    0xffffffff (D -1)
00003cbc  00000802  LEV   0x8 (D 8)
os.c  1364:   iunlockput(ip);
00003cc0  0000040e  LL    0x4 (D 4)
00003cc4  0000009d  PSHA
00003cc8  ffd80405  JSR   0xffffd804 (TO 0x14d0)
00003ccc  00000801  ENT   0x8 (D 8)
os.c  1365:   return 0;
00003cd0  00000023  LI    0x0 (D 0)
00003cd4  00000802  LEV   0x8 (D 8)
os.c  1366: }
os.c  1367: 
os.c  1368: int mknod(char *path, int mode, int dev)
00003cd8  00000802  LEV   0x8 (D 8)
os.c  1369: {
os.c  1370:   struct inode *ip;    
os.c  1371:   if (!svalid(path) || !(ip = create(path, mode, dev))) return -1;
00003cdc  fffff801  ENT   0xfffffff8 (D -8)
00003ce0  0000100e  LL    0x10 (D 16)
00003ce4  0000009d  PSHA
00003ce8  ffed0005  JSR   0xffffed00 (TO 0x29ec)
00003cec  00000801  ENT   0x8 (D 8)
00003cf0  00000084  BZ    <fwd>
00003cf4  0000200e  LL    0x20 (D 32)
00003cf8  0000009d  PSHA
00003cfc  0000200e  LL    0x20 (D 32)
00003d00  0000009d  PSHA
00003d04  0000200e  LL    0x20 (D 32)
00003d08  0000009d  PSHA
00003d0c  ffea6c05  JSR   0xffffea6c (TO 0x277c)
00003d10  00001801  ENT   0x18 (D 24)
00003d14  00000440  SL    0x4 (D 4)
00003d18  00000086  BNZ   <fwd>
00003d1c  ffffff23  LI    0xffffffff (D -1)
00003d20  00000802  LEV   0x8 (D 8)
os.c  1372:   iunlockput(ip);
00003d24  0000040e  LL    0x4 (D 4)
00003d28  0000009d  PSHA
00003d2c  ffd7a005  JSR   0xffffd7a0 (TO 0x14d0)
00003d30  00000801  ENT   0x8 (D 8)
os.c  1373:   return 0;
00003d34  00000023  LI    0x0 (D 0)
00003d38  00000802  LEV   0x8 (D 8)
os.c  1374: }
os.c  1375: 
os.c  1376: int chdir(char *path)
00003d3c  00000802  LEV   0x8 (D 8)
os.c  1377: {
os.c  1378:   struct inode *ip;
os.c  1379: 
os.c  1380:   if (!svalid(path) || !(ip = namei(path))) return -1;
00003d40  fffff801  ENT   0xfffffff8 (D -8)
00003d44  0000100e  LL    0x10 (D 16)
00003d48  0000009d  PSHA
00003d4c  ffec9c05  JSR   0xffffec9c (TO 0x29ec)
00003d50  00000801  ENT   0x8 (D 8)
00003d54  00000084  BZ    <fwd>
00003d58  0000100e  LL    0x10 (D 16)
00003d5c  0000009d  PSHA
00003d60  ffe3b005  JSR   0xffffe3b0 (TO 0x2114)
00003d64  00000801  ENT   0x8 (D 8)
00003d68  00000440  SL    0x4 (D 4)
00003d6c  00000086  BNZ   <fwd>
00003d70  ffffff23  LI    0xffffffff (D -1)
00003d74  00000802  LEV   0x8 (D 8)
os.c  1381:   ilock(ip);
00003d78  0000040e  LL    0x4 (D 4)
00003d7c  0000009d  PSHA
00003d80  ffd42405  JSR   0xffffd424 (TO 0x11a8)
00003d84  00000801  ENT   0x8 (D 8)
os.c  1382:   if ((ip->mode & S_IFMT) != S_IFDIR) {
00003d88  0000040e  LL    0x4 (D 4)
00003d8c  00000c1e  LXH   0xc (D 12)
00003d90  00f00069  ANDI  0xf000 (D 61440)
00003d94  0040003b  LBI   0x4000 (D 16384)
00003d98  00000088  BE    <fwd>
os.c  1383:     iunlockput(ip);
00003d9c  0000040e  LL    0x4 (D 4)
00003da0  0000009d  PSHA
00003da4  ffd72805  JSR   0xffffd728 (TO 0x14d0)
00003da8  00000801  ENT   0x8 (D 8)
os.c  1384:     return -1;
00003dac  ffffff23  LI    0xffffffff (D -1)
00003db0  00000802  LEV   0x8 (D 8)
os.c  1385:   }
os.c  1386:   iunlock(ip);
00003db4  0000040e  LL    0x4 (D 4)
00003db8  0000009d  PSHA
00003dbc  ffd58005  JSR   0xffffd580 (TO 0x1340)
00003dc0  00000801  ENT   0x8 (D 8)
os.c  1387:   iput(u->cwd);
00003dc4  00210015  LG    0x2100 (D 8448)
00003dc8  0000701c  LX    0x70 (D 112)
00003dcc  0000009d  PSHA
00003dd0  ffd5ec05  JSR   0xffffd5ec (TO 0x13c0)
00003dd4  00000801  ENT   0x8 (D 8)
os.c  1388:   u->cwd = ip;
00003dd8  00210015  LG    0x2100 (D 8448)
00003ddc  00007054  ADDI  0x70 (D 112)
00003de0  0000003e  LBA 
00003de4  0000040e  LL    0x4 (D 4)
00003de8  0000004a  SX  
os.c  1389:   return 0;
00003dec  00000023  LI    0x0 (D 0)
00003df0  00000802  LEV   0x8 (D 8)
os.c  1390: }
os.c  1391: 
os.c  1392: int pipe(int *fd)
00003df4  00000802  LEV   0x8 (D 8)
os.c  1393: {
os.c  1394:   struct pipe *p;
os.c  1395:   struct file *rf, *wf;
os.c  1396:   int fd0, fd1;
os.c  1397: 
os.c  1398:   if (!mvalid(fd, 8) || !(rf = filealloc())) return -1;
00003df8  ffffe801  ENT   0xffffffe8 (D -24)
00003dfc  0000089e  PSHI  0x8 (D 8)
00003e00  0000280e  LL    0x28 (D 40)
00003e04  0000009d  PSHA
00003e08  ffec3005  JSR   0xffffec30 (TO 0x2a3c)
00003e0c  00001001  ENT   0x10 (D 16)
00003e10  00000084  BZ    <fwd>
00003e14  ffe7f405  JSR   0xffffe7f4 (TO 0x260c)
00003e18  00001040  SL    0x10 (D 16)
00003e1c  00000086  BNZ   <fwd>
00003e20  ffffff23  LI    0xffffffff (D -1)
00003e24  00001802  LEV   0x18 (D 24)
os.c  1399:   if (!(wf = filealloc())) { fileclose(rf); return -1; }
00003e28  ffe7e005  JSR   0xffffe7e0 (TO 0x260c)
00003e2c  00000c40  SL    0xc (D 12)
00003e30  00000086  BNZ   <fwd>
00003e34  0000100e  LL    0x10 (D 16)
00003e38  0000009d  PSHA
00003e3c  ffedf405  JSR   0xffffedf4 (TO 0x2c34)
00003e40  00000801  ENT   0x8 (D 8)
00003e44  ffffff23  LI    0xffffffff (D -1)
00003e48  00001802  LEV   0x18 (D 24)
os.c  1400:   p = (struct pipe *)kalloc();
00003e4c  ffc39c05  JSR   0xffffc39c (TO 0x1ec)
00003e50  00001440  SL    0x14 (D 20)
os.c  1401:   p->readopen = 1;
00003e54  0000140e  LL    0x14 (D 20)
00003e58  000fa854  ADDI  0xfa8 (D 4008)
00003e5c  0000003e  LBA 
00003e60  00000123  LI    0x1 (D 1)
00003e64  0000004a  SX  
os.c  1402:   p->writeopen = 1;
00003e68  0000140e  LL    0x14 (D 20)
00003e6c  000fac54  ADDI  0xfac (D 4012)
00003e70  0000003e  LBA 
00003e74  00000123  LI    0x1 (D 1)
00003e78  0000004a  SX  
os.c  1403:   p->nwrite = 0;
00003e7c  0000140e  LL    0x14 (D 20)
00003e80  000fa454  ADDI  0xfa4 (D 4004)
00003e84  0000003e  LBA 
00003e88  00000023  LI    0x0 (D 0)
00003e8c  0000004a  SX  
os.c  1404:   p->nread = 0;
00003e90  0000140e  LL    0x14 (D 20)
00003e94  000fa054  ADDI  0xfa0 (D 4000)
00003e98  0000003e  LBA 
00003e9c  00000023  LI    0x0 (D 0)
00003ea0  0000004a  SX  
os.c  1405:   rf->type = FD_PIPE;
00003ea4  00000123  LI    0x1 (D 1)
00003ea8  00001026  LBL   0x10 (D 16)
00003eac  0000004a  SX  
os.c  1406:   rf->readable = 1;
00003eb0  0000100e  LL    0x10 (D 16)
00003eb4  00000854  ADDI  0x8 (D 8)
00003eb8  0000003e  LBA 
00003ebc  00000123  LI    0x1 (D 1)
00003ec0  0000004c  SXB 
os.c  1407:   rf->writable = 0;
00003ec4  0000100e  LL    0x10 (D 16)
00003ec8  00000954  ADDI  0x9 (D 9)
00003ecc  0000003e  LBA 
00003ed0  00000023  LI    0x0 (D 0)
00003ed4  0000004c  SXB 
os.c  1408:   rf->pipe = p;
00003ed8  0000100e  LL    0x10 (D 16)
00003edc  00000c54  ADDI  0xc (D 12)
00003ee0  0000003e  LBA 
00003ee4  0000140e  LL    0x14 (D 20)
00003ee8  0000004a  SX  
os.c  1409:   wf->type = FD_PIPE;
00003eec  00000123  LI    0x1 (D 1)
00003ef0  00000c26  LBL   0xc (D 12)
00003ef4  0000004a  SX  
os.c  1410:   wf->readable = 0;
00003ef8  00000c0e  LL    0xc (D 12)
00003efc  00000854  ADDI  0x8 (D 8)
00003f00  0000003e  LBA 
00003f04  00000023  LI    0x0 (D 0)
00003f08  0000004c  SXB 
os.c  1411:   wf->writable = 1;
00003f0c  00000c0e  LL    0xc (D 12)
00003f10  00000954  ADDI  0x9 (D 9)
00003f14  0000003e  LBA 
00003f18  00000123  LI    0x1 (D 1)
00003f1c  0000004c  SXB 
os.c  1412:   wf->pipe = p;
00003f20  00000c0e  LL    0xc (D 12)
00003f24  00000c54  ADDI  0xc (D 12)
00003f28  0000003e  LBA 
00003f2c  0000140e  LL    0x14 (D 20)
00003f30  0000004a  SX  
os.c  1413: 
os.c  1414:   if ((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0) {
00003f34  0000100e  LL    0x10 (D 16)
00003f38  0000009d  PSHA
00003f3c  ffe7b405  JSR   0xffffe7b4 (TO 0x26f4)
00003f40  00000801  ENT   0x8 (D 8)
00003f44  00000840  SL    0x8 (D 8)
00003f48  0000003b  LBI   0x0 (D 0)
00003f4c  0000008c  BLT   <fwd>
00003f50  00000c0e  LL    0xc (D 12)
00003f54  0000009d  PSHA
00003f58  ffe79805  JSR   0xffffe798 (TO 0x26f4)
00003f5c  00000801  ENT   0x8 (D 8)
00003f60  00000440  SL    0x4 (D 4)
00003f64  0000003b  LBI   0x0 (D 0)
00003f68  0000008f  BGE   <fwd>
os.c  1415:     if (fd0 >= 0) u->ofile[fd0] = 0;
00003f6c  0000080e  LL    0x8 (D 8)
00003f70  0000003b  LBI   0x0 (D 0)
00003f74  0000008c  BLT   <fwd>
00003f78  00210015  LG    0x2100 (D 8448)
00003f7c  00003054  ADDI  0x30 (D 48)
00003f80  0000009d  PSHA
00003f84  0000100e  LL    0x10 (D 16)
00003f88  0000045a  MULI  0x4 (D 4)
00003f8c  000000a1  POPB
00003f90  00000053  ADD 
00003f94  0000003e  LBA 
00003f98  00000023  LI    0x0 (D 0)
00003f9c  0000004a  SX  
os.c  1416:     fileclose(rf);
00003fa0  0000100e  LL    0x10 (D 16)
00003fa4  0000009d  PSHA
00003fa8  ffec8805  JSR   0xffffec88 (TO 0x2c34)
00003fac  00000801  ENT   0x8 (D 8)
os.c  1417:     fileclose(wf);
00003fb0  00000c0e  LL    0xc (D 12)
00003fb4  0000009d  PSHA
00003fb8  ffec7805  JSR   0xffffec78 (TO 0x2c34)
00003fbc  00000801  ENT   0x8 (D 8)
os.c  1418:     return -1;
00003fc0  ffffff23  LI    0xffffffff (D -1)
00003fc4  00001802  LEV   0x18 (D 24)
os.c  1419:   }
os.c  1420:   fd[0] = fd0;
00003fc8  0000080e  LL    0x8 (D 8)
00003fcc  00002026  LBL   0x20 (D 32)
00003fd0  0000004a  SX  
os.c  1421:   fd[1] = fd1;
00003fd4  0000200e  LL    0x20 (D 32)
00003fd8  00000454  ADDI  0x4 (D 4)
00003fdc  0000003e  LBA 
00003fe0  0000040e  LL    0x4 (D 4)
00003fe4  0000004a  SX  
os.c  1422:   return 0;
00003fe8  00000023  LI    0x0 (D 0)
00003fec  00001802  LEV   0x18 (D 24)
os.c  1423: }
os.c  1424: uint *walkpdir(uint *pd, uint va);
00003ff0  00001802  LEV   0x18 (D 24)
os.c  1425: 
os.c  1426: int exec(char *path, char **argv)
os.c  1427: {
os.c  1428:   char *s, *last;
os.c  1429:   uint argc, sz, sp, *stack, *pd, *oldpd, *pte;
os.c  1430:   struct { uint magic, bss, entry, flags; } hdr;
os.c  1431:   struct inode *ip;
os.c  1432:   char cpath[16];  // XXX length, safety!
os.c  1433:   int i, n, c;
os.c  1434: 
os.c  1435:   if (!svalid(path)) return -1;
00003ff4  ffffa801  ENT   0xffffffa8 (D -88)
00003ff8  0000600e  LL    0x60 (D 96)
00003ffc  0000009d  PSHA
00004000  ffe9e805  JSR   0xffffe9e8 (TO 0x29ec)
00004004  00000801  ENT   0x8 (D 8)
00004008  00000086  BNZ   <fwd>
0000400c  ffffff23  LI    0xffffffff (D -1)
00004010  00005802  LEV   0x58 (D 88)
os.c  1436:   for (argc = 0; ; argc++) {
00004014  00000023  LI    0x0 (D 0)
00004018  00004c40  SL    0x4c (D 76)
os.c  1437:     if (argc >= MAXARG || !mvalid(argv + argc, 4)) return -1;
0000401c  00004c0e  LL    0x4c (D 76)
00004020  0001003b  LBI   0x100 (D 256)
00004024  00000090  BGEU  <fwd>
00004028  0000049e  PSHI  0x4 (D 4)
0000402c  0000540e  LL    0x54 (D 84)
00004030  0000045a  MULI  0x4 (D 4)
00004034  00007055  ADDL  0x70 (D 112)
00004038  0000009d  PSHA
0000403c  ffe9fc05  JSR   0xffffe9fc (TO 0x2a3c)
00004040  00001001  ENT   0x10 (D 16)
00004044  00000086  BNZ   <fwd>
00004048  ffffff23  LI    0xffffffff (D -1)
0000404c  00005802  LEV   0x58 (D 88)
os.c  1438:     if (!argv[argc]) break;
00004050  00004c0e  LL    0x4c (D 76)
00004054  0000045a  MULI  0x4 (D 4)
00004058  00006855  ADDL  0x68 (D 104)
0000405c  0000001c  LX  
00004060  00000086  BNZ   <fwd>
00004064  00000003  JMP   <fwd>
os.c  1439:     if (!svalid(argv[argc])) return -1;
00004068  00004c0e  LL    0x4c (D 76)
0000406c  0000045a  MULI  0x4 (D 4)
00004070  00006855  ADDL  0x68 (D 104)
00004074  0000001c  LX  
00004078  0000009d  PSHA
0000407c  ffe96c05  JSR   0xffffe96c (TO 0x29ec)
00004080  00000801  ENT   0x8 (D 8)
00004084  00000086  BNZ   <fwd>
00004088  ffffff23  LI    0xffffffff (D -1)
0000408c  00005802  LEV   0x58 (D 88)
os.c  1440:   }
os.c  1441: 
os.c  1442:   if (c = !(ip = namei(path))) {  
00004090  00004c0e  LL    0x4c (D 76)
00004094  ffffff57  SUBI  0xffffffff (D -1)
00004098  00004c40  SL    0x4c (D 76)
0000409c  ffff7c03  JMP   0xffffff7c (TO 0x401c)
000040a0  0000600e  LL    0x60 (D 96)
000040a4  0000009d  PSHA
000040a8  ffe06805  JSR   0xffffe068 (TO 0x2114)
000040ac  00000801  ENT   0x8 (D 8)
000040b0  00002040  SL    0x20 (D 32)
000040b4  0000003b  LBI   0x0 (D 0)
000040b8  0000007a  EQ  
000040bc  00000440  SL    0x4 (D 4)
000040c0  00000084  BZ    <fwd>
os.c  1443:     memcpy(cpath, path, i = strlen(path));
000040c4  0000600e  LL    0x60 (D 96)
000040c8  0000009d  PSHA
000040cc  ffbfe805  JSR   0xffffbfe8 (TO 0xb8)
000040d0  00000801  ENT   0x8 (D 8)
000040d4  00000c40  SL    0xc (D 12)
000040d8  0000009d  PSHA
000040dc  0000680e  LL    0x68 (D 104)
000040e0  0000009d  PSHA
000040e4  00002007  LEA   0x20 (D 32)
000040e8  0000009d  PSHA
000040ec  ffbf1005  JSR   0xffffbf10 (TO 0x0)
000040f0  00001801  ENT   0x18 (D 24)
os.c  1444:     cpath[i] = '.';
000040f4  00001007  LEA   0x10 (D 16)
000040f8  00000c55  ADDL  0xc (D 12)
000040fc  0000003e  LBA 
00004100  00002e23  LI    0x2e (D 46)
00004104  0000004c  SXB 
os.c  1445:     cpath[i+1] = 'c';
00004108  00001007  LEA   0x10 (D 16)
0000410c  0000009d  PSHA
00004110  0000140e  LL    0x14 (D 20)
00004114  00000154  ADDI  0x1 (D 1)
00004118  000000a1  POPB
0000411c  00000053  ADD 
00004120  0000003e  LBA 
00004124  00006323  LI    0x63 (D 99)
00004128  0000004c  SXB 
os.c  1446:     cpath[i+2] = 0;
0000412c  00001007  LEA   0x10 (D 16)
00004130  0000009d  PSHA
00004134  0000140e  LL    0x14 (D 20)
00004138  00000254  ADDI  0x2 (D 2)
0000413c  000000a1  POPB
00004140  00000053  ADD 
00004144  0000003e  LBA 
00004148  00000023  LI    0x0 (D 0)
0000414c  0000004c  SXB 
os.c  1447:     if (!namei(cpath)) return -1;
00004150  00001007  LEA   0x10 (D 16)
00004154  0000009d  PSHA
00004158  ffdfb805  JSR   0xffffdfb8 (TO 0x2114)
0000415c  00000801  ENT   0x8 (D 8)
00004160  00000086  BNZ   <fwd>
00004164  ffffff23  LI    0xffffffff (D -1)
00004168  00005802  LEV   0x58 (D 88)
os.c  1448:     if (!(ip = namei(path = "/bin/c"))) return -1;
0000416c  00028c08  LEAG  0x28c (D 652)
00004170  00006040  SL    0x60 (D 96)
00004174  0000009d  PSHA
00004178  ffdf9805  JSR   0xffffdf98 (TO 0x2114)
0000417c  00000801  ENT   0x8 (D 8)
00004180  00002040  SL    0x20 (D 32)
00004184  00000086  BNZ   <fwd>
00004188  ffffff23  LI    0xffffffff (D -1)
0000418c  00005802  LEV   0x58 (D 88)
os.c  1449:     argv++;
00004190  0000680e  LL    0x68 (D 104)
00004194  fffffc57  SUBI  0xfffffffc (D -4)
00004198  00006840  SL    0x68 (D 104)
os.c  1450:     argc++;
0000419c  00004c0e  LL    0x4c (D 76)
000041a0  ffffff57  SUBI  0xffffffff (D -1)
000041a4  00004c40  SL    0x4c (D 76)
os.c  1451:   }
os.c  1452:   ilock(ip);
000041a8  0000200e  LL    0x20 (D 32)
000041ac  0000009d  PSHA
000041b0  ffcff405  JSR   0xffffcff4 (TO 0x11a8)
000041b4  00000801  ENT   0x8 (D 8)
os.c  1453:   pd = 0;
000041b8  00000023  LI    0x0 (D 0)
000041bc  00003c40  SL    0x3c (D 60)
os.c  1454: 
os.c  1455:   // Check header
os.c  1456:   if (readi(ip, (char *)&hdr, 0, sizeof(hdr)) < sizeof(hdr)) goto bad;
000041c0  0000109e  PSHI  0x10 (D 16)
000041c4  0000009e  PSHI  0x0 (D 0)
000041c8  00003407  LEA   0x34 (D 52)
000041cc  0000009d  PSHA
000041d0  0000380e  LL    0x38 (D 56)
000041d4  0000009d  PSHA
000041d8  ffd72c05  JSR   0xffffd72c (TO 0x1908)
000041dc  00002001  ENT   0x20 (D 32)
000041e0  0000103b  LBI   0x10 (D 16)
000041e4  0000008f  BGE   <fwd>
000041e8  00000003  JMP   <fwd>
os.c  1457:   if (hdr.magic != 0xC0DEF00D) goto bad; // XXX some more hdr checking?
000041ec  0000240e  LL    0x24 (D 36)
000041f0  ffffc03b  LBI   0xffffffc0 (D -64)
000041f4  def00d3c  LBHI  0xffdef00d (D -2166771)
000041f8  00000088  BE    <fwd>
000041fc  0041e803  JMP   <fwd>
os.c  1458: 
os.c  1459:   pd = memcpy(kalloc(), kpdir, PAGE);
00004200  0010009e  PSHI  0x1000 (D 4096)
00004204  00216815  LG    0x2168 (D 8552)
00004208  0000009d  PSHA
0000420c  ffbfdc05  JSR   0xffffbfdc (TO 0x1ec)
00004210  0000009d  PSHA
00004214  ffbde805  JSR   0xffffbde8 (TO 0x0)
00004218  00001801  ENT   0x18 (D 24)
0000421c  00003c40  SL    0x3c (D 60)
os.c  1460: 
os.c  1461:   // XXX stack should go after heap
os.c  1462: 
os.c  1463:   // load text and data segment   XXX map the whole file copy on write
os.c  1464:   if (!(sz = allocuvm(pd, 0, ip->size, 1))) goto bad;
00004220  0000019e  PSHI  0x1 (D 1)
00004224  0000280e  LL    0x28 (D 40)
00004228  0000141c  LX    0x14 (D 20)
0000422c  0000009d  PSHA
00004230  0000009e  PSHI  0x0 (D 0)
00004234  0000540e  LL    0x54 (D 84)
00004238  0000009d  PSHA
0000423c  00000005  JSR   <fwd>
00004240  00002001  ENT   0x20 (D 32)
00004244  00004840  SL    0x48 (D 72)
00004248  00000086  BNZ   <fwd>
0000424c  0041fc03  JMP   <fwd>
os.c  1465: 
os.c  1466:   for (i = 0; i < sz; i += PAGE) {
00004250  00000023  LI    0x0 (D 0)
00004254  00000c40  SL    0xc (D 12)
00004258  00000003  JMP   <fwd>
os.c  1467:     if (!(pte = walkpdir(pd, i))) panic("exit() address should exist");
0000425c  00000c0e  LL    0xc (D 12)
00004260  0000009d  PSHA
00004264  0000440e  LL    0x44 (D 68)
00004268  0000009d  PSHA
0000426c  00000005  JSR   <fwd>
00004270  00001001  ENT   0x10 (D 16)
00004274  00003440  SL    0x34 (D 52)
00004278  00000086  BNZ   <fwd>
0000427c  00029308  LEAG  0x293 (D 659)
00004280  0000009d  PSHA
00004284  ffc2ac05  JSR   0xffffc2ac (TO 0x534)
00004288  00000801  ENT   0x8 (D 8)
os.c  1468:     n = (sz - i < PAGE) ? sz - i : PAGE;
0000428c  0000480e  LL    0x48 (D 72)
00004290  00000c58  SUBL  0xc (D 12)
00004294  0010003b  LBI   0x1000 (D 4096)
00004298  00000090  BGEU  <fwd>
0000429c  0000480e  LL    0x48 (D 72)
000042a0  00000c58  SUBL  0xc (D 12)
000042a4  00000003  JMP   <fwd>
000042a8  00100023  LI    0x1000 (D 4096)
000042ac  00000840  SL    0x8 (D 8)
os.c  1469:     if (readi(ip, P2V+(*pte & -PAGE), i, n) != n) goto bad;
000042b0  0000080e  LL    0x8 (D 8)
000042b4  0000009d  PSHA
000042b8  0000140e  LL    0x14 (D 20)
000042bc  0000009d  PSHA
000042c0  0000440e  LL    0x44 (D 68)
000042c4  0000001c  LX  
000042c8  fff00069  ANDI  0xfffff000 (D -4096)
000042cc  ffffc03b  LBI   0xffffffc0 (D -64)
000042d0  0000003c  LBHI  0x0 (D 0)
000042d4  00000053  ADD 
000042d8  0000009d  PSHA
000042dc  0000380e  LL    0x38 (D 56)
000042e0  0000009d  PSHA
000042e4  ffd62005  JSR   0xffffd620 (TO 0x1908)
000042e8  00002001  ENT   0x20 (D 32)
000042ec  00000826  LBL   0x8 (D 8)
000042f0  00000088  BE    <fwd>
000042f4  00424c03  JMP   <fwd>
os.c  1470:   }
os.c  1471:   
os.c  1472:   iunlockput(ip);
000042f8  00000c0e  LL    0xc (D 12)
000042fc  00100054  ADDI  0x1000 (D 4096)
00004300  00000c40  SL    0xc (D 12)
00004304  00000c0e  LL    0xc (D 12)
00004308  00004826  LBL   0x48 (D 72)
0000430c  0000008d  BLTU  <fwd>
00004310  0000200e  LL    0x20 (D 32)
00004314  0000009d  PSHA
00004318  ffd1b405  JSR   0xffffd1b4 (TO 0x14d0)
0000431c  00000801  ENT   0x8 (D 8)
os.c  1473:   ip = 0;
00004320  00000023  LI    0x0 (D 0)
00004324  00002040  SL    0x20 (D 32)
os.c  1474:   
os.c  1475:   // allocate bss and stack segment
os.c  1476:   if (!(sz = allocuvm(pd, sz, sz + hdr.bss + STACKSZ, 0))) goto bad;
00004328  0000009e  PSHI  0x0 (D 0)
0000432c  0000500e  LL    0x50 (D 80)
00004330  00003055  ADDL  0x30 (D 48)
00004334  0000003b  LBI   0x0 (D 0)
00004338  8000003c  LBHI  0xff800000 (D -8388608)
0000433c  00000053  ADD 
00004340  0000009d  PSHA
00004344  0000580e  LL    0x58 (D 88)
00004348  0000009d  PSHA
0000434c  0000540e  LL    0x54 (D 84)
00004350  0000009d  PSHA
00004354  00423c05  JSR   <fwd>
00004358  00002001  ENT   0x20 (D 32)
0000435c  00004840  SL    0x48 (D 72)
00004360  00000086  BNZ   <fwd>
00004364  0042f403  JMP   <fwd>
os.c  1477: 
os.c  1478:   // initialize the top page of the stack
os.c  1479:   sz &= -PAGE;
00004368  0000480e  LL    0x48 (D 72)
0000436c  fff00069  ANDI  0xfffff000 (D -4096)
00004370  00004840  SL    0x48 (D 72)
os.c  1480:   mappage(pd, sz, V2P+(sp = memset(kalloc(), 0, PAGE)), PTE_P | PTE_W | PTE_U);
00004374  0000079e  PSHI  0x7 (D 7)
00004378  0010009e  PSHI  0x1000 (D 4096)
0000437c  0000009e  PSHI  0x0 (D 0)
00004380  ffbe6805  JSR   0xffffbe68 (TO 0x1ec)
00004384  0000009d  PSHA
00004388  ffbc8c05  JSR   0xffffbc8c (TO 0x18)
0000438c  00001801  ENT   0x18 (D 24)
00004390  00004c40  SL    0x4c (D 76)
00004394  0000403b  LBI   0x40 (D 64)
00004398  0000003c  LBHI  0x0 (D 0)
0000439c  00000053  ADD 
000043a0  0000009d  PSHA
000043a4  0000580e  LL    0x58 (D 88)
000043a8  0000009d  PSHA
000043ac  0000540e  LL    0x54 (D 84)
000043b0  0000009d  PSHA
000043b4  00000005  JSR   <fwd>
000043b8  00002001  ENT   0x20 (D 32)
os.c  1481: 
os.c  1482:   // prepare stack arguments
os.c  1483:   stack = sp += PAGE - (argc+1)*4;
000043bc  00004c0e  LL    0x4c (D 76)
000043c0  00000154  ADDI  0x1 (D 1)
000043c4  0000045a  MULI  0x4 (D 4)
000043c8  0000003e  LBA 
000043cc  00100023  LI    0x1000 (D 4096)
000043d0  00000056  SUB 
000043d4  00004455  ADDL  0x44 (D 68)
000043d8  00004440  SL    0x44 (D 68)
000043dc  00004040  SL    0x40 (D 64)
os.c  1484:   for (i=0; i<argc; i++) {
000043e0  00000023  LI    0x0 (D 0)
000043e4  00000c40  SL    0xc (D 12)
000043e8  00000003  JMP   <fwd>
os.c  1485:     s = (!c || i > 1) ? *argv++ : (i ? cpath : path);
000043ec  0000040e  LL    0x4 (D 4)
000043f0  00000084  BZ    <fwd>
000043f4  00000123  LI    0x1 (D 1)
000043f8  00000c26  LBL   0xc (D 12)
000043fc  0000008f  BGE   <fwd>
00004400  0000680e  LL    0x68 (D 104)
00004404  fffffc57  SUBI  0xfffffffc (D -4)
00004408  00006840  SL    0x68 (D 104)
0000440c  fffffc1c  LX    0xfffffffc (D -4)
00004410  00000003  JMP   <fwd>
00004414  00000c0e  LL    0xc (D 12)
00004418  00000084  BZ    <fwd>
0000441c  00001007  LEA   0x10 (D 16)
00004420  00000003  JMP   <fwd>
00004424  0000600e  LL    0x60 (D 96)
00004428  00005440  SL    0x54 (D 84)
os.c  1486:     n = strlen(s) + 1;
0000442c  0000540e  LL    0x54 (D 84)
00004430  0000009d  PSHA
00004434  ffbc8005  JSR   0xffffbc80 (TO 0xb8)
00004438  00000801  ENT   0x8 (D 8)
0000443c  00000154  ADDI  0x1 (D 1)
00004440  00000840  SL    0x8 (D 8)
os.c  1487:     if ((sp & (PAGE - 1)) < n) goto bad;
00004444  0000440e  LL    0x44 (D 68)
00004448  000fff69  ANDI  0xfff (D 4095)
0000444c  00000826  LBL   0x8 (D 8)
00004450  00000090  BGEU  <fwd>
00004454  00436403  JMP   <fwd>
os.c  1488:     sp -= n;
00004458  0000440e  LL    0x44 (D 68)
0000445c  00000858  SUBL  0x8 (D 8)
00004460  00004440  SL    0x44 (D 68)
os.c  1489:     memcpy(sp, s, n);
00004464  0000080e  LL    0x8 (D 8)
00004468  0000009d  PSHA
0000446c  00005c0e  LL    0x5c (D 92)
00004470  0000009d  PSHA
00004474  0000540e  LL    0x54 (D 84)
00004478  0000009d  PSHA
0000447c  ffbb8005  JSR   0xffffbb80 (TO 0x0)
00004480  00001801  ENT   0x18 (D 24)
os.c  1490:     stack[i] = sz + (sp & (PAGE - 1));
00004484  00000c0e  LL    0xc (D 12)
00004488  0000045a  MULI  0x4 (D 4)
0000448c  00004055  ADDL  0x40 (D 64)
00004490  0000009d  PSHA
00004494  00004c0e  LL    0x4c (D 76)
00004498  000fff69  ANDI  0xfff (D 4095)
0000449c  00005055  ADDL  0x50 (D 80)
000044a0  000000a1  POPB
000044a4  0000004a  SX  
os.c  1491:   }
os.c  1492:   stack[argc] = 0;
000044a8  00000c0e  LL    0xc (D 12)
000044ac  ffffff57  SUBI  0xffffffff (D -1)
000044b0  00000c40  SL    0xc (D 12)
000044b4  00000c0e  LL    0xc (D 12)
000044b8  00004c26  LBL   0x4c (D 76)
000044bc  0000008d  BLTU  <fwd>
000044c0  00004c0e  LL    0x4c (D 76)
000044c4  0000045a  MULI  0x4 (D 4)
000044c8  00004055  ADDL  0x40 (D 64)
000044cc  0000003e  LBA 
000044d0  00000023  LI    0x0 (D 0)
000044d4  0000004a  SX  
os.c  1493:   if ((sp & (PAGE - 1)) < 40) { // XXX 40? stick into above loop?
000044d8  0000440e  LL    0x44 (D 68)
000044dc  000fff69  ANDI  0xfff (D 4095)
000044e0  0000283b  LBI   0x28 (D 40)
000044e4  00000090  BGEU  <fwd>
os.c  1494: bad:
os.c  1495:     if (pd) freevm(pd);
000044e8  00003c0e  LL    0x3c (D 60)
000044ec  00000084  BZ    <fwd>
000044f0  00003c0e  LL    0x3c (D 60)
000044f4  0000009d  PSHA
000044f8  00000005  JSR   <fwd>
000044fc  00000801  ENT   0x8 (D 8)
os.c  1496:     if (ip) iunlockput(ip);
00004500  0000200e  LL    0x20 (D 32)
00004504  00000084  BZ    <fwd>
00004508  0000200e  LL    0x20 (D 32)
0000450c  0000009d  PSHA
00004510  ffcfbc05  JSR   0xffffcfbc (TO 0x14d0)
00004514  00000801  ENT   0x8 (D 8)
os.c  1497:     return -1;
00004518  ffffff23  LI    0xffffffff (D -1)
0000451c  00005802  LEV   0x58 (D 88)
os.c  1498:   }
os.c  1499:   stack = sp = (sp - 28) & -8;
00004520  0000440e  LL    0x44 (D 68)
00004524  ffffe454  ADDI  0xffffffe4 (D -28)
00004528  fffff869  ANDI  0xfffffff8 (D -8)
0000452c  00004440  SL    0x44 (D 68)
00004530  00004040  SL    0x40 (D 64)
os.c  1500:   stack[0] = sz + ((sp + 24) & (PAGE - 1)); // return address
00004534  0000440e  LL    0x44 (D 68)
00004538  00001854  ADDI  0x18 (D 24)
0000453c  000fff69  ANDI  0xfff (D 4095)
00004540  00004855  ADDL  0x48 (D 72)
00004544  00004026  LBL   0x40 (D 64)
00004548  0000004a  SX  
os.c  1501:   stack[2] = argc;
0000454c  0000400e  LL    0x40 (D 64)
00004550  00000854  ADDI  0x8 (D 8)
00004554  0000003e  LBA 
00004558  00004c0e  LL    0x4c (D 76)
0000455c  0000004a  SX  
os.c  1502:   stack[4] = sz + PAGE - (argc+1)*4; // argv
00004560  0000400e  LL    0x40 (D 64)
00004564  00001054  ADDI  0x10 (D 16)
00004568  0000009d  PSHA
0000456c  0000540e  LL    0x54 (D 84)
00004570  00000154  ADDI  0x1 (D 1)
00004574  0000045a  MULI  0x4 (D 4)
00004578  0000009d  PSHA
0000457c  0000580e  LL    0x58 (D 88)
00004580  00100054  ADDI  0x1000 (D 4096)
00004584  000000a1  POPB
00004588  00000056  SUB 
0000458c  000000a1  POPB
00004590  0000004a  SX  
os.c  1503:   stack[6] = TRAP | (S_exit<<8); // call exit if main returns
00004594  0000400e  LL    0x40 (D 64)
00004598  00001854  ADDI  0x18 (D 24)
0000459c  0000003e  LBA 
000045a0  0002a923  LI    0x2a9 (D 681)
000045a4  0000004a  SX  
os.c  1504: 
os.c  1505:   // save program name for debugging XXX
os.c  1506:   for (last=s=path; *s; s++)
000045a8  0000600e  LL    0x60 (D 96)
000045ac  00005440  SL    0x54 (D 84)
000045b0  00005040  SL    0x50 (D 80)
os.c  1507:     if (*s == '/') last = s+1;
000045b4  00000003  JMP   <fwd>
000045b8  0000540e  LL    0x54 (D 84)
000045bc  0000001f  LXC 
000045c0  00002f3b  LBI   0x2f (D 47)
000045c4  0000008a  BNE   <fwd>
000045c8  0000540e  LL    0x54 (D 84)
000045cc  00000154  ADDI  0x1 (D 1)
000045d0  00005040  SL    0x50 (D 80)
os.c  1508:   safestrcpy(u->name, last, sizeof(u->name));
000045d4  0000540e  LL    0x54 (D 84)
000045d8  ffffff57  SUBI  0xffffffff (D -1)
000045dc  00005440  SL    0x54 (D 84)
000045e0  0000540e  LL    0x54 (D 84)
000045e4  0000001f  LXC 
000045e8  00000086  BNZ   <fwd>
000045ec  0000109e  PSHI  0x10 (D 16)
000045f0  0000580e  LL    0x58 (D 88)
000045f4  0000009d  PSHA
000045f8  00210015  LG    0x2100 (D 8448)
000045fc  00007454  ADDI  0x74 (D 116)
00004600  0000009d  PSHA
00004604  ffbb7005  JSR   0xffffbb70 (TO 0x178)
00004608  00001801  ENT   0x18 (D 24)
os.c  1509:   
os.c  1510:   // commit to the user image
os.c  1511:   oldpd = u->pdir;
0000460c  00210015  LG    0x2100 (D 8448)
00004610  00000c1c  LX    0xc (D 12)
00004614  00003840  SL    0x38 (D 56)
os.c  1512:   u->pdir = pd;
00004618  00210015  LG    0x2100 (D 8448)
0000461c  00000c54  ADDI  0xc (D 12)
00004620  0000003e  LBA 
00004624  00003c0e  LL    0x3c (D 60)
00004628  0000004a  SX  
os.c  1513:   u->sz = sz + PAGE;
0000462c  00210015  LG    0x2100 (D 8448)
00004630  00000854  ADDI  0x8 (D 8)
00004634  0000009d  PSHA
00004638  0000500e  LL    0x50 (D 80)
0000463c  00100054  ADDI  0x1000 (D 4096)
00004640  000000a1  POPB
00004644  0000004a  SX  
os.c  1514:   u->tf->fc = USER;
00004648  00210015  LG    0x2100 (D 8448)
0000464c  0000201c  LX    0x20 (D 32)
00004650  00003054  ADDI  0x30 (D 48)
00004654  0000003e  LBA 
00004658  00001023  LI    0x10 (D 16)
0000465c  0000004a  SX  
os.c  1515:   u->tf->pc = hdr.entry + sizeof(hdr);
00004660  00210015  LG    0x2100 (D 8448)
00004664  0000201c  LX    0x20 (D 32)
00004668  00003854  ADDI  0x38 (D 56)
0000466c  0000009d  PSHA
00004670  0000340e  LL    0x34 (D 52)
00004674  00001054  ADDI  0x10 (D 16)
00004678  000000a1  POPB
0000467c  0000004a  SX  
os.c  1516:   u->tf->sp = sz + (sp & (PAGE - 1));
00004680  00210015  LG    0x2100 (D 8448)
00004684  0000201c  LX    0x20 (D 32)
00004688  0000009d  PSHA
0000468c  00004c0e  LL    0x4c (D 76)
00004690  000fff69  ANDI  0xfff (D 4095)
00004694  00005055  ADDL  0x50 (D 80)
00004698  000000a1  POPB
0000469c  0000004a  SX  
os.c  1517:   pdir(V2P+(uint)(u->pdir));
000046a0  00210015  LG    0x2100 (D 8448)
000046a4  00000c1c  LX    0xc (D 12)
000046a8  0000403b  LBI   0x40 (D 64)
000046ac  0000003c  LBHI  0x0 (D 0)
000046b0  00000053  ADD 
000046b4  0000009d  PSHA
000046b8  ffb9cc05  JSR   0xffffb9cc (TO 0x88)
000046bc  00000801  ENT   0x8 (D 8)
os.c  1518:   freevm(oldpd);
000046c0  0000380e  LL    0x38 (D 56)
000046c4  0000009d  PSHA
000046c8  0044f805  JSR   <fwd>
000046cc  00000801  ENT   0x8 (D 8)
os.c  1519:   return 0;
000046d0  00000023  LI    0x0 (D 0)
000046d4  00005802  LEV   0x58 (D 88)
os.c  1520: }
os.c  1521: 
os.c  1522: struct proc *allocproc();
000046d8  00005802  LEV   0x58 (D 88)
os.c  1523: uint *copyuvm(uint *pd, uint sz);
os.c  1524: 
os.c  1525: int fork()
os.c  1526: {
os.c  1527:   int i, pid;
os.c  1528:   struct proc *np;
os.c  1529: 
os.c  1530:   if (!(np = allocproc())) return -1;
000046dc  fffff001  ENT   0xfffffff0 (D -16)
000046e0  00000005  JSR   <fwd>
000046e4  00000440  SL    0x4 (D 4)
000046e8  00000086  BNZ   <fwd>
000046ec  ffffff23  LI    0xffffffff (D -1)
000046f0  00001002  LEV   0x10 (D 16)
os.c  1531:   np->pdir = copyuvm(u->pdir, u->sz); // copy process state
000046f4  0000040e  LL    0x4 (D 4)
000046f8  00000c54  ADDI  0xc (D 12)
000046fc  0000009d  PSHA
00004700  00210015  LG    0x2100 (D 8448)
00004704  0000081c  LX    0x8 (D 8)
00004708  0000009d  PSHA
0000470c  00210015  LG    0x2100 (D 8448)
00004710  00000c1c  LX    0xc (D 12)
00004714  0000009d  PSHA
00004718  00000005  JSR   <fwd>
0000471c  00001001  ENT   0x10 (D 16)
00004720  000000a1  POPB
00004724  0000004a  SX  
os.c  1532:   np->sz = u->sz;
00004728  0000040e  LL    0x4 (D 4)
0000472c  00000854  ADDI  0x8 (D 8)
00004730  0000009d  PSHA
00004734  00210015  LG    0x2100 (D 8448)
00004738  0000081c  LX    0x8 (D 8)
0000473c  000000a1  POPB
00004740  0000004a  SX  
os.c  1533:   np->parent = u;
00004744  0000040e  LL    0x4 (D 4)
00004748  00001c54  ADDI  0x1c (D 28)
0000474c  0000003e  LBA 
00004750  00210015  LG    0x2100 (D 8448)
00004754  0000004a  SX  
os.c  1534:   memcpy(np->tf, u->tf, sizeof(struct trapframe));
00004758  0000409e  PSHI  0x40 (D 64)
0000475c  00210015  LG    0x2100 (D 8448)
00004760  0000201c  LX    0x20 (D 32)
00004764  0000009d  PSHA
00004768  0000140e  LL    0x14 (D 20)
0000476c  0000201c  LX    0x20 (D 32)
00004770  0000009d  PSHA
00004774  ffb88805  JSR   0xffffb888 (TO 0x0)
00004778  00001801  ENT   0x18 (D 24)
os.c  1535:   np->tf->a = 0; // child returns 0
0000477c  0000040e  LL    0x4 (D 4)
00004780  0000201c  LX    0x20 (D 32)
00004784  00002854  ADDI  0x28 (D 40)
00004788  0000003e  LBA 
0000478c  00000023  LI    0x0 (D 0)
00004790  0000004a  SX  
os.c  1536:   for (i = 0; i < NOFILE; i++)
00004794  00000023  LI    0x0 (D 0)
00004798  00000c40  SL    0xc (D 12)
os.c  1537:     if (u->ofile[i]) np->ofile[i] = filedup(u->ofile[i]);
0000479c  00000003  JMP   <fwd>
000047a0  00210015  LG    0x2100 (D 8448)
000047a4  00003054  ADDI  0x30 (D 48)
000047a8  0000009d  PSHA
000047ac  0000140e  LL    0x14 (D 20)
000047b0  0000045a  MULI  0x4 (D 4)
000047b4  000000a1  POPB
000047b8  00000053  ADD 
000047bc  0000001c  LX  
000047c0  00000084  BZ    <fwd>
000047c4  0000040e  LL    0x4 (D 4)
000047c8  00003054  ADDI  0x30 (D 48)
000047cc  0000009d  PSHA
000047d0  0000140e  LL    0x14 (D 20)
000047d4  0000045a  MULI  0x4 (D 4)
000047d8  000000a1  POPB
000047dc  00000053  ADD 
000047e0  0000009d  PSHA
000047e4  00210015  LG    0x2100 (D 8448)
000047e8  00003054  ADDI  0x30 (D 48)
000047ec  0000009d  PSHA
000047f0  00001c0e  LL    0x1c (D 28)
000047f4  0000045a  MULI  0x4 (D 4)
000047f8  000000a1  POPB
000047fc  00000053  ADD 
00004800  0000001c  LX  
00004804  0000009d  PSHA
00004808  ffde8805  JSR   0xffffde88 (TO 0x2694)
0000480c  00000801  ENT   0x8 (D 8)
00004810  000000a1  POPB
00004814  0000004a  SX  
os.c  1538:   idup(np->cwd = u->cwd);
00004818  00000c0e  LL    0xc (D 12)
0000481c  ffffff57  SUBI  0xffffffff (D -1)
00004820  00000c40  SL    0xc (D 12)
00004824  00000c0e  LL    0xc (D 12)
00004828  0000103b  LBI   0x10 (D 16)
0000482c  0000008c  BLT   <fwd>
00004830  0000040e  LL    0x4 (D 4)
00004834  00007054  ADDI  0x70 (D 112)
00004838  0000009d  PSHA
0000483c  00210015  LG    0x2100 (D 8448)
00004840  0000701c  LX    0x70 (D 112)
00004844  000000a1  POPB
00004848  0000004a  SX  
0000484c  0000009d  PSHA
00004850  ffc91c05  JSR   0xffffc91c (TO 0x1170)
00004854  00000801  ENT   0x8 (D 8)
os.c  1539:   pid = np->pid;
00004858  0000040e  LL    0x4 (D 4)
0000485c  0000181c  LX    0x18 (D 24)
00004860  00000840  SL    0x8 (D 8)
os.c  1540:   safestrcpy(np->name, u->name, sizeof(u->name));
00004864  0000109e  PSHI  0x10 (D 16)
00004868  00210015  LG    0x2100 (D 8448)
0000486c  00007454  ADDI  0x74 (D 116)
00004870  0000009d  PSHA
00004874  0000140e  LL    0x14 (D 20)
00004878  00007454  ADDI  0x74 (D 116)
0000487c  0000009d  PSHA
00004880  ffb8f405  JSR   0xffffb8f4 (TO 0x178)
00004884  00001801  ENT   0x18 (D 24)
os.c  1541:   np->state = RUNNABLE;
00004888  0000040e  LL    0x4 (D 4)
0000488c  00001454  ADDI  0x14 (D 20)
00004890  0000003e  LBA 
00004894  00000323  LI    0x3 (D 3)
00004898  0000004a  SX  
os.c  1542:   return pid;
0000489c  0000080e  LL    0x8 (D 8)
000048a0  00001002  LEV   0x10 (D 16)
os.c  1543: }
os.c  1544: 
os.c  1545: // Exit the current process.  Does not return.  An exited process remains in the zombie state
os.c  1546: // until its parent calls wait() to find out it exited.  Special treatment for process 0 and 1.
os.c  1547: exit(int rc)
000048a4  00001002  LEV   0x10 (D 16)
os.c  1548: {
os.c  1549:   struct proc *p; int fd;
os.c  1550: 
os.c  1551: //  printf("exit(%d)\n",rc); // XXX do something with return code
os.c  1552:   if (u->pid == 0) { for (;;) asm(IDLE); } // spin in the arms of the kernel (cant be paged out)
000048a8  fffff801  ENT   0xfffffff8 (D -8)
000048ac  00210015  LG    0x2100 (D 8448)
000048b0  0000181c  LX    0x18 (D 24)
000048b4  0000003b  LBI   0x0 (D 0)
000048b8  0000008a  BNE   <fwd>
000048bc  000000d0  IDLE
000048c0  fffff803  JMP   0xfffffff8 (TO 0x48bc)
os.c  1553:   else if (u->pid == 1) panic("exit() init exiting"); // XXX reboot after all processes go away?
000048c4  00000003  JMP   <fwd>
000048c8  00210015  LG    0x2100 (D 8448)
000048cc  0000181c  LX    0x18 (D 24)
000048d0  0000013b  LBI   0x1 (D 1)
000048d4  0000008a  BNE   <fwd>
000048d8  0002af08  LEAG  0x2af (D 687)
000048dc  0000009d  PSHA
000048e0  ffbc5005  JSR   0xffffbc50 (TO 0x534)
000048e4  00000801  ENT   0x8 (D 8)
os.c  1554: 
os.c  1555:   // close all open files
os.c  1556:   for (fd = 0; fd < NOFILE; fd++) {
000048e8  00000023  LI    0x0 (D 0)
000048ec  00000040  SL    0x0 (D 0)
000048f0  00000003  JMP   <fwd>
os.c  1557:     if (u->ofile[fd]) {
000048f4  00210015  LG    0x2100 (D 8448)
000048f8  00003054  ADDI  0x30 (D 48)
000048fc  0000009d  PSHA
00004900  0000080e  LL    0x8 (D 8)
00004904  0000045a  MULI  0x4 (D 4)
00004908  000000a1  POPB
0000490c  00000053  ADD 
00004910  0000001c  LX  
00004914  00000084  BZ    <fwd>
os.c  1558:       fileclose(u->ofile[fd]);
00004918  00210015  LG    0x2100 (D 8448)
0000491c  00003054  ADDI  0x30 (D 48)
00004920  0000009d  PSHA
00004924  0000080e  LL    0x8 (D 8)
00004928  0000045a  MULI  0x4 (D 4)
0000492c  000000a1  POPB
00004930  00000053  ADD 
00004934  0000001c  LX  
00004938  0000009d  PSHA
0000493c  ffe2f405  JSR   0xffffe2f4 (TO 0x2c34)
00004940  00000801  ENT   0x8 (D 8)
os.c  1559:       u->ofile[fd] = 0;
00004944  00210015  LG    0x2100 (D 8448)
00004948  00003054  ADDI  0x30 (D 48)
0000494c  0000009d  PSHA
00004950  0000080e  LL    0x8 (D 8)
00004954  0000045a  MULI  0x4 (D 4)
00004958  000000a1  POPB
0000495c  00000053  ADD 
00004960  0000003e  LBA 
00004964  00000023  LI    0x0 (D 0)
00004968  0000004a  SX  
os.c  1560:     }
os.c  1561:   }
os.c  1562:   iput(u->cwd);
0000496c  0000000e  LL    0x0 (D 0)
00004970  ffffff57  SUBI  0xffffffff (D -1)
00004974  00000040  SL    0x0 (D 0)
00004978  0000000e  LL    0x0 (D 0)
0000497c  0000103b  LBI   0x10 (D 16)
00004980  0000008c  BLT   <fwd>
00004984  00210015  LG    0x2100 (D 8448)
00004988  0000701c  LX    0x70 (D 112)
0000498c  0000009d  PSHA
00004990  ffca2c05  JSR   0xffffca2c (TO 0x13c0)
00004994  00000801  ENT   0x8 (D 8)
os.c  1563:   u->cwd = 0;
00004998  00210015  LG    0x2100 (D 8448)
0000499c  00007054  ADDI  0x70 (D 112)
000049a0  0000003e  LBA 
000049a4  00000023  LI    0x0 (D 0)
000049a8  0000004a  SX  
os.c  1564: 
os.c  1565:   asm(CLI);
000049ac  00000096  CLI 
os.c  1566: 
os.c  1567:   // parent might be sleeping in wait()
os.c  1568:   wakeup(u->parent);
000049b0  00210015  LG    0x2100 (D 8448)
000049b4  00001c1c  LX    0x1c (D 28)
000049b8  0000009d  PSHA
000049bc  0025e805  JSR   <fwd>
000049c0  00000801  ENT   0x8 (D 8)
os.c  1569: 
os.c  1570:   // pass abandoned children to init
os.c  1571:   for (p = proc; p < &proc[NPROC]; p++) {
000049c4  00000008  LEAG  0x0 (D 0)
000049c8  00000440  SL    0x4 (D 4)
000049cc  00000003  JMP   <fwd>
os.c  1572:     if (p->parent == u) {
000049d0  0000040e  LL    0x4 (D 4)
000049d4  00001c1c  LX    0x1c (D 28)
000049d8  0021002d  LBG   0x2100 (D 8448)
000049dc  0000008a  BNE   <fwd>
os.c  1573:       p->parent = init;
000049e0  0000040e  LL    0x4 (D 4)
000049e4  00001c54  ADDI  0x1c (D 28)
000049e8  0000003e  LBA 
000049ec  00210415  LG    0x2104 (D 8452)
000049f0  0000004a  SX  
os.c  1574:       if (p->state == ZOMBIE) wakeup(init);
000049f4  0000040e  LL    0x4 (D 4)
000049f8  0000141c  LX    0x14 (D 20)
000049fc  0000053b  LBI   0x5 (D 5)
00004a00  0000008a  BNE   <fwd>
00004a04  00210415  LG    0x2104 (D 8452)
00004a08  0000009d  PSHA
00004a0c  0049bc05  JSR   <fwd>
00004a10  00000801  ENT   0x8 (D 8)
os.c  1575:     }
os.c  1576:   }
os.c  1577: 
os.c  1578:   // jump into the scheduler, never to return
os.c  1579:   u->state = ZOMBIE;
00004a14  0000040e  LL    0x4 (D 4)
00004a18  ffff7c57  SUBI  0xffffff7c (D -132)
00004a1c  00000440  SL    0x4 (D 4)
00004a20  00210008  LEAG  0x2100 (D 8448)
00004a24  0000003e  LBA 
00004a28  0000040e  LL    0x4 (D 4)
00004a2c  0000008d  BLTU  <fwd>
00004a30  00210015  LG    0x2100 (D 8448)
00004a34  00001454  ADDI  0x14 (D 20)
00004a38  0000003e  LBA 
00004a3c  00000523  LI    0x5 (D 5)
00004a40  0000004a  SX  
os.c  1580:   sched();
00004a44  00000005  JSR   <fwd>
os.c  1581:   panic("zombie exit");
00004a48  0002c308  LEAG  0x2c3 (D 707)
00004a4c  0000009d  PSHA
00004a50  ffbae005  JSR   0xffffbae0 (TO 0x534)
00004a54  00000801  ENT   0x8 (D 8)
os.c  1582: }
os.c  1583: 
os.c  1584: // Kill the process with the given pid.  Process won't exit until it returns to user space (see trap()).
os.c  1585: int kill(int pid)
00004a58  00000802  LEV   0x8 (D 8)
os.c  1586: {
os.c  1587:   struct proc *p; int e = splhi();
os.c  1588: 
os.c  1589:   for (p = proc; p < &proc[NPROC]; p++) {
00004a5c  fffff801  ENT   0xfffffff8 (D -8)
00004a60  ffb63c05  JSR   0xffffb63c (TO 0xa0)
00004a64  00000040  SL    0x0 (D 0)
00004a68  00000008  LEAG  0x0 (D 0)
00004a6c  00000440  SL    0x4 (D 4)
00004a70  00000003  JMP   <fwd>
os.c  1590:     if (p->pid == pid) {
00004a74  0000040e  LL    0x4 (D 4)
00004a78  0000181c  LX    0x18 (D 24)
00004a7c  00001026  LBL   0x10 (D 16)
00004a80  0000008a  BNE   <fwd>
os.c  1591:       p->killed = 1;
00004a84  0000040e  LL    0x4 (D 4)
00004a88  00002c54  ADDI  0x2c (D 44)
00004a8c  0000003e  LBA 
00004a90  00000123  LI    0x1 (D 1)
00004a94  0000004a  SX  
os.c  1592:       // wake process from sleep if necessary
os.c  1593:       if (p->state == SLEEPING) p->state = RUNNABLE;
00004a98  0000040e  LL    0x4 (D 4)
00004a9c  0000141c  LX    0x14 (D 20)
00004aa0  0000023b  LBI   0x2 (D 2)
00004aa4  0000008a  BNE   <fwd>
00004aa8  0000040e  LL    0x4 (D 4)
00004aac  00001454  ADDI  0x14 (D 20)
00004ab0  0000003e  LBA 
00004ab4  00000323  LI    0x3 (D 3)
00004ab8  0000004a  SX  
os.c  1594:       splx(e);
00004abc  0000000e  LL    0x0 (D 0)
00004ac0  0000009d  PSHA
00004ac4  ffb5e005  JSR   0xffffb5e0 (TO 0xa8)
00004ac8  00000801  ENT   0x8 (D 8)
os.c  1595:       return 0;
00004acc  00000023  LI    0x0 (D 0)
00004ad0  00000802  LEV   0x8 (D 8)
os.c  1596:     }
os.c  1597:   }
os.c  1598:   splx(e);
00004ad4  0000040e  LL    0x4 (D 4)
00004ad8  ffff7c57  SUBI  0xffffff7c (D -132)
00004adc  00000440  SL    0x4 (D 4)
00004ae0  00210008  LEAG  0x2100 (D 8448)
00004ae4  0000003e  LBA 
00004ae8  0000040e  LL    0x4 (D 4)
00004aec  0000008d  BLTU  <fwd>
00004af0  0000000e  LL    0x0 (D 0)
00004af4  0000009d  PSHA
00004af8  ffb5ac05  JSR   0xffffb5ac (TO 0xa8)
00004afc  00000801  ENT   0x8 (D 8)
os.c  1599:   return -1;
00004b00  ffffff23  LI    0xffffffff (D -1)
00004b04  00000802  LEV   0x8 (D 8)
os.c  1600: }
os.c  1601: 
os.c  1602: // Wait for a child process to exit and return its pid.  Return -1 if this process has no children.
os.c  1603: int wait()
00004b08  00000802  LEV   0x8 (D 8)
os.c  1604: {
os.c  1605:   struct proc *p;
os.c  1606:   int havekids, pid, e = splhi();
os.c  1607: 
os.c  1608:   for (;;) { // scan through table looking for zombie children
00004b0c  fffff001  ENT   0xfffffff0 (D -16)
00004b10  ffb58c05  JSR   0xffffb58c (TO 0xa0)
00004b14  00000040  SL    0x0 (D 0)
os.c  1609:     havekids = 0;
00004b18  00000023  LI    0x0 (D 0)
00004b1c  00000840  SL    0x8 (D 8)
os.c  1610:     for (p = proc; p < &proc[NPROC]; p++) {
00004b20  00000008  LEAG  0x0 (D 0)
00004b24  00000c40  SL    0xc (D 12)
00004b28  00000003  JMP   <fwd>
os.c  1611:       if (p->parent != u) continue;
00004b2c  00000c0e  LL    0xc (D 12)
00004b30  00001c1c  LX    0x1c (D 28)
00004b34  0021002d  LBG   0x2100 (D 8448)
00004b38  00000088  BE    <fwd>
00004b3c  00000003  JMP   <fwd>
os.c  1612:       havekids = 1;
00004b40  00000123  LI    0x1 (D 1)
00004b44  00000840  SL    0x8 (D 8)
os.c  1613:       if (p->state == ZOMBIE) {
00004b48  00000c0e  LL    0xc (D 12)
00004b4c  0000141c  LX    0x14 (D 20)
00004b50  0000053b  LBI   0x5 (D 5)
00004b54  0000008a  BNE   <fwd>
os.c  1614:         pid = p->pid;
00004b58  00000c0e  LL    0xc (D 12)
00004b5c  0000181c  LX    0x18 (D 24)
00004b60  00000440  SL    0x4 (D 4)
os.c  1615:         kfree(p->kstack);
00004b64  00000c0e  LL    0xc (D 12)
00004b68  0000101c  LX    0x10 (D 16)
00004b6c  0000009d  PSHA
00004b70  ffb70405  JSR   0xffffb704 (TO 0x278)
00004b74  00000801  ENT   0x8 (D 8)
os.c  1616:         p->kstack = 0;
00004b78  00000c0e  LL    0xc (D 12)
00004b7c  00001054  ADDI  0x10 (D 16)
00004b80  0000003e  LBA 
00004b84  00000023  LI    0x0 (D 0)
00004b88  0000004a  SX  
os.c  1617:         freevm(p->pdir);
00004b8c  00000c0e  LL    0xc (D 12)
00004b90  00000c1c  LX    0xc (D 12)
00004b94  0000009d  PSHA
00004b98  0046c805  JSR   <fwd>
00004b9c  00000801  ENT   0x8 (D 8)
os.c  1618:         p->state = UNUSED;
00004ba0  00000c0e  LL    0xc (D 12)
00004ba4  00001454  ADDI  0x14 (D 20)
00004ba8  0000003e  LBA 
00004bac  00000023  LI    0x0 (D 0)
00004bb0  0000004a  SX  
os.c  1619:         p->pid = 0;
00004bb4  00000c0e  LL    0xc (D 12)
00004bb8  00001854  ADDI  0x18 (D 24)
00004bbc  0000003e  LBA 
00004bc0  00000023  LI    0x0 (D 0)
00004bc4  0000004a  SX  
os.c  1620:         p->parent = 0;
00004bc8  00000c0e  LL    0xc (D 12)
00004bcc  00001c54  ADDI  0x1c (D 28)
00004bd0  0000003e  LBA 
00004bd4  00000023  LI    0x0 (D 0)
00004bd8  0000004a  SX  
os.c  1621:         p->name[0] = 0;
00004bdc  00000c0e  LL    0xc (D 12)
00004be0  00007454  ADDI  0x74 (D 116)
00004be4  0000003e  LBA 
00004be8  00000023  LI    0x0 (D 0)
00004bec  0000004c  SXB 
os.c  1622:         p->killed = 0;
00004bf0  00000c0e  LL    0xc (D 12)
00004bf4  00002c54  ADDI  0x2c (D 44)
00004bf8  0000003e  LBA 
00004bfc  00000023  LI    0x0 (D 0)
00004c00  0000004a  SX  
os.c  1623:         splx(e);
00004c04  0000000e  LL    0x0 (D 0)
00004c08  0000009d  PSHA
00004c0c  ffb49805  JSR   0xffffb498 (TO 0xa8)
00004c10  00000801  ENT   0x8 (D 8)
os.c  1624:         return pid;
00004c14  0000040e  LL    0x4 (D 4)
00004c18  00001002  LEV   0x10 (D 16)
os.c  1625:       }
os.c  1626:     }
os.c  1627: 
os.c  1628:     // no point waiting if we don't have any children
os.c  1629:     if (!havekids || u->killed) {
00004c1c  00000c0e  LL    0xc (D 12)
00004c20  ffff7c57  SUBI  0xffffff7c (D -132)
00004c24  00000c40  SL    0xc (D 12)
00004c28  00210008  LEAG  0x2100 (D 8448)
00004c2c  0000003e  LBA 
00004c30  00000c0e  LL    0xc (D 12)
00004c34  0000008d  BLTU  <fwd>
00004c38  0000080e  LL    0x8 (D 8)
00004c3c  00000084  BZ    <fwd>
00004c40  00210015  LG    0x2100 (D 8448)
00004c44  00002c1c  LX    0x2c (D 44)
00004c48  00000084  BZ    <fwd>
os.c  1630:       splx(e);
00004c4c  0000000e  LL    0x0 (D 0)
00004c50  0000009d  PSHA
00004c54  ffb45005  JSR   0xffffb450 (TO 0xa8)
00004c58  00000801  ENT   0x8 (D 8)
os.c  1631:       return -1;
00004c5c  ffffff23  LI    0xffffffff (D -1)
00004c60  00001002  LEV   0x10 (D 16)
os.c  1632:     }
os.c  1633: 
os.c  1634:     // wait for children to exit.  (See wakeup call in exit.)
os.c  1635:     sleep(u);  // XXX DOC: wait-sleep
00004c64  00210015  LG    0x2100 (D 8448)
00004c68  0000009d  PSHA
00004c6c  00252c05  JSR   <fwd>
00004c70  00000801  ENT   0x8 (D 8)
os.c  1636:   }
os.c  1637: }
00004c74  fffea003  JMP   0xfffffea0 (TO 0x4b18)
os.c  1638: 
os.c  1639: // grow process by n bytes             XXX need to verify that u->sz is always at a 4 byte alignment  !!!!!
os.c  1640: int sbrk(int n)
00004c78  00001002  LEV   0x10 (D 16)
os.c  1641: {
os.c  1642:   uint osz, sz;
os.c  1643:   if (!n) return u->sz;
00004c7c  fffff801  ENT   0xfffffff8 (D -8)
00004c80  0000100e  LL    0x10 (D 16)
00004c84  00000086  BNZ   <fwd>
00004c88  00210015  LG    0x2100 (D 8448)
00004c8c  0000081c  LX    0x8 (D 8)
00004c90  00000802  LEV   0x8 (D 8)
os.c  1644:   osz = sz = u->sz;
00004c94  00210015  LG    0x2100 (D 8448)
00004c98  0000081c  LX    0x8 (D 8)
00004c9c  00000040  SL    0x0 (D 0)
00004ca0  00000440  SL    0x4 (D 4)
os.c  1645:   if (n > 0) {
00004ca4  00000023  LI    0x0 (D 0)
00004ca8  00001026  LBL   0x10 (D 16)
00004cac  0000008f  BGE   <fwd>
os.c  1646: //    printf("growproc(%d)\n",n);
os.c  1647:     if (!(sz = allocuvm(u->pdir, sz, sz + n, 0))) {
00004cb0  0000009e  PSHI  0x0 (D 0)
00004cb4  0000080e  LL    0x8 (D 8)
00004cb8  00001855  ADDL  0x18 (D 24)
00004cbc  0000009d  PSHA
00004cc0  0000100e  LL    0x10 (D 16)
00004cc4  0000009d  PSHA
00004cc8  00210015  LG    0x2100 (D 8448)
00004ccc  00000c1c  LX    0xc (D 12)
00004cd0  0000009d  PSHA
00004cd4  00435405  JSR   <fwd>
00004cd8  00002001  ENT   0x20 (D 32)
00004cdc  00000040  SL    0x0 (D 0)
00004ce0  00000086  BNZ   <fwd>
os.c  1648:       printf("bad growproc!!\n"); //XXX
00004ce4  0002cf08  LEAG  0x2cf (D 719)
00004ce8  0000009d  PSHA
00004cec  ffb6c805  JSR   0xffffb6c8 (TO 0x3b8)
00004cf0  00000801  ENT   0x8 (D 8)
os.c  1649:       return -1;
00004cf4  ffffff23  LI    0xffffffff (D -1)
00004cf8  00000802  LEV   0x8 (D 8)
os.c  1650:     }
os.c  1651:   } else {
00004cfc  00000003  JMP   <fwd>
os.c  1652: //    printf("shrinkproc(%d)\n",n);
os.c  1653: //    if (sz + n < KRESERVED)
os.c  1654:     if ((uint)(-n) > sz) { //XXX
00004d00  0000100e  LL    0x10 (D 16)
00004d04  ffffff5a  MULI  0xffffffff (D -1)
00004d08  0000003e  LBA 
00004d0c  0000000e  LL    0x0 (D 0)
00004d10  00000090  BGEU  <fwd>
os.c  1655:       printf("bad shrinkproc!!\n"); //XXX
00004d14  0002df08  LEAG  0x2df (D 735)
00004d18  0000009d  PSHA
00004d1c  ffb69805  JSR   0xffffb698 (TO 0x3b8)
00004d20  00000801  ENT   0x8 (D 8)
os.c  1656:       return -1;
00004d24  ffffff23  LI    0xffffffff (D -1)
00004d28  00000802  LEV   0x8 (D 8)
os.c  1657:     }
os.c  1658:     if (!(sz = deallocuvm(u->pdir, sz, sz + n))) return -1;
00004d2c  0000000e  LL    0x0 (D 0)
00004d30  00001055  ADDL  0x10 (D 16)
00004d34  0000009d  PSHA
00004d38  0000080e  LL    0x8 (D 8)
00004d3c  0000009d  PSHA
00004d40  00210015  LG    0x2100 (D 8448)
00004d44  00000c1c  LX    0xc (D 12)
00004d48  0000009d  PSHA
00004d4c  00000005  JSR   <fwd>
00004d50  00001801  ENT   0x18 (D 24)
00004d54  00000040  SL    0x0 (D 0)
00004d58  00000086  BNZ   <fwd>
00004d5c  ffffff23  LI    0xffffffff (D -1)
00004d60  00000802  LEV   0x8 (D 8)
os.c  1659:     pdir(V2P+(uint)(u->pdir));
00004d64  00210015  LG    0x2100 (D 8448)
00004d68  00000c1c  LX    0xc (D 12)
00004d6c  0000403b  LBI   0x40 (D 64)
00004d70  0000003c  LBHI  0x0 (D 0)
00004d74  00000053  ADD 
00004d78  0000009d  PSHA
00004d7c  ffb30805  JSR   0xffffb308 (TO 0x88)
00004d80  00000801  ENT   0x8 (D 8)
os.c  1660:   }
os.c  1661:   u->sz = sz;
00004d84  00210015  LG    0x2100 (D 8448)
00004d88  00000854  ADDI  0x8 (D 8)
00004d8c  0000003e  LBA 
00004d90  0000000e  LL    0x0 (D 0)
00004d94  0000004a  SX  
os.c  1662: //  pdir(V2P+(u->pdir));
os.c  1663:   return osz;
00004d98  0000040e  LL    0x4 (D 4)
00004d9c  00000802  LEV   0x8 (D 8)
os.c  1664: }
os.c  1665: 
os.c  1666: int ssleep(int n)
00004da0  00000802  LEV   0x8 (D 8)
os.c  1667: {
os.c  1668:   uint ticks0; int e = splhi();
os.c  1669: 
os.c  1670:   ticks0 = ticks;
00004da4  fffff801  ENT   0xfffffff8 (D -8)
00004da8  ffb2f405  JSR   0xffffb2f4 (TO 0xa0)
00004dac  00000040  SL    0x0 (D 0)
00004db0  00216c15  LG    0x216c (D 8556)
00004db4  00000440  SL    0x4 (D 4)
os.c  1671:   while (ticks - ticks0 < n) {
00004db8  00000003  JMP   <fwd>
os.c  1672:     if (u->killed) {
00004dbc  00210015  LG    0x2100 (D 8448)
00004dc0  00002c1c  LX    0x2c (D 44)
00004dc4  00000084  BZ    <fwd>
os.c  1673:       splx(e);
00004dc8  0000000e  LL    0x0 (D 0)
00004dcc  0000009d  PSHA
00004dd0  ffb2d405  JSR   0xffffb2d4 (TO 0xa8)
00004dd4  00000801  ENT   0x8 (D 8)
os.c  1674:       return -1;
00004dd8  ffffff23  LI    0xffffffff (D -1)
00004ddc  00000802  LEV   0x8 (D 8)
os.c  1675:     }
os.c  1676:     sleep(&ticks);
00004de0  00216c08  LEAG  0x216c (D 8556)
00004de4  0000009d  PSHA
00004de8  004c6c05  JSR   <fwd>
00004dec  00000801  ENT   0x8 (D 8)
os.c  1677:   }
os.c  1678:   splx(e);
00004df0  00216c15  LG    0x216c (D 8556)
00004df4  00000458  SUBL  0x4 (D 4)
00004df8  00001026  LBL   0x10 (D 16)
00004dfc  0000008d  BLTU  <fwd>
00004e00  0000000e  LL    0x0 (D 0)
00004e04  0000009d  PSHA
00004e08  ffb29c05  JSR   0xffffb29c (TO 0xa8)
00004e0c  00000801  ENT   0x8 (D 8)
os.c  1679:   return 0;
00004e10  00000023  LI    0x0 (D 0)
00004e14  00000802  LEV   0x8 (D 8)
os.c  1680: }
os.c  1681: 
os.c  1682: // XXX HACK CODE (and all wrong) to bootstrap initial network functionality
os.c  1683: enum { POLLIN = 1, POLLOUT = 2, POLLNVAL = 4 };
00004e18  00000802  LEV   0x8 (D 8)
os.c  1684: struct pollfd { int fd; short events, revents; };
os.c  1685: 
os.c  1686: int socket(int family, int type, int protocol)
os.c  1687: {
os.c  1688:   int fd, sd;
os.c  1689:   struct file *f;
os.c  1690: 
os.c  1691: //  printf("socket(family=%d, type=%d, protocol=%d)\n", family, type, protocol);
os.c  1692:   if (family != 2 || type != 1 || protocol != 0) return -1;
00004e1c  fffff001  ENT   0xfffffff0 (D -16)
00004e20  0000180e  LL    0x18 (D 24)
00004e24  0000023b  LBI   0x2 (D 2)
00004e28  0000008a  BNE   <fwd>
00004e2c  0000200e  LL    0x20 (D 32)
00004e30  0000013b  LBI   0x1 (D 1)
00004e34  004e288a  BNE   <fwd>
00004e38  0000280e  LL    0x28 (D 40)
00004e3c  0000003b  LBI   0x0 (D 0)
00004e40  00000088  BE    <fwd>
00004e44  ffffff23  LI    0xffffffff (D -1)
00004e48  00001002  LEV   0x10 (D 16)
os.c  1693: 
os.c  1694:   if (!(f = filealloc()) || (fd = fdalloc(f)) < 0) {
00004e4c  ffd7bc05  JSR   0xffffd7bc (TO 0x260c)
00004e50  00000440  SL    0x4 (D 4)
00004e54  00000084  BZ    <fwd>
00004e58  0000040e  LL    0x4 (D 4)
00004e5c  0000009d  PSHA
00004e60  ffd89005  JSR   0xffffd890 (TO 0x26f4)
00004e64  00000801  ENT   0x8 (D 8)
00004e68  00000c40  SL    0xc (D 12)
00004e6c  0000003b  LBI   0x0 (D 0)
00004e70  0000008f  BGE   <fwd>
os.c  1695:     if (f) fileclose(f);
00004e74  0000040e  LL    0x4 (D 4)
00004e78  00000084  BZ    <fwd>
00004e7c  0000040e  LL    0x4 (D 4)
00004e80  0000009d  PSHA
00004e84  ffddac05  JSR   0xffffddac (TO 0x2c34)
00004e88  00000801  ENT   0x8 (D 8)
os.c  1696:     return -1;
00004e8c  ffffff23  LI    0xffffffff (D -1)
00004e90  00001002  LEV   0x10 (D 16)
os.c  1697:   }
os.c  1698: 
os.c  1699:   if ((sd = sockopen(family, type, protocol)) < 0) { u->ofile[fd] = 0; fileclose(f); return sd; }
00004e94  0000280e  LL    0x28 (D 40)
00004e98  0000009d  PSHA
00004e9c  0000280e  LL    0x28 (D 40)
00004ea0  0000009d  PSHA
00004ea4  0000280e  LL    0x28 (D 40)
00004ea8  0000009d  PSHA
00004eac  ffdc0805  JSR   0xffffdc08 (TO 0x2ab8)
00004eb0  00001801  ENT   0x18 (D 24)
00004eb4  00000840  SL    0x8 (D 8)
00004eb8  0000003b  LBI   0x0 (D 0)
00004ebc  0000008f  BGE   <fwd>
00004ec0  00210015  LG    0x2100 (D 8448)
00004ec4  00003054  ADDI  0x30 (D 48)
00004ec8  0000009d  PSHA
00004ecc  0000140e  LL    0x14 (D 20)
00004ed0  0000045a  MULI  0x4 (D 4)
00004ed4  000000a1  POPB
00004ed8  00000053  ADD 
00004edc  0000003e  LBA 
00004ee0  00000023  LI    0x0 (D 0)
00004ee4  0000004a  SX  
00004ee8  0000040e  LL    0x4 (D 4)
00004eec  0000009d  PSHA
00004ef0  ffdd4005  JSR   0xffffdd40 (TO 0x2c34)
00004ef4  00000801  ENT   0x8 (D 8)
00004ef8  0000080e  LL    0x8 (D 8)
00004efc  00001002  LEV   0x10 (D 16)
os.c  1700: 
os.c  1701:   f->type = FD_SOCKET;
00004f00  00000323  LI    0x3 (D 3)
00004f04  00000426  LBL   0x4 (D 4)
00004f08  0000004a  SX  
os.c  1702:   f->readable = f->writable = 1;
00004f0c  0000040e  LL    0x4 (D 4)
00004f10  00000854  ADDI  0x8 (D 8)
00004f14  0000009d  PSHA
00004f18  00000c0e  LL    0xc (D 12)
00004f1c  00000954  ADDI  0x9 (D 9)
00004f20  0000003e  LBA 
00004f24  00000123  LI    0x1 (D 1)
00004f28  0000004c  SXB 
00004f2c  00001872  SHLI  0x18 (D 24)
00004f30  00001875  SHRI  0x18 (D 24)
00004f34  000000a1  POPB
00004f38  0000004c  SXB 
os.c  1703:   f->off = sd;
00004f3c  0000040e  LL    0x4 (D 4)
00004f40  00001454  ADDI  0x14 (D 20)
00004f44  0000003e  LBA 
00004f48  0000080e  LL    0x8 (D 8)
00004f4c  0000004a  SX  
os.c  1704:   return fd;
00004f50  00000c0e  LL    0xc (D 12)
00004f54  00001002  LEV   0x10 (D 16)
os.c  1705: }
os.c  1706: 
os.c  1707: int poll(struct pollfd *pfd, uint n, int msec)
00004f58  00001002  LEV   0x10 (D 16)
os.c  1708: {
os.c  1709:   int r, ev; struct file *f; struct pollfd *p, *pn;
os.c  1710:   if (n && !mvalid(pfd, n * sizeof(struct pollfd))) return -1;
00004f5c  ffffe801  ENT   0xffffffe8 (D -24)
00004f60  0000280e  LL    0x28 (D 40)
00004f64  00000084  BZ    <fwd>
00004f68  0000280e  LL    0x28 (D 40)
00004f6c  0000085a  MULI  0x8 (D 8)
00004f70  0000009d  PSHA
00004f74  0000280e  LL    0x28 (D 40)
00004f78  0000009d  PSHA
00004f7c  ffdabc05  JSR   0xffffdabc (TO 0x2a3c)
00004f80  00001001  ENT   0x10 (D 16)
00004f84  004f6486  BNZ   <fwd>
00004f88  ffffff23  LI    0xffffffff (D -1)
00004f8c  00001802  LEV   0x18 (D 24)
os.c  1711:   pn = &pfd[n];
00004f90  0000280e  LL    0x28 (D 40)
00004f94  0000085a  MULI  0x8 (D 8)
00004f98  00002055  ADDL  0x20 (D 32)
00004f9c  00000440  SL    0x4 (D 4)
os.c  1712:   for (;;)
os.c  1713:   {
os.c  1714:     r = 0;
00004fa0  00000023  LI    0x0 (D 0)
00004fa4  00001440  SL    0x14 (D 20)
os.c  1715:     for (p = pfd; p != pn; p++)
00004fa8  0000200e  LL    0x20 (D 32)
00004fac  00000840  SL    0x8 (D 8)
os.c  1716:     {
00004fb0  00000003  JMP   <fwd>
os.c  1717:       if (p->fd < 0) continue;
00004fb4  0000080e  LL    0x8 (D 8)
00004fb8  0000001c  LX  
00004fbc  0000003b  LBI   0x0 (D 0)
00004fc0  0000008f  BGE   <fwd>
00004fc4  00000003  JMP   <fwd>
os.c  1718:       ev = 0;
00004fc8  00000023  LI    0x0 (D 0)
00004fcc  00001040  SL    0x10 (D 16)
os.c  1719:       if (!(f = getf(p->fd))) ev = POLLNVAL;
00004fd0  0000080e  LL    0x8 (D 8)
00004fd4  0000001c  LX  
00004fd8  0000009d  PSHA
00004fdc  ffda9c05  JSR   0xffffda9c (TO 0x2a7c)
00004fe0  00000801  ENT   0x8 (D 8)
00004fe4  00000c40  SL    0xc (D 12)
00004fe8  00000086  BNZ   <fwd>
00004fec  00000423  LI    0x4 (D 4)
00004ff0  00001040  SL    0x10 (D 16)
os.c  1720:       else if (p->events & POLLIN) {
00004ff4  00000003  JMP   <fwd>
00004ff8  0000080e  LL    0x8 (D 8)
00004ffc  0000041d  LXS   0x4 (D 4)
00005000  00000169  ANDI  0x1 (D 1)
00005004  00000084  BZ    <fwd>
os.c  1721:         switch (f->type) {
00005008  00000c0e  LL    0xc (D 12)
0000500c  0000001c  LX  
00005010  00000003  JMP   <fwd>
os.c  1722:         case FD_PIPE: if (f->pipe->nwrite != f->pipe->nread || !f->pipe->writeopen) ev = POLLIN; break;
00005014  00000c0e  LL    0xc (D 12)
00005018  00000c1c  LX    0xc (D 12)
0000501c  000fa01c  LX    0xfa0 (D 4000)
00005020  0000009d  PSHA
00005024  0000140e  LL    0x14 (D 20)
00005028  00000c1c  LX    0xc (D 12)
0000502c  000fa41c  LX    0xfa4 (D 4004)
00005030  000000a1  POPB
00005034  0000008a  BNE   <fwd>
00005038  00000c0e  LL    0xc (D 12)
0000503c  00000c1c  LX    0xc (D 12)
00005040  000fac1c  LX    0xfac (D 4012)
00005044  00000086  BNZ   <fwd>
00005048  00000123  LI    0x1 (D 1)
0000504c  00001040  SL    0x10 (D 16)
00005050  00000003  JMP   <fwd>
os.c  1723:         case FD_SOCKET: if (sockpoll(f->off)) ev = POLLIN; break;
00005054  00000c0e  LL    0xc (D 12)
00005058  0000141c  LX    0x14 (D 20)
0000505c  0000009d  PSHA
00005060  ffdab005  JSR   0xffffdab0 (TO 0x2b14)
00005064  00000801  ENT   0x8 (D 8)
00005068  00000084  BZ    <fwd>
0000506c  00000123  LI    0x1 (D 1)
00005070  00001040  SL    0x10 (D 16)
00005074  00505003  JMP   <fwd>
os.c  1724:         case FD_INODE:
os.c  1725:           if ((f->ip->mode & S_IFMT) == S_IFCHR && f->ip->dir[0] == CONSOLE) {
00005078  00000c0e  LL    0xc (D 12)
0000507c  0000101c  LX    0x10 (D 16)
00005080  00000c1e  LXH   0xc (D 12)
00005084  00f00069  ANDI  0xf000 (D 61440)
00005088  0020003b  LBI   0x2000 (D 8192)
0000508c  0000008a  BNE   <fwd>
00005090  00000c0e  LL    0xc (D 12)
00005094  0000101c  LX    0x10 (D 16)
00005098  0000181c  LX    0x18 (D 24)
0000509c  0000013b  LBI   0x1 (D 1)
000050a0  00508c8a  BNE   <fwd>
os.c  1726:             ilock(f->ip);
000050a4  00000c0e  LL    0xc (D 12)
000050a8  0000101c  LX    0x10 (D 16)
000050ac  0000009d  PSHA
000050b0  ffc0f405  JSR   0xffffc0f4 (TO 0x11a8)
000050b4  00000801  ENT   0x8 (D 8)
os.c  1727:             if (input.r != input.w) ev = POLLIN;
000050b8  0021f415  LG    0x21f4 (D 8692)
000050bc  0021f82d  LBG   0x21f8 (D 8696)
000050c0  00000088  BE    <fwd>
000050c4  00000123  LI    0x1 (D 1)
000050c8  00001040  SL    0x10 (D 16)
os.c  1728:             iunlock(f->ip);
000050cc  00000c0e  LL    0xc (D 12)
000050d0  0000101c  LX    0x10 (D 16)
000050d4  0000009d  PSHA
000050d8  ffc26405  JSR   0xffffc264 (TO 0x1340)
000050dc  00000801  ENT   0x8 (D 8)
os.c  1729:           }
os.c  1730:         }
os.c  1731:       }
000050e0  00507403  JMP   <fwd>
000050e4  0000043b  LBI   0x4 (D 4)
000050e8  0050e090  BGEU  <fwd>
000050ec  0002f404  JMPI  0x2f4 (D 756)
os.c  1732:       if (p->revents = ev) { msec = 0; r++; }
000050f0  0000080e  LL    0x8 (D 8)
000050f4  00000654  ADDI  0x6 (D 6)
000050f8  0000003e  LBA 
000050fc  0000100e  LL    0x10 (D 16)
00005100  0000004b  SXH 
00005104  00001072  SHLI  0x10 (D 16)
00005108  00001075  SHRI  0x10 (D 16)
0000510c  00000084  BZ    <fwd>
00005110  00000023  LI    0x0 (D 0)
00005114  00003040  SL    0x30 (D 48)
00005118  0000140e  LL    0x14 (D 20)
0000511c  ffffff57  SUBI  0xffffffff (D -1)
00005120  00001440  SL    0x14 (D 20)
os.c  1733:     }
os.c  1734:     if (!msec) break;
00005124  0000080e  LL    0x8 (D 8)
00005128  fffff857  SUBI  0xfffffff8 (D -8)
0000512c  00000840  SL    0x8 (D 8)
00005130  0000080e  LL    0x8 (D 8)
00005134  00000426  LBL   0x4 (D 4)
00005138  0000008a  BNE   <fwd>
0000513c  0000300e  LL    0x30 (D 48)
00005140  00000086  BNZ   <fwd>
00005144  00000003  JMP   <fwd>
os.c  1735:     ssleep(1);
00005148  0000019e  PSHI  0x1 (D 1)
0000514c  fffc5405  JSR   0xfffffc54 (TO 0x4da4)
00005150  00000801  ENT   0x8 (D 8)
os.c  1736:     if (msec > 100) msec -= 100; // XXX this wrongly assumes one tick equals 100ms
00005154  00006423  LI    0x64 (D 100)
00005158  00003026  LBL   0x30 (D 48)
0000515c  0000008f  BGE   <fwd>
00005160  0000300e  LL    0x30 (D 48)
00005164  00006457  SUBI  0x64 (D 100)
00005168  00003040  SL    0x30 (D 48)
os.c  1737:     else if (msec > 0) msec = 0;
0000516c  00000003  JMP   <fwd>
00005170  00000023  LI    0x0 (D 0)
00005174  00003026  LBL   0x30 (D 48)
00005178  0000008f  BGE   <fwd>
0000517c  00000023  LI    0x0 (D 0)
00005180  00003040  SL    0x30 (D 48)
os.c  1738:   }
os.c  1739:   return r;
00005184  fffe1803  JMP   0xfffffe18 (TO 0x4fa0)
00005188  0000140e  LL    0x14 (D 20)
0000518c  00001802  LEV   0x18 (D 24)
os.c  1740: }
os.c  1741: // XXX int connect(struct file *s, struct sockaddr *name, uint namelen)
os.c  1742: int connect(int fd, uint *addr, int addrlen)
00005190  00001802  LEV   0x18 (D 24)
os.c  1743: {
os.c  1744:   struct file *f;
os.c  1745:   if (!(f = getf(fd)) || addrlen < 8 || !mvalid(addr, addrlen)) return -1;
00005194  fffff801  ENT   0xfffffff8 (D -8)
00005198  0000100e  LL    0x10 (D 16)
0000519c  0000009d  PSHA
000051a0  ffd8d805  JSR   0xffffd8d8 (TO 0x2a7c)
000051a4  00000801  ENT   0x8 (D 8)
000051a8  00000440  SL    0x4 (D 4)
000051ac  00000084  BZ    <fwd>
000051b0  0000200e  LL    0x20 (D 32)
000051b4  0000083b  LBI   0x8 (D 8)
000051b8  0051ac8c  BLT   <fwd>
000051bc  0000200e  LL    0x20 (D 32)
000051c0  0000009d  PSHA
000051c4  0000200e  LL    0x20 (D 32)
000051c8  0000009d  PSHA
000051cc  ffd86c05  JSR   0xffffd86c (TO 0x2a3c)
000051d0  00001001  ENT   0x10 (D 16)
000051d4  00000086  BNZ   <fwd>
000051d8  ffffff23  LI    0xffffffff (D -1)
000051dc  00000802  LEV   0x8 (D 8)
os.c  1746:   return sockconnect(f->off, addr[0], addr[1]);
000051e0  0000180e  LL    0x18 (D 24)
000051e4  0000041c  LX    0x4 (D 4)
000051e8  0000009d  PSHA
000051ec  0000200e  LL    0x20 (D 32)
000051f0  0000001c  LX  
000051f4  0000009d  PSHA
000051f8  0000140e  LL    0x14 (D 20)
000051fc  0000141c  LX    0x14 (D 20)
00005200  0000009d  PSHA
00005204  ffd8d005  JSR   0xffffd8d0 (TO 0x2ad8)
00005208  00001801  ENT   0x18 (D 24)
0000520c  00000802  LEV   0x8 (D 8)
os.c  1747: }
os.c  1748: 
os.c  1749: int sockbind(int fd, uint family_port, uint addr) { asm(LL,8); asm(LBL,16); asm(LCL,24); asm(NET7); }
00005210  00000802  LEV   0x8 (D 8)
00005214  0000080e  LL    0x8 (D 8)
00005218  00001026  LBL   0x10 (D 16)
0000521c  000018ac  LCL   0x18 (D 24)
00005220  000000b9  NET7
os.c  1750: int bind(int fd, uint *addr, int addrlen)
00005224  00000002  LEV   0x0 (D 0)
os.c  1751: {
os.c  1752:   struct file *f;
os.c  1753:   if (!(f = getf(fd)) || addrlen < 8 || !mvalid(addr, addrlen)) return -1;
00005228  fffff801  ENT   0xfffffff8 (D -8)
0000522c  0000100e  LL    0x10 (D 16)
00005230  0000009d  PSHA
00005234  ffd84405  JSR   0xffffd844 (TO 0x2a7c)
00005238  00000801  ENT   0x8 (D 8)
0000523c  00000440  SL    0x4 (D 4)
00005240  00000084  BZ    <fwd>
00005244  0000200e  LL    0x20 (D 32)
00005248  0000083b  LBI   0x8 (D 8)
0000524c  0052408c  BLT   <fwd>
00005250  0000200e  LL    0x20 (D 32)
00005254  0000009d  PSHA
00005258  0000200e  LL    0x20 (D 32)
0000525c  0000009d  PSHA
00005260  ffd7d805  JSR   0xffffd7d8 (TO 0x2a3c)
00005264  00001001  ENT   0x10 (D 16)
00005268  00000086  BNZ   <fwd>
0000526c  ffffff23  LI    0xffffffff (D -1)
00005270  00000802  LEV   0x8 (D 8)
os.c  1754:   return sockbind(f->off, addr[0], addr[1]);
00005274  0000180e  LL    0x18 (D 24)
00005278  0000041c  LX    0x4 (D 4)
0000527c  0000009d  PSHA
00005280  0000200e  LL    0x20 (D 32)
00005284  0000001c  LX  
00005288  0000009d  PSHA
0000528c  0000140e  LL    0x14 (D 20)
00005290  0000141c  LX    0x14 (D 20)
00005294  0000009d  PSHA
00005298  ffff7805  JSR   0xffffff78 (TO 0x5214)
0000529c  00001801  ENT   0x18 (D 24)
000052a0  00000802  LEV   0x8 (D 8)
os.c  1755: }
os.c  1756: int socklisten() { asm(LL,8); asm(LBL,16); asm(NET8); }
000052a4  00000802  LEV   0x8 (D 8)
000052a8  0000080e  LL    0x8 (D 8)
000052ac  00001026  LBL   0x10 (D 16)
000052b0  000000ba  NET8
os.c  1757: int listen(int fd, int len)
000052b4  00000002  LEV   0x0 (D 0)
os.c  1758: {
os.c  1759:   struct file *f;
os.c  1760:   if (!(f = getf(fd))) return -1;
000052b8  fffff801  ENT   0xfffffff8 (D -8)
000052bc  0000100e  LL    0x10 (D 16)
000052c0  0000009d  PSHA
000052c4  ffd7b405  JSR   0xffffd7b4 (TO 0x2a7c)
000052c8  00000801  ENT   0x8 (D 8)
000052cc  00000440  SL    0x4 (D 4)
000052d0  00000086  BNZ   <fwd>
000052d4  ffffff23  LI    0xffffffff (D -1)
000052d8  00000802  LEV   0x8 (D 8)
os.c  1761:   return socklisten(f->off, len);
000052dc  0000180e  LL    0x18 (D 24)
000052e0  0000009d  PSHA
000052e4  00000c0e  LL    0xc (D 12)
000052e8  0000141c  LX    0x14 (D 20)
000052ec  0000009d  PSHA
000052f0  ffffb405  JSR   0xffffffb4 (TO 0x52a8)
000052f4  00001001  ENT   0x10 (D 16)
000052f8  00000802  LEV   0x8 (D 8)
os.c  1762: }
os.c  1763: int sockaccept() { asm(LL,8); asm(LBL,16); asm(LCL,24); asm(NET9); }
000052fc  00000802  LEV   0x8 (D 8)
00005300  0000080e  LL    0x8 (D 8)
00005304  00001026  LBL   0x10 (D 16)
00005308  000018ac  LCL   0x18 (D 24)
0000530c  000000bb  NET9
os.c  1764: int accept(int fd, uint *addr, int *addrlen) // XXXX params!!!! accept(int,*|0,*|0)
00005310  00000002  LEV   0x0 (D 0)
os.c  1765: {
os.c  1766:   int sd;
os.c  1767:   struct file *f;
os.c  1768:   if (!(f = getf(fd))) return -1;
00005314  fffff801  ENT   0xfffffff8 (D -8)
00005318  0000100e  LL    0x10 (D 16)
0000531c  0000009d  PSHA
00005320  ffd75805  JSR   0xffffd758 (TO 0x2a7c)
00005324  00000801  ENT   0x8 (D 8)
00005328  00000040  SL    0x0 (D 0)
0000532c  00000086  BNZ   <fwd>
00005330  ffffff23  LI    0xffffffff (D -1)
00005334  00000802  LEV   0x8 (D 8)
os.c  1769:   
os.c  1770:   while (!sockpoll(f->off)) ssleep(1); // XXX
00005338  00000003  JMP   <fwd>
0000533c  0000019e  PSHI  0x1 (D 1)
00005340  fffa6005  JSR   0xfffffa60 (TO 0x4da4)
00005344  00000801  ENT   0x8 (D 8)
os.c  1771: 
os.c  1772:   if ((sd = sockaccept(f->off, 0, 0)) < 0) return sd; // XXX null params for now
00005348  0000000e  LL    0x0 (D 0)
0000534c  0000141c  LX    0x14 (D 20)
00005350  0000009d  PSHA
00005354  ffd7bc05  JSR   0xffffd7bc (TO 0x2b14)
00005358  00000801  ENT   0x8 (D 8)
0000535c  00000084  BZ    <fwd>
00005360  0000009e  PSHI  0x0 (D 0)
00005364  0000009e  PSHI  0x0 (D 0)
00005368  0000100e  LL    0x10 (D 16)
0000536c  0000141c  LX    0x14 (D 20)
00005370  0000009d  PSHA
00005374  ffff8805  JSR   0xffffff88 (TO 0x5300)
00005378  00001801  ENT   0x18 (D 24)
0000537c  00000440  SL    0x4 (D 4)
00005380  0000003b  LBI   0x0 (D 0)
00005384  0000008f  BGE   <fwd>
00005388  0000040e  LL    0x4 (D 4)
0000538c  00000802  LEV   0x8 (D 8)
os.c  1773:   
os.c  1774:   if (!(f = filealloc()) || (fd = fdalloc(f)) < 0) { // XXX do this before sockaccept?
00005390  ffd27805  JSR   0xffffd278 (TO 0x260c)
00005394  00000040  SL    0x0 (D 0)
00005398  00000084  BZ    <fwd>
0000539c  0000000e  LL    0x0 (D 0)
000053a0  0000009d  PSHA
000053a4  ffd34c05  JSR   0xffffd34c (TO 0x26f4)
000053a8  00000801  ENT   0x8 (D 8)
000053ac  00001040  SL    0x10 (D 16)
000053b0  0000003b  LBI   0x0 (D 0)
000053b4  0000008f  BGE   <fwd>
os.c  1775:     if (f) fileclose(f);
000053b8  0000000e  LL    0x0 (D 0)
000053bc  00000084  BZ    <fwd>
000053c0  0000000e  LL    0x0 (D 0)
000053c4  0000009d  PSHA
000053c8  ffd86805  JSR   0xffffd868 (TO 0x2c34)
000053cc  00000801  ENT   0x8 (D 8)
os.c  1776:     return -1;
000053d0  ffffff23  LI    0xffffffff (D -1)
000053d4  00000802  LEV   0x8 (D 8)
os.c  1777:   }
os.c  1778: 
os.c  1779:   f->type = FD_SOCKET;
000053d8  00000323  LI    0x3 (D 3)
000053dc  00000026  LBL   0x0 (D 0)
000053e0  0000004a  SX  
os.c  1780:   f->readable = f->writable = 1;
000053e4  0000000e  LL    0x0 (D 0)
000053e8  00000854  ADDI  0x8 (D 8)
000053ec  0000009d  PSHA
000053f0  0000080e  LL    0x8 (D 8)
000053f4  00000954  ADDI  0x9 (D 9)
000053f8  0000003e  LBA 
000053fc  00000123  LI    0x1 (D 1)
00005400  0000004c  SXB 
00005404  00001872  SHLI  0x18 (D 24)
00005408  00001875  SHRI  0x18 (D 24)
0000540c  000000a1  POPB
00005410  0000004c  SXB 
os.c  1781:   f->off = sd;
00005414  0000000e  LL    0x0 (D 0)
00005418  00001454  ADDI  0x14 (D 20)
0000541c  0000003e  LBA 
00005420  0000040e  LL    0x4 (D 4)
00005424  0000004a  SX  
os.c  1782:   return fd;
00005428  0000100e  LL    0x10 (D 16)
0000542c  00000802  LEV   0x8 (D 8)
os.c  1783: }
os.c  1784: 
os.c  1785: // *** end of syscalls ***
os.c  1786: 
os.c  1787: // sleep on channel
os.c  1788: sleep(void *chan)
00005430  00000802  LEV   0x8 (D 8)
os.c  1789: {
os.c  1790:   u->chan = chan;
00005434  00210015  LG    0x2100 (D 8448)
00005438  00002854  ADDI  0x28 (D 40)
0000543c  0000003e  LBA 
00005440  0000080e  LL    0x8 (D 8)
00005444  0000004a  SX  
os.c  1791:   u->state = SLEEPING;
00005448  00210015  LG    0x2100 (D 8448)
0000544c  00001454  ADDI  0x14 (D 20)
00005450  0000003e  LBA 
00005454  00000223  LI    0x2 (D 2)
00005458  0000004a  SX  
os.c  1792:   sched();
0000545c  004a4405  JSR   <fwd>
os.c  1793:   // tidy up
os.c  1794:   u->chan = 0;
00005460  00210015  LG    0x2100 (D 8448)
00005464  00002854  ADDI  0x28 (D 40)
00005468  0000003e  LBA 
0000546c  00000023  LI    0x0 (D 0)
00005470  0000004a  SX  
os.c  1795: }
os.c  1796: 
os.c  1797: // wake up all processes sleeping on chan
os.c  1798: wakeup(void *chan)
00005474  00000002  LEV   0x0 (D 0)
os.c  1799: {
os.c  1800:   struct proc *p;
os.c  1801:   for (p = proc; p < &proc[NPROC]; p++)
00005478  fffff801  ENT   0xfffffff8 (D -8)
0000547c  00000008  LEAG  0x0 (D 0)
00005480  00000440  SL    0x4 (D 4)
os.c  1802:     if (p->state == SLEEPING && p->chan == chan) p->state = RUNNABLE;
00005484  00000003  JMP   <fwd>
00005488  0000040e  LL    0x4 (D 4)
0000548c  0000141c  LX    0x14 (D 20)
00005490  0000023b  LBI   0x2 (D 2)
00005494  0000008a  BNE   <fwd>
00005498  0000040e  LL    0x4 (D 4)
0000549c  0000281c  LX    0x28 (D 40)
000054a0  00001026  LBL   0x10 (D 16)
000054a4  0054948a  BNE   <fwd>
000054a8  0000040e  LL    0x4 (D 4)
000054ac  00001454  ADDI  0x14 (D 20)
000054b0  0000003e  LBA 
000054b4  00000323  LI    0x3 (D 3)
000054b8  0000004a  SX  
os.c  1803: }
000054bc  0000040e  LL    0x4 (D 4)
000054c0  ffff7c57  SUBI  0xffffff7c (D -132)
000054c4  00000440  SL    0x4 (D 4)
000054c8  00210008  LEAG  0x2100 (D 8448)
000054cc  0000003e  LBA 
000054d0  0000040e  LL    0x4 (D 4)
000054d4  0000008d  BLTU  <fwd>
os.c  1804: 
os.c  1805: // a forked child's very first scheduling will swtch here
os.c  1806: forkret()
000054d8  00000802  LEV   0x8 (D 8)
os.c  1807: {
os.c  1808:   asm(POPA); asm(SUSP);
000054dc  000000a3  POPA
000054e0  000000ab  SUSP
os.c  1809:   asm(POPG);
000054e4  000000b2  POPG
os.c  1810:   asm(POPF);
000054e8  000000a2  POPF
os.c  1811:   asm(POPC);
000054ec  000000af  POPC
os.c  1812:   asm(POPB);
000054f0  000000a1  POPB
os.c  1813:   asm(POPA);
000054f4  000000a3  POPA
os.c  1814:   asm(RTI);
000054f8  00000098  RTI 
os.c  1815: }
os.c  1816: 
os.c  1817: // Look in the process table for an UNUSED proc.  If found, change state to EMBRYO and initialize
os.c  1818: // state required to run in the kernel.  Otherwise return 0.
os.c  1819: struct proc *allocproc()
000054fc  00000002  LEV   0x0 (D 0)
os.c  1820: {
os.c  1821:   struct proc *p; char *sp; int e = splhi();
os.c  1822: 
os.c  1823:   for (p = proc; p < &proc[NPROC]; p++)
00005500  fffff001  ENT   0xfffffff0 (D -16)
00005504  ffab9805  JSR   0xffffab98 (TO 0xa0)
00005508  00000440  SL    0x4 (D 4)
0000550c  00000008  LEAG  0x0 (D 0)
00005510  00000c40  SL    0xc (D 12)
os.c  1824:     if (p->state == UNUSED) goto found;
00005514  00000003  JMP   <fwd>
00005518  00000c0e  LL    0xc (D 12)
0000551c  0000141c  LX    0x14 (D 20)
00005520  0000003b  LBI   0x0 (D 0)
00005524  0000008a  BNE   <fwd>
00005528  00000003  JMP   <fwd>
os.c  1825:   splx(e);
0000552c  00000c0e  LL    0xc (D 12)
00005530  ffff7c57  SUBI  0xffffff7c (D -132)
00005534  00000c40  SL    0xc (D 12)
00005538  00210008  LEAG  0x2100 (D 8448)
0000553c  0000003e  LBA 
00005540  00000c0e  LL    0xc (D 12)
00005544  0000008d  BLTU  <fwd>
00005548  0000040e  LL    0x4 (D 4)
0000554c  0000009d  PSHA
00005550  ffab5405  JSR   0xffffab54 (TO 0xa8)
00005554  00000801  ENT   0x8 (D 8)
os.c  1826:   return 0;
00005558  00000023  LI    0x0 (D 0)
0000555c  00001002  LEV   0x10 (D 16)
os.c  1827: 
os.c  1828: found:
os.c  1829:   p->state = EMBRYO;
00005560  00000c0e  LL    0xc (D 12)
00005564  00001454  ADDI  0x14 (D 20)
00005568  0000003e  LBA 
0000556c  00000123  LI    0x1 (D 1)
00005570  0000004a  SX  
os.c  1830:   p->pid = nextpid++;
00005574  00000c0e  LL    0xc (D 12)
00005578  00001854  ADDI  0x18 (D 24)
0000557c  0000009d  PSHA
00005580  0337e815  LG    0x337e8 (D 210920)
00005584  ffffff57  SUBI  0xffffffff (D -1)
00005588  0337e845  SG    0x337e8 (D 210920)
0000558c  ffffff54  ADDI  0xffffffff (D -1)
00005590  000000a1  POPB
00005594  0000004a  SX  
os.c  1831:   splx(e);
00005598  0000040e  LL    0x4 (D 4)
0000559c  0000009d  PSHA
000055a0  ffab0405  JSR   0xffffab04 (TO 0xa8)
000055a4  00000801  ENT   0x8 (D 8)
os.c  1832: 
os.c  1833:   // allocate kernel stack leaving room for trap frame
os.c  1834:   sp = (p->kstack = kalloc()) + PAGE - sizeof(struct trapframe);
000055a8  00000c0e  LL    0xc (D 12)
000055ac  00001054  ADDI  0x10 (D 16)
000055b0  0000009d  PSHA
000055b4  ffac3405  JSR   0xffffac34 (TO 0x1ec)
000055b8  000000a1  POPB
000055bc  0000004a  SX  
000055c0  00100054  ADDI  0x1000 (D 4096)
000055c4  ffffc054  ADDI  0xffffffc0 (D -64)
000055c8  00000840  SL    0x8 (D 8)
os.c  1835:   p->tf = (struct trapframe *)sp;
000055cc  00000c0e  LL    0xc (D 12)
000055d0  00002054  ADDI  0x20 (D 32)
000055d4  0000003e  LBA 
000055d8  0000080e  LL    0x8 (D 8)
000055dc  0000004a  SX  
os.c  1836:   
os.c  1837:   // set up new context to start executing at forkret
os.c  1838:   sp -= 8;
000055e0  0000080e  LL    0x8 (D 8)
000055e4  00000857  SUBI  0x8 (D 8)
000055e8  00000840  SL    0x8 (D 8)
os.c  1839:   *(uint *)sp = (uint)forkret;
000055ec  fffeec08  LEAG  0xfffffeec (D -276)
000055f0  00000826  LBL   0x8 (D 8)
000055f4  0000004a  SX  
os.c  1840: 
os.c  1841:   p->context = sp;
000055f8  00000c0e  LL    0xc (D 12)
000055fc  00002454  ADDI  0x24 (D 36)
00005600  0000003e  LBA 
00005604  0000080e  LL    0x8 (D 8)
00005608  0000004a  SX  
os.c  1842:   return p;
0000560c  00000c0e  LL    0xc (D 12)
00005610  00001002  LEV   0x10 (D 16)
os.c  1843: }
os.c  1844: 
os.c  1845: // hand-craft the first process
os.c  1846: init_start()
00005614  00001002  LEV   0x10 (D 16)
os.c  1847: {
os.c  1848:   char cmd[10], *argv[2];
os.c  1849:   
os.c  1850:   // no data/bss segment
os.c  1851:   cmd[0] = '/'; cmd[1] = 'e'; cmd[2] = 't'; cmd[3] = 'c'; cmd[4] = '/';
00005618  ffffe801  ENT   0xffffffe8 (D -24)
0000561c  00002f23  LI    0x2f (D 47)
00005620  00000e42  SLB   0xe (D 14)
00005624  00006523  LI    0x65 (D 101)
00005628  00000f42  SLB   0xf (D 15)
0000562c  00007423  LI    0x74 (D 116)
00005630  00001042  SLB   0x10 (D 16)
00005634  00006323  LI    0x63 (D 99)
00005638  00001142  SLB   0x11 (D 17)
0000563c  00002f23  LI    0x2f (D 47)
00005640  00001242  SLB   0x12 (D 18)
os.c  1852:   cmd[5] = 'i'; cmd[6] = 'n'; cmd[7] = 'i'; cmd[8] = 't'; cmd[9] = 0;
00005644  00006923  LI    0x69 (D 105)
00005648  00001342  SLB   0x13 (D 19)
0000564c  00006e23  LI    0x6e (D 110)
00005650  00001442  SLB   0x14 (D 20)
00005654  00006923  LI    0x69 (D 105)
00005658  00001542  SLB   0x15 (D 21)
0000565c  00007423  LI    0x74 (D 116)
00005660  00001642  SLB   0x16 (D 22)
00005664  00000023  LI    0x0 (D 0)
00005668  00001742  SLB   0x17 (D 23)
os.c  1853:   
os.c  1854:   argv[0] = cmd;
0000566c  00000e07  LEA   0xe (D 14)
00005670  00000440  SL    0x4 (D 4)
os.c  1855:   argv[1] = 0;
00005674  00000023  LI    0x0 (D 0)
00005678  00000840  SL    0x8 (D 8)
os.c  1856: 
os.c  1857:   if (!init_fork()) init_exec(cmd, argv);
0000567c  00000005  JSR   <fwd>
00005680  00000086  BNZ   <fwd>
00005684  00000407  LEA   0x4 (D 4)
00005688  0000009d  PSHA
0000568c  00001607  LEA   0x16 (D 22)
00005690  0000009d  PSHA
00005694  00000005  JSR   <fwd>
00005698  00001001  ENT   0x10 (D 16)
os.c  1858:   init_exit(0); // become the idle task
0000569c  0000009e  PSHI  0x0 (D 0)
000056a0  00000005  JSR   <fwd>
000056a4  00000801  ENT   0x8 (D 8)
os.c  1859: }
os.c  1860: init_fork() { asm(TRAP,S_fork); }
000056a8  00001802  LEV   0x18 (D 24)
000056ac  000001a9  TRAP  0x1 (D 1)
os.c  1861: init_exec() { asm(LL,8); asm(LBL,16); asm(TRAP,S_exec); }
000056b0  00000002  LEV   0x0 (D 0)
000056b4  0000080e  LL    0x8 (D 8)
000056b8  00001026  LBL   0x10 (D 16)
000056bc  000009a9  TRAP  0x9 (D 9)
os.c  1862: init_exit() { asm(LL,8); asm(TRAP,S_exit); }
000056c0  00000002  LEV   0x0 (D 0)
000056c4  0000080e  LL    0x8 (D 8)
000056c8  000002a9  TRAP  0x2 (D 2)
os.c  1863: 
os.c  1864: userinit()
000056cc  00000002  LEV   0x0 (D 0)
os.c  1865: {
os.c  1866:   char *mem;
os.c  1867:   init = allocproc();
000056d0  fffff801  ENT   0xfffffff8 (D -8)
000056d4  fffe2805  JSR   0xfffffe28 (TO 0x5500)
000056d8  00210445  SG    0x2104 (D 8452)
os.c  1868:   init->pdir = memcpy(kalloc(), kpdir, PAGE);
000056dc  00210415  LG    0x2104 (D 8452)
000056e0  00000c54  ADDI  0xc (D 12)
000056e4  0000009d  PSHA
000056e8  0010009e  PSHI  0x1000 (D 4096)
000056ec  00216815  LG    0x2168 (D 8552)
000056f0  0000009d  PSHA
000056f4  ffaaf405  JSR   0xffffaaf4 (TO 0x1ec)
000056f8  0000009d  PSHA
000056fc  ffa90005  JSR   0xffffa900 (TO 0x0)
00005700  00001801  ENT   0x18 (D 24)
00005704  000000a1  POPB
00005708  0000004a  SX  
os.c  1869:   mem = memcpy(memset(kalloc(), 0, PAGE), (char *)init_start, (uint)userinit - (uint)init_start);
0000570c  ffff0808  LEAG  0xffffff08 (D -248)
00005710  0000009d  PSHA
00005714  ffffb808  LEAG  0xffffffb8 (D -72)
00005718  000000a1  POPB
0000571c  00000056  SUB 
00005720  0000009d  PSHA
00005724  fffef008  LEAG  0xfffffef0 (D -272)
00005728  0000009d  PSHA
0000572c  0010009e  PSHI  0x1000 (D 4096)
00005730  0000009e  PSHI  0x0 (D 0)
00005734  ffaab405  JSR   0xffffaab4 (TO 0x1ec)
00005738  0000009d  PSHA
0000573c  ffa8d805  JSR   0xffffa8d8 (TO 0x18)
00005740  00001801  ENT   0x18 (D 24)
00005744  0000009d  PSHA
00005748  ffa8b405  JSR   0xffffa8b4 (TO 0x0)
0000574c  00001801  ENT   0x18 (D 24)
00005750  00000440  SL    0x4 (D 4)
os.c  1870:   mappage(init->pdir, 0, V2P+mem, PTE_P | PTE_W | PTE_U);
00005754  0000079e  PSHI  0x7 (D 7)
00005758  00000c0e  LL    0xc (D 12)
0000575c  0000403b  LBI   0x40 (D 64)
00005760  0000003c  LBHI  0x0 (D 0)
00005764  00000053  ADD 
00005768  0000009d  PSHA
0000576c  0000009e  PSHI  0x0 (D 0)
00005770  00210415  LG    0x2104 (D 8452)
00005774  00000c1c  LX    0xc (D 12)
00005778  0000009d  PSHA
0000577c  0043b405  JSR   <fwd>
00005780  00002001  ENT   0x20 (D 32)
os.c  1871: 
os.c  1872:   init->sz = PAGE;
00005784  00210415  LG    0x2104 (D 8452)
00005788  00000854  ADDI  0x8 (D 8)
0000578c  0000003e  LBA 
00005790  00100023  LI    0x1000 (D 4096)
00005794  0000004a  SX  
os.c  1873:   init->tf->sp = PAGE;
00005798  00210415  LG    0x2104 (D 8452)
0000579c  0000201c  LX    0x20 (D 32)
000057a0  0000003e  LBA 
000057a4  00100023  LI    0x1000 (D 4096)
000057a8  0000004a  SX  
os.c  1874:   init->tf->fc = USER;
000057ac  00210415  LG    0x2104 (D 8452)
000057b0  0000201c  LX    0x20 (D 32)
000057b4  00003054  ADDI  0x30 (D 48)
000057b8  0000003e  LBA 
000057bc  00001023  LI    0x10 (D 16)
000057c0  0000004a  SX  
os.c  1875:   init->tf->pc = 0;
000057c4  00210415  LG    0x2104 (D 8452)
000057c8  0000201c  LX    0x20 (D 32)
000057cc  00003854  ADDI  0x38 (D 56)
000057d0  0000003e  LBA 
000057d4  00000023  LI    0x0 (D 0)
000057d8  0000004a  SX  
os.c  1876:   safestrcpy(init->name, "initcode", sizeof(init->name));
000057dc  0000109e  PSHI  0x10 (D 16)
000057e0  00030408  LEAG  0x304 (D 772)
000057e4  0000009d  PSHA
000057e8  00210415  LG    0x2104 (D 8452)
000057ec  00007454  ADDI  0x74 (D 116)
000057f0  0000009d  PSHA
000057f4  ffa98005  JSR   0xffffa980 (TO 0x178)
000057f8  00001801  ENT   0x18 (D 24)
os.c  1877:   init->cwd = namei("/");
000057fc  00210415  LG    0x2104 (D 8452)
00005800  00007054  ADDI  0x70 (D 112)
00005804  0000009d  PSHA
00005808  00030d08  LEAG  0x30d (D 781)
0000580c  0000009d  PSHA
00005810  ffc90005  JSR   0xffffc900 (TO 0x2114)
00005814  00000801  ENT   0x8 (D 8)
00005818  000000a1  POPB
0000581c  0000004a  SX  
os.c  1878:   init->state = RUNNABLE;
00005820  00210415  LG    0x2104 (D 8452)
00005824  00001454  ADDI  0x14 (D 20)
00005828  0000003e  LBA 
0000582c  00000323  LI    0x3 (D 3)
00005830  0000004a  SX  
os.c  1879: }
os.c  1880: 
os.c  1881: // set up kernel page table
os.c  1882: setupkvm()
00005834  00000802  LEV   0x8 (D 8)
os.c  1883: {
os.c  1884:   uint i, *pde, *pt;
os.c  1885: 
os.c  1886:   kpdir = memset(kalloc(), 0, PAGE); // kalloc returns physical addresses here (kfree wont work until later on)
00005838  fffff001  ENT   0xfffffff0 (D -16)
0000583c  0010009e  PSHI  0x1000 (D 4096)
00005840  0000009e  PSHI  0x0 (D 0)
00005844  ffa9a405  JSR   0xffffa9a4 (TO 0x1ec)
00005848  0000009d  PSHA
0000584c  ffa7c805  JSR   0xffffa7c8 (TO 0x18)
00005850  00001801  ENT   0x18 (D 24)
00005854  00216845  SG    0x2168 (D 8552)
os.c  1887: 
os.c  1888:   for (i=0; i<mem_sz; i += PAGE) {
00005858  00000023  LI    0x0 (D 0)
0000585c  00000c40  SL    0xc (D 12)
00005860  00000003  JMP   <fwd>
os.c  1889:     pde = &kpdir[(P2V+i) >> 22];
00005864  00000c0e  LL    0xc (D 12)
00005868  ffffc03b  LBI   0xffffffc0 (D -64)
0000586c  0000003c  LBHI  0x0 (D 0)
00005870  00000053  ADD 
00005874  00001678  SRUI  0x16 (D 22)
00005878  0000045a  MULI  0x4 (D 4)
0000587c  0021682d  LBG   0x2168 (D 8552)
00005880  00000053  ADD 
00005884  00000840  SL    0x8 (D 8)
os.c  1890:     if (*pde & PTE_P)
00005888  0000080e  LL    0x8 (D 8)
0000588c  0000001c  LX  
00005890  00000169  ANDI  0x1 (D 1)
00005894  00000084  BZ    <fwd>
os.c  1891:       pt = *pde & -PAGE;
00005898  0000080e  LL    0x8 (D 8)
0000589c  0000001c  LX  
000058a0  fff00069  ANDI  0xfffff000 (D -4096)
000058a4  00000440  SL    0x4 (D 4)
os.c  1892:     else
os.c  1893:       *pde = (uint)(pt = memset(kalloc(), 0, PAGE)) | PTE_P | PTE_W;
000058a8  00000003  JMP   <fwd>
000058ac  0010009e  PSHI  0x1000 (D 4096)
000058b0  0000009e  PSHI  0x0 (D 0)
000058b4  ffa93405  JSR   0xffffa934 (TO 0x1ec)
000058b8  0000009d  PSHA
000058bc  ffa75805  JSR   0xffffa758 (TO 0x18)
000058c0  00001801  ENT   0x18 (D 24)
000058c4  00000440  SL    0x4 (D 4)
000058c8  0000016c  ORI   0x1 (D 1)
000058cc  0000026c  ORI   0x2 (D 2)
000058d0  00000826  LBL   0x8 (D 8)
000058d4  0000004a  SX  
os.c  1894:     pt[((P2V+i) >> 12) & 0x3ff] = i | PTE_P | PTE_W;
000058d8  00000c0e  LL    0xc (D 12)
000058dc  ffffc03b  LBI   0xffffffc0 (D -64)
000058e0  0000003c  LBHI  0x0 (D 0)
000058e4  00000053  ADD 
000058e8  00000c78  SRUI  0xc (D 12)
000058ec  0003ff69  ANDI  0x3ff (D 1023)
000058f0  0000045a  MULI  0x4 (D 4)
000058f4  00000455  ADDL  0x4 (D 4)
000058f8  0000009d  PSHA
000058fc  0000140e  LL    0x14 (D 20)
00005900  0000016c  ORI   0x1 (D 1)
00005904  0000026c  ORI   0x2 (D 2)
00005908  000000a1  POPB
0000590c  0000004a  SX  
os.c  1895:   }
os.c  1896: }
00005910  00000c0e  LL    0xc (D 12)
00005914  00100054  ADDI  0x1000 (D 4096)
00005918  00000c40  SL    0xc (D 12)
0000591c  00000c0e  LL    0xc (D 12)
00005920  0021102d  LBG   0x2110 (D 8464)
00005924  0000008d  BLTU  <fwd>
os.c  1897: 
os.c  1898: // return the address of the PTE in page table pd that corresponds to virtual address va
os.c  1899: uint *walkpdir(uint *pd, uint va)
00005928  00001002  LEV   0x10 (D 16)
os.c  1900: {
os.c  1901:   uint *pde = &pd[va >> 22], *pt;
os.c  1902: 
os.c  1903:   if (!(*pde & PTE_P)) return 0;
0000592c  fffff801  ENT   0xfffffff8 (D -8)
00005930  0000180e  LL    0x18 (D 24)
00005934  00001678  SRUI  0x16 (D 22)
00005938  0000045a  MULI  0x4 (D 4)
0000593c  00001055  ADDL  0x10 (D 16)
00005940  00000440  SL    0x4 (D 4)
00005944  0000040e  LL    0x4 (D 4)
00005948  0000001c  LX  
0000594c  00000169  ANDI  0x1 (D 1)
00005950  00000086  BNZ   <fwd>
00005954  00000023  LI    0x0 (D 0)
00005958  00000802  LEV   0x8 (D 8)
os.c  1904:   pt = P2V+(*pde & -PAGE);
0000595c  0000040e  LL    0x4 (D 4)
00005960  0000001c  LX  
00005964  fff00069  ANDI  0xfffff000 (D -4096)
00005968  ffffc03b  LBI   0xffffffc0 (D -64)
0000596c  0000003c  LBHI  0x0 (D 0)
00005970  00000053  ADD 
00005974  00000040  SL    0x0 (D 0)
os.c  1905:   return &pt[(va >> 12) & 0x3ff];
00005978  0000180e  LL    0x18 (D 24)
0000597c  00000c78  SRUI  0xc (D 12)
00005980  0003ff69  ANDI  0x3ff (D 1023)
00005984  0000045a  MULI  0x4 (D 4)
00005988  00000055  ADDL  0x0 (D 0)
0000598c  00000802  LEV   0x8 (D 8)
os.c  1906: }
os.c  1907: 
os.c  1908: // create PTE for a page
os.c  1909: mappage(uint *pd, uint va, uint pa, int perm)
00005990  00000802  LEV   0x8 (D 8)
os.c  1910: {
os.c  1911:   uint *pde, *pte, *pt;
os.c  1912: 
os.c  1913:   if (*(pde = &pd[va >> 22]) & PTE_P)
00005994  fffff001  ENT   0xfffffff0 (D -16)
00005998  0000200e  LL    0x20 (D 32)
0000599c  00001678  SRUI  0x16 (D 22)
000059a0  0000045a  MULI  0x4 (D 4)
000059a4  00001855  ADDL  0x18 (D 24)
000059a8  00000c40  SL    0xc (D 12)
000059ac  0000001c  LX  
000059b0  00000169  ANDI  0x1 (D 1)
000059b4  00000084  BZ    <fwd>
os.c  1914:     pt = P2V+(*pde & -PAGE);
000059b8  00000c0e  LL    0xc (D 12)
000059bc  0000001c  LX  
000059c0  fff00069  ANDI  0xfffff000 (D -4096)
000059c4  ffffc03b  LBI   0xffffffc0 (D -64)
000059c8  0000003c  LBHI  0x0 (D 0)
000059cc  00000053  ADD 
000059d0  00000440  SL    0x4 (D 4)
os.c  1915:   else
os.c  1916:     *pde = (V2P+(uint)(pt = memset(kalloc(), 0, PAGE))) | PTE_P | PTE_W | PTE_U;
000059d4  00000003  JMP   <fwd>
000059d8  0010009e  PSHI  0x1000 (D 4096)
000059dc  0000009e  PSHI  0x0 (D 0)
000059e0  ffa80805  JSR   0xffffa808 (TO 0x1ec)
000059e4  0000009d  PSHA
000059e8  ffa62c05  JSR   0xffffa62c (TO 0x18)
000059ec  00001801  ENT   0x18 (D 24)
000059f0  00000440  SL    0x4 (D 4)
000059f4  0000403b  LBI   0x40 (D 64)
000059f8  0000003c  LBHI  0x0 (D 0)
000059fc  00000053  ADD 
00005a00  0000016c  ORI   0x1 (D 1)
00005a04  0000026c  ORI   0x2 (D 2)
00005a08  0000046c  ORI   0x4 (D 4)
00005a0c  00000c26  LBL   0xc (D 12)
00005a10  0000004a  SX  
os.c  1917:   pte = &pt[(va >> 12) & 0x3ff];
00005a14  0000200e  LL    0x20 (D 32)
00005a18  00000c78  SRUI  0xc (D 12)
00005a1c  0003ff69  ANDI  0x3ff (D 1023)
00005a20  0000045a  MULI  0x4 (D 4)
00005a24  00000455  ADDL  0x4 (D 4)
00005a28  00000840  SL    0x8 (D 8)
os.c  1918:   if (*pte & PTE_P) { printf("*pte=0x%x pd=0x%x va=0x%x pa=0x%x perm=0x%x", *pte, pd, va, pa, perm); panic("remap"); }
00005a2c  0000080e  LL    0x8 (D 8)
00005a30  0000001c  LX  
00005a34  00000169  ANDI  0x1 (D 1)
00005a38  00000084  BZ    <fwd>
00005a3c  0000300e  LL    0x30 (D 48)
00005a40  0000009d  PSHA
00005a44  0000300e  LL    0x30 (D 48)
00005a48  0000009d  PSHA
00005a4c  0000300e  LL    0x30 (D 48)
00005a50  0000009d  PSHA
00005a54  0000300e  LL    0x30 (D 48)
00005a58  0000009d  PSHA
00005a5c  0000280e  LL    0x28 (D 40)
00005a60  0000001c  LX  
00005a64  0000009d  PSHA
00005a68  00030f08  LEAG  0x30f (D 783)
00005a6c  0000009d  PSHA
00005a70  ffa94405  JSR   0xffffa944 (TO 0x3b8)
00005a74  00003001  ENT   0x30 (D 48)
00005a78  00033b08  LEAG  0x33b (D 827)
00005a7c  0000009d  PSHA
00005a80  ffaab005  JSR   0xffffaab0 (TO 0x534)
00005a84  00000801  ENT   0x8 (D 8)
os.c  1919:   *pte = pa | perm;
00005a88  0000280e  LL    0x28 (D 40)
00005a8c  0000306d  ORL   0x30 (D 48)
00005a90  00000826  LBL   0x8 (D 8)
00005a94  0000004a  SX  
os.c  1920: }
os.c  1921: 
os.c  1922: // Allocate page tables and physical memory to grow process from oldsz to
os.c  1923: // newsz, which need not be page aligned.  Returns new size or 0 on error.
os.c  1924: int allocuvm(uint *pd, uint oldsz, uint newsz, int create) // XXX rename grow() ?
00005a98  00001002  LEV   0x10 (D 16)
os.c  1925: {
os.c  1926:   uint va;
os.c  1927:   if (newsz > USERTOP) return 0; // XXX make sure this never happens...
00005a9c  fffff801  ENT   0xfffffff8 (D -8)
00005aa0  ffffc023  LI    0xffffffc0 (D -64)
00005aa4  00000024  LHI   0x0 (D 0)
00005aa8  00002026  LBL   0x20 (D 32)
00005aac  00000090  BGEU  <fwd>
00005ab0  00000023  LI    0x0 (D 0)
00005ab4  00000802  LEV   0x8 (D 8)
os.c  1928:   if (newsz <= oldsz) panic("allocuvm: newsz <= oldsz"); // XXX do pre-checking in caller, no more post-checking needed
00005ab8  0000180e  LL    0x18 (D 24)
00005abc  00002026  LBL   0x20 (D 32)
00005ac0  0000008d  BLTU  <fwd>
00005ac4  00034108  LEAG  0x341 (D 833)
00005ac8  0000009d  PSHA
00005acc  ffaa6405  JSR   0xffffaa64 (TO 0x534)
00005ad0  00000801  ENT   0x8 (D 8)
os.c  1929:   
os.c  1930:   va = (oldsz + PAGE-1) & -PAGE;
00005ad4  0000180e  LL    0x18 (D 24)
00005ad8  00100054  ADDI  0x1000 (D 4096)
00005adc  ffffff54  ADDI  0xffffffff (D -1)
00005ae0  fff00069  ANDI  0xfffff000 (D -4096)
00005ae4  00000440  SL    0x4 (D 4)
os.c  1931:   while (va < newsz) {
00005ae8  00000003  JMP   <fwd>
os.c  1932:     if (create)
00005aec  0000280e  LL    0x28 (D 40)
00005af0  00000084  BZ    <fwd>
os.c  1933:       mappage(pd, va, V2P+(memset(kalloc(), 0, PAGE)), PTE_P | PTE_W | PTE_U);
00005af4  0000079e  PSHI  0x7 (D 7)
00005af8  0010009e  PSHI  0x1000 (D 4096)
00005afc  0000009e  PSHI  0x0 (D 0)
00005b00  ffa6e805  JSR   0xffffa6e8 (TO 0x1ec)
00005b04  0000009d  PSHA
00005b08  ffa50c05  JSR   0xffffa50c (TO 0x18)
00005b0c  00001801  ENT   0x18 (D 24)
00005b10  0000403b  LBI   0x40 (D 64)
00005b14  0000003c  LBHI  0x0 (D 0)
00005b18  00000053  ADD 
00005b1c  0000009d  PSHA
00005b20  0000140e  LL    0x14 (D 20)
00005b24  0000009d  PSHA
00005b28  0000280e  LL    0x28 (D 40)
00005b2c  0000009d  PSHA
00005b30  fffe6005  JSR   0xfffffe60 (TO 0x5994)
00005b34  00002001  ENT   0x20 (D 32)
os.c  1934:     else
os.c  1935:       mappage(pd, va, 0, PTE_W | PTE_U);
00005b38  00000003  JMP   <fwd>
00005b3c  0000069e  PSHI  0x6 (D 6)
00005b40  0000009e  PSHI  0x0 (D 0)
00005b44  0000140e  LL    0x14 (D 20)
00005b48  0000009d  PSHA
00005b4c  0000280e  LL    0x28 (D 40)
00005b50  0000009d  PSHA
00005b54  fffe3c05  JSR   0xfffffe3c (TO 0x5994)
00005b58  00002001  ENT   0x20 (D 32)
os.c  1936:     va += PAGE;
00005b5c  0000040e  LL    0x4 (D 4)
00005b60  00100054  ADDI  0x1000 (D 4096)
00005b64  00000440  SL    0x4 (D 4)
os.c  1937:   }  
os.c  1938:   return newsz; // XXX not needed if never fails
00005b68  0000040e  LL    0x4 (D 4)
00005b6c  00002026  LBL   0x20 (D 32)
00005b70  0000008d  BLTU  <fwd>
00005b74  0000200e  LL    0x20 (D 32)
00005b78  00000802  LEV   0x8 (D 8)
os.c  1939: }
os.c  1940: 
os.c  1941: // deallocate user pages to bring the process size from oldsz to newsz.
os.c  1942: // oldsz and newsz need not be page-aligned, nor does newsz need to be less than oldsz.   XXXX wha why?
os.c  1943: // oldsz can be larger than the actual process size.  Returns the new process size.
os.c  1944: int deallocuvm(uint *pd, uint oldsz, uint newsz) // XXX rename shrink() ?? //XXX memset 0 top of partial page if present !!!
00005b7c  00000802  LEV   0x8 (D 8)
os.c  1945: {
os.c  1946:   uint va, *pde, *pte, *pt;
os.c  1947: 
os.c  1948:   if (newsz >= oldsz) return oldsz; // XXX maybe make sure this never happens
00005b80  fffff001  ENT   0xfffffff0 (D -16)
00005b84  0000280e  LL    0x28 (D 40)
00005b88  00002026  LBL   0x20 (D 32)
00005b8c  0000008d  BLTU  <fwd>
00005b90  0000200e  LL    0x20 (D 32)
00005b94  00001002  LEV   0x10 (D 16)
os.c  1949: 
os.c  1950:   va = newsz;
00005b98  0000280e  LL    0x28 (D 40)
00005b9c  00000c40  SL    0xc (D 12)
os.c  1951:   if (va & (PAGE-1)) {
00005ba0  00000c0e  LL    0xc (D 12)
00005ba4  000fff69  ANDI  0xfff (D 4095)
00005ba8  00000084  BZ    <fwd>
os.c  1952:     memset(va, 0, PAGE - (va & (PAGE-1)));
00005bac  00000c0e  LL    0xc (D 12)
00005bb0  000fff69  ANDI  0xfff (D 4095)
00005bb4  0000003e  LBA 
00005bb8  00100023  LI    0x1000 (D 4096)
00005bbc  00000056  SUB 
00005bc0  0000009d  PSHA
00005bc4  0000009e  PSHI  0x0 (D 0)
00005bc8  00001c0e  LL    0x1c (D 28)
00005bcc  0000009d  PSHA
00005bd0  ffa44405  JSR   0xffffa444 (TO 0x18)
00005bd4  00001801  ENT   0x18 (D 24)
os.c  1953:     va = (va + PAGE-1) & -PAGE;
00005bd8  00000c0e  LL    0xc (D 12)
00005bdc  00100054  ADDI  0x1000 (D 4096)
00005be0  ffffff54  ADDI  0xffffffff (D -1)
00005be4  fff00069  ANDI  0xfffff000 (D -4096)
00005be8  00000c40  SL    0xc (D 12)
os.c  1954:   }
os.c  1955: 
os.c  1956:   while(va < oldsz) {
00005bec  00000003  JMP   <fwd>
os.c  1957:     pde = &pd[(va >> 22) & 0x3ff]; //&pd[PDX(va)];
00005bf0  00000c0e  LL    0xc (D 12)
00005bf4  00001678  SRUI  0x16 (D 22)
00005bf8  0003ff69  ANDI  0x3ff (D 1023)
00005bfc  0000045a  MULI  0x4 (D 4)
00005c00  00001855  ADDL  0x18 (D 24)
00005c04  00000840  SL    0x8 (D 8)
os.c  1958:     if (*pde & PTE_P) { // XXX this may no longer be true if we are paging out pde/pte's?
00005c08  0000080e  LL    0x8 (D 8)
00005c0c  0000001c  LX  
00005c10  00000169  ANDI  0x1 (D 1)
00005c14  00000084  BZ    <fwd>
os.c  1959:       pt = P2V+(*pde & -PAGE);
00005c18  0000080e  LL    0x8 (D 8)
00005c1c  0000001c  LX  
00005c20  fff00069  ANDI  0xfffff000 (D -4096)
00005c24  ffffc03b  LBI   0xffffffc0 (D -64)
00005c28  0000003c  LBHI  0x0 (D 0)
00005c2c  00000053  ADD 
00005c30  00000040  SL    0x0 (D 0)
os.c  1960:       pte = &pt[(va >> 12) & 0x3ff]; // &pt[PTX(va)];
00005c34  00000c0e  LL    0xc (D 12)
00005c38  00000c78  SRUI  0xc (D 12)
00005c3c  0003ff69  ANDI  0x3ff (D 1023)
00005c40  0000045a  MULI  0x4 (D 4)
00005c44  00000055  ADDL  0x0 (D 0)
00005c48  00000440  SL    0x4 (D 4)
os.c  1961: 
os.c  1962:       if (*pte & PTE_P) {
00005c4c  0000040e  LL    0x4 (D 4)
00005c50  0000001c  LX  
00005c54  00000169  ANDI  0x1 (D 1)
00005c58  00000084  BZ    <fwd>
os.c  1963:         kfree(P2V+(*pte & -PAGE));
00005c5c  0000040e  LL    0x4 (D 4)
00005c60  0000001c  LX  
00005c64  fff00069  ANDI  0xfffff000 (D -4096)
00005c68  ffffc03b  LBI   0xffffffc0 (D -64)
00005c6c  0000003c  LBHI  0x0 (D 0)
00005c70  00000053  ADD 
00005c74  0000009d  PSHA
00005c78  ffa5fc05  JSR   0xffffa5fc (TO 0x278)
00005c7c  00000801  ENT   0x8 (D 8)
os.c  1964:         *pte = 0;      
00005c80  00000023  LI    0x0 (D 0)
00005c84  00000426  LBL   0x4 (D 4)
00005c88  0000004a  SX  
os.c  1965:       }
os.c  1966:       va += PAGE;
00005c8c  00000c0e  LL    0xc (D 12)
00005c90  00100054  ADDI  0x1000 (D 4096)
00005c94  00000c40  SL    0xc (D 12)
os.c  1967:     }
os.c  1968:     else
os.c  1969:       va = (va + PAGE * 1024) & -(PAGE * 1024);
00005c98  00000003  JMP   <fwd>
00005c9c  00000c0e  LL    0xc (D 12)
00005ca0  40000054  ADDI  0x400000 (D 4194304)
00005ca4  c0000069  ANDI  0xffc00000 (D -4194304)
00005ca8  00000c40  SL    0xc (D 12)
os.c  1970:   }
os.c  1971:   return newsz; // XXX not needed if never fails
00005cac  00000c0e  LL    0xc (D 12)
00005cb0  00002026  LBL   0x20 (D 32)
00005cb4  0000008d  BLTU  <fwd>
00005cb8  0000280e  LL    0x28 (D 40)
00005cbc  00001002  LEV   0x10 (D 16)
os.c  1972: }
os.c  1973: 
os.c  1974: // free a page table and all the physical memory pages in the user part
os.c  1975: freevm(uint *pd)
00005cc0  00001002  LEV   0x10 (D 16)
os.c  1976: {
os.c  1977:   uint i;
os.c  1978: 
os.c  1979:   if (!pd) panic("freevm: no pd");
00005cc4  fffff801  ENT   0xfffffff8 (D -8)
00005cc8  0000100e  LL    0x10 (D 16)
00005ccc  00000086  BNZ   <fwd>
00005cd0  00035a08  LEAG  0x35a (D 858)
00005cd4  0000009d  PSHA
00005cd8  ffa85805  JSR   0xffffa858 (TO 0x534)
00005cdc  00000801  ENT   0x8 (D 8)
os.c  1980:   deallocuvm(pd, USERTOP, 0);  // deallocate all user memory XXX do this more simply
00005ce0  0000009e  PSHI  0x0 (D 0)
00005ce4  ffffc023  LI    0xffffffc0 (D -64)
00005ce8  00000024  LHI   0x0 (D 0)
00005cec  0000009d  PSHA
00005cf0  0000200e  LL    0x20 (D 32)
00005cf4  0000009d  PSHA
00005cf8  fffe8405  JSR   0xfffffe84 (TO 0x5b80)
00005cfc  00001801  ENT   0x18 (D 24)
os.c  1981:   for (i = 0; i < ((USERTOP >> 22) & 0x3ff); i++) { // for (i = 0; i < PDX(USERTOP); i++)
00005d00  00000023  LI    0x0 (D 0)
00005d04  00000440  SL    0x4 (D 4)
00005d08  00000003  JMP   <fwd>
os.c  1982:     if (pd[i] & PTE_P) kfree(P2V+(pd[i] & -PAGE)); // deallocate all page table entries
00005d0c  0000040e  LL    0x4 (D 4)
00005d10  0000045a  MULI  0x4 (D 4)
00005d14  00001055  ADDL  0x10 (D 16)
00005d18  0000001c  LX  
00005d1c  00000169  ANDI  0x1 (D 1)
00005d20  00000084  BZ    <fwd>
00005d24  0000040e  LL    0x4 (D 4)
00005d28  0000045a  MULI  0x4 (D 4)
00005d2c  00001055  ADDL  0x10 (D 16)
00005d30  0000001c  LX  
00005d34  fff00069  ANDI  0xfffff000 (D -4096)
00005d38  ffffc03b  LBI   0xffffffc0 (D -64)
00005d3c  0000003c  LBHI  0x0 (D 0)
00005d40  00000053  ADD 
00005d44  0000009d  PSHA
00005d48  ffa52c05  JSR   0xffffa52c (TO 0x278)
00005d4c  00000801  ENT   0x8 (D 8)
os.c  1983:   }
os.c  1984:   kfree(pd); // deallocate page directory
00005d50  0000040e  LL    0x4 (D 4)
00005d54  ffffff57  SUBI  0xffffffff (D -1)
00005d58  00000440  SL    0x4 (D 4)
00005d5c  0000040e  LL    0x4 (D 4)
00005d60  0003003b  LBI   0x300 (D 768)
00005d64  0000008d  BLTU  <fwd>
00005d68  0000100e  LL    0x10 (D 16)
00005d6c  0000009d  PSHA
00005d70  ffa50405  JSR   0xffffa504 (TO 0x278)
00005d74  00000801  ENT   0x8 (D 8)
os.c  1985: }
os.c  1986: 
os.c  1987: // copy parent process page table for a child
os.c  1988: uint *copyuvm(uint *pd, uint sz)
00005d78  00000802  LEV   0x8 (D 8)
os.c  1989: {
os.c  1990:   uint va, *d, *pte;
os.c  1991: 
os.c  1992:   d = memcpy(kalloc(), kpdir, PAGE);
00005d7c  fffff001  ENT   0xfffffff0 (D -16)
00005d80  0010009e  PSHI  0x1000 (D 4096)
00005d84  00216815  LG    0x2168 (D 8552)
00005d88  0000009d  PSHA
00005d8c  ffa45c05  JSR   0xffffa45c (TO 0x1ec)
00005d90  0000009d  PSHA
00005d94  ffa26805  JSR   0xffffa268 (TO 0x0)
00005d98  00001801  ENT   0x18 (D 24)
00005d9c  00000840  SL    0x8 (D 8)
os.c  1993:   for (va = 0; va < sz; va += PAGE) {
00005da0  00000023  LI    0x0 (D 0)
00005da4  00000c40  SL    0xc (D 12)
00005da8  00000003  JMP   <fwd>
os.c  1994:     if (!(pte = walkpdir(pd, va))) panic("copyuvm: pte should exist");
00005dac  00000c0e  LL    0xc (D 12)
00005db0  0000009d  PSHA
00005db4  0000200e  LL    0x20 (D 32)
00005db8  0000009d  PSHA
00005dbc  fffb6c05  JSR   0xfffffb6c (TO 0x592c)
00005dc0  00001001  ENT   0x10 (D 16)
00005dc4  00000440  SL    0x4 (D 4)
00005dc8  00000086  BNZ   <fwd>
00005dcc  00036808  LEAG  0x368 (D 872)
00005dd0  0000009d  PSHA
00005dd4  ffa75c05  JSR   0xffffa75c (TO 0x534)
00005dd8  00000801  ENT   0x8 (D 8)
os.c  1995: 
os.c  1996:     if (*pte & PTE_P)
00005ddc  0000040e  LL    0x4 (D 4)
00005de0  0000001c  LX  
00005de4  00000169  ANDI  0x1 (D 1)
00005de8  00000084  BZ    <fwd>
os.c  1997:       mappage(d, va, V2P+(memcpy(kalloc(), P2V+(*pte & -PAGE), PAGE)), PTE_P | PTE_W | PTE_U); // XXX implement copy on write
00005dec  0000079e  PSHI  0x7 (D 7)
00005df0  0010009e  PSHI  0x1000 (D 4096)
00005df4  0000140e  LL    0x14 (D 20)
00005df8  0000001c  LX  
00005dfc  fff00069  ANDI  0xfffff000 (D -4096)
00005e00  ffffc03b  LBI   0xffffffc0 (D -64)
00005e04  0000003c  LBHI  0x0 (D 0)
00005e08  00000053  ADD 
00005e0c  0000009d  PSHA
00005e10  ffa3d805  JSR   0xffffa3d8 (TO 0x1ec)
00005e14  0000009d  PSHA
00005e18  ffa1e405  JSR   0xffffa1e4 (TO 0x0)
00005e1c  00001801  ENT   0x18 (D 24)
00005e20  0000403b  LBI   0x40 (D 64)
00005e24  0000003c  LBHI  0x0 (D 0)
00005e28  00000053  ADD 
00005e2c  0000009d  PSHA
00005e30  00001c0e  LL    0x1c (D 28)
00005e34  0000009d  PSHA
00005e38  0000200e  LL    0x20 (D 32)
00005e3c  0000009d  PSHA
00005e40  fffb5005  JSR   0xfffffb50 (TO 0x5994)
00005e44  00002001  ENT   0x20 (D 32)
os.c  1998:     else
os.c  1999:       mappage(d, va, 0, PTE_W | PTE_U);
00005e48  00000003  JMP   <fwd>
00005e4c  0000069e  PSHI  0x6 (D 6)
00005e50  0000009e  PSHI  0x0 (D 0)
00005e54  00001c0e  LL    0x1c (D 28)
00005e58  0000009d  PSHA
00005e5c  0000200e  LL    0x20 (D 32)
00005e60  0000009d  PSHA
00005e64  fffb2c05  JSR   0xfffffb2c (TO 0x5994)
00005e68  00002001  ENT   0x20 (D 32)
os.c  2000:   }
os.c  2001:   return d;
00005e6c  00000c0e  LL    0xc (D 12)
00005e70  00100054  ADDI  0x1000 (D 4096)
00005e74  00000c40  SL    0xc (D 12)
00005e78  00000c0e  LL    0xc (D 12)
00005e7c  00002026  LBL   0x20 (D 32)
00005e80  0000008d  BLTU  <fwd>
00005e84  0000080e  LL    0x8 (D 8)
00005e88  00001002  LEV   0x10 (D 16)
os.c  2002: }
os.c  2003: 
os.c  2004: swtch(int *old, int new) // switch stacks
00005e8c  00001002  LEV   0x10 (D 16)
os.c  2005: {
os.c  2006:   asm(LEA,0); // a = sp
00005e90  00000007  LEA   0x0 (D 0)
os.c  2007:   asm(LBL,8); // b = old
00005e94  00000826  LBL   0x8 (D 8)
os.c  2008:   asm(SX,0);  // *b = a
00005e98  0000004a  SX    0x0 (D 0)
os.c  2009:   asm(LL,16); // a = new
00005e9c  0000100e  LL    0x10 (D 16)
os.c  2010:   asm(SSP);   // sp = a
00005ea0  0000009c  SSP 
os.c  2011: }
os.c  2012: 
os.c  2013: scheduler()
00005ea4  00000002  LEV   0x0 (D 0)
os.c  2014: {
os.c  2015:   int n;
os.c  2016:   
os.c  2017:   for (n = 0; n < NPROC; n++) {  // XXX do me differently
00005ea8  fffff801  ENT   0xfffffff8 (D -8)
00005eac  00000023  LI    0x0 (D 0)
00005eb0  00000440  SL    0x4 (D 4)
00005eb4  00000003  JMP   <fwd>
os.c  2018:     proc[n].next = &proc[(n+1)&(NPROC-1)];
00005eb8  00000008  LEAG  0x0 (D 0)
00005ebc  0000009d  PSHA
00005ec0  00000c0e  LL    0xc (D 12)
00005ec4  0000845a  MULI  0x84 (D 132)
00005ec8  000000a1  POPB
00005ecc  00000053  ADD 
00005ed0  0000009d  PSHA
00005ed4  00000008  LEAG  0x0 (D 0)
00005ed8  0000009d  PSHA
00005edc  0000140e  LL    0x14 (D 20)
00005ee0  00000154  ADDI  0x1 (D 1)
00005ee4  00003f69  ANDI  0x3f (D 63)
00005ee8  0000845a  MULI  0x84 (D 132)
00005eec  000000a1  POPB
00005ef0  00000053  ADD 
00005ef4  000000a1  POPB
00005ef8  0000004a  SX  
os.c  2019:     proc[n].prev = &proc[(n-1)&(NPROC-1)];
00005efc  00000008  LEAG  0x0 (D 0)
00005f00  0000009d  PSHA
00005f04  00000c0e  LL    0xc (D 12)
00005f08  0000845a  MULI  0x84 (D 132)
00005f0c  000000a1  POPB
00005f10  00000053  ADD 
00005f14  00000454  ADDI  0x4 (D 4)
00005f18  0000009d  PSHA
00005f1c  00000008  LEAG  0x0 (D 0)
00005f20  0000009d  PSHA
00005f24  0000140e  LL    0x14 (D 20)
00005f28  ffffff54  ADDI  0xffffffff (D -1)
00005f2c  00003f69  ANDI  0x3f (D 63)
00005f30  0000845a  MULI  0x84 (D 132)
00005f34  000000a1  POPB
00005f38  00000053  ADD 
00005f3c  000000a1  POPB
00005f40  0000004a  SX  
os.c  2020:   }
os.c  2021:   
os.c  2022:   u = &proc[0];
00005f44  0000040e  LL    0x4 (D 4)
00005f48  ffffff57  SUBI  0xffffffff (D -1)
00005f4c  00000440  SL    0x4 (D 4)
00005f50  0000040e  LL    0x4 (D 4)
00005f54  0000403b  LBI   0x40 (D 64)
00005f58  0000008c  BLT   <fwd>
00005f5c  00000008  LEAG  0x0 (D 0)
00005f60  00210045  SG    0x2100 (D 8448)
os.c  2023:   pdir(V2P+(uint)(u->pdir));
00005f64  00210015  LG    0x2100 (D 8448)
00005f68  00000c1c  LX    0xc (D 12)
00005f6c  0000403b  LBI   0x40 (D 64)
00005f70  0000003c  LBHI  0x0 (D 0)
00005f74  00000053  ADD 
00005f78  0000009d  PSHA
00005f7c  ffa10805  JSR   0xffffa108 (TO 0x88)
00005f80  00000801  ENT   0x8 (D 8)
os.c  2024:   u->state = RUNNING;
00005f84  00210015  LG    0x2100 (D 8448)
00005f88  00001454  ADDI  0x14 (D 20)
00005f8c  0000003e  LBA 
00005f90  00000423  LI    0x4 (D 4)
00005f94  0000004a  SX  
os.c  2025:   swtch(&n, u->context);
00005f98  00210015  LG    0x2100 (D 8448)
00005f9c  0000241c  LX    0x24 (D 36)
00005fa0  0000009d  PSHA
00005fa4  00000c07  LEA   0xc (D 12)
00005fa8  0000009d  PSHA
00005fac  fffee005  JSR   0xfffffee0 (TO 0x5e90)
00005fb0  00001001  ENT   0x10 (D 16)
os.c  2026:   panic("scheduler returned!\n");
00005fb4  00038208  LEAG  0x382 (D 898)
00005fb8  0000009d  PSHA
00005fbc  ffa57405  JSR   0xffffa574 (TO 0x534)
00005fc0  00000801  ENT   0x8 (D 8)
os.c  2027: }
os.c  2028: 
os.c  2029: sched() // XXX redesign this better
00005fc4  00000802  LEV   0x8 (D 8)
os.c  2030: {
os.c  2031:   int n; struct proc *p;
os.c  2032: //  if (u->state == RUNNING) panic("sched running");
os.c  2033: //  if (lien()) panic("sched interruptible");
os.c  2034:   p = u;
00005fc8  fffff801  ENT   0xfffffff8 (D -8)
00005fcc  00210015  LG    0x2100 (D 8448)
00005fd0  00000040  SL    0x0 (D 0)
os.c  2035: //  while (u->state != RUNNABLE) u = u->next;
os.c  2036:   for (n=0;n<NPROC;n++) {
00005fd4  00000023  LI    0x0 (D 0)
00005fd8  00000440  SL    0x4 (D 4)
00005fdc  00000003  JMP   <fwd>
os.c  2037:     u = u->next;
00005fe0  00210015  LG    0x2100 (D 8448)
00005fe4  0000001c  LX  
00005fe8  00210045  SG    0x2100 (D 8448)
os.c  2038:     if (u == &proc[0]) continue;
00005fec  00000008  LEAG  0x0 (D 0)
00005ff0  0021002d  LBG   0x2100 (D 8448)
00005ff4  0000008a  BNE   <fwd>
00005ff8  00000003  JMP   <fwd>
os.c  2039:     if (u->state == RUNNABLE) goto found;
00005ffc  00210015  LG    0x2100 (D 8448)
00006000  0000141c  LX    0x14 (D 20)
00006004  0000033b  LBI   0x3 (D 3)
00006008  0000008a  BNE   <fwd>
0000600c  00000003  JMP   <fwd>
os.c  2040:   }
os.c  2041:   u = &proc[0];
00006010  0000040e  LL    0x4 (D 4)
00006014  ffffff57  SUBI  0xffffffff (D -1)
00006018  00000440  SL    0x4 (D 4)
0000601c  0000040e  LL    0x4 (D 4)
00006020  0000403b  LBI   0x40 (D 64)
00006024  0000008c  BLT   <fwd>
00006028  00000008  LEAG  0x0 (D 0)
0000602c  00210045  SG    0x2100 (D 8448)
os.c  2042:   //printf("-");
os.c  2043:   
os.c  2044: found:
os.c  2045:   u->state = RUNNING;
00006030  00210015  LG    0x2100 (D 8448)
00006034  00001454  ADDI  0x14 (D 20)
00006038  0000003e  LBA 
0000603c  00000423  LI    0x4 (D 4)
00006040  0000004a  SX  
os.c  2046:   if (p != u) {
00006044  00210015  LG    0x2100 (D 8448)
00006048  00000026  LBL   0x0 (D 0)
0000604c  00000088  BE    <fwd>
os.c  2047:     pdir(V2P+(uint)(u->pdir));
00006050  00210015  LG    0x2100 (D 8448)
00006054  00000c1c  LX    0xc (D 12)
00006058  0000403b  LBI   0x40 (D 64)
0000605c  0000003c  LBHI  0x0 (D 0)
00006060  00000053  ADD 
00006064  0000009d  PSHA
00006068  ffa01c05  JSR   0xffffa01c (TO 0x88)
0000606c  00000801  ENT   0x8 (D 8)
os.c  2048:     //printf("+");
os.c  2049:     swtch(&p->context, u->context);
00006070  00210015  LG    0x2100 (D 8448)
00006074  0000241c  LX    0x24 (D 36)
00006078  0000009d  PSHA
0000607c  0000080e  LL    0x8 (D 8)
00006080  00002454  ADDI  0x24 (D 36)
00006084  0000009d  PSHA
00006088  fffe0405  JSR   0xfffffe04 (TO 0x5e90)
0000608c  00001001  ENT   0x10 (D 16)
os.c  2050:   }
os.c  2051:   //else printf("spin(%d)\n",u->pid);    XXX else do a wait for interrupt? (which will actually pend because interrupts are turned off here)
os.c  2052: }
os.c  2053: 
os.c  2054: trap(uint *sp, double g, double f, int c, int b, int a, int fc, uint *pc)  
00006090  00000802  LEV   0x8 (D 8)
os.c  2055: {
os.c  2056:   uint va;
os.c  2057:   switch (fc) {
00006094  fffff801  ENT   0xfffffff8 (D -8)
00006098  0000400e  LL    0x40 (D 64)
0000609c  00000003  JMP   <fwd>
os.c  2058:   case FSYS: panic("FSYS from kernel");
000060a0  00039708  LEAG  0x397 (D 919)
000060a4  0000009d  PSHA
000060a8  ffa48805  JSR   0xffffa488 (TO 0x534)
000060ac  00000801  ENT   0x8 (D 8)
os.c  2059:   case FSYS + USER:
os.c  2060:     if (u->killed) exit(-1);
000060b0  00210015  LG    0x2100 (D 8448)
000060b4  00002c1c  LX    0x2c (D 44)
000060b8  00000084  BZ    <fwd>
000060bc  ffffff9e  PSHI  0xffffffff (D -1)
000060c0  ffe7e405  JSR   0xffffe7e4 (TO 0x48a8)
000060c4  00000801  ENT   0x8 (D 8)
os.c  2061:     u->tf = &sp;
000060c8  00210015  LG    0x2100 (D 8448)
000060cc  00002054  ADDI  0x20 (D 32)
000060d0  0000009d  PSHA
000060d4  00001807  LEA   0x18 (D 24)
000060d8  000000a1  POPB
000060dc  0000004a  SX  
os.c  2062:     switch (pc[-1] >> 8) {
000060e0  0000480e  LL    0x48 (D 72)
000060e4  fffffc1c  LX    0xfffffffc (D -4)
000060e8  00000878  SRUI  0x8 (D 8)
000060ec  00000003  JMP   <fwd>
os.c  2063:     case S_fork:    a = fork(); break;
000060f0  ffe5e805  JSR   0xffffe5e8 (TO 0x46dc)
000060f4  00003840  SL    0x38 (D 56)
000060f8  00000003  JMP   <fwd>
os.c  2064:     case S_exit:    if (a < -99) printf("exit(%d)\n",a); exit(a); // XXX debug feature
000060fc  0000380e  LL    0x38 (D 56)
00006100  ffff9d3b  LBI   0xffffff9d (D -99)
00006104  0000008f  BGE   <fwd>
00006108  0000380e  LL    0x38 (D 56)
0000610c  0000009d  PSHA
00006110  0003a808  LEAG  0x3a8 (D 936)
00006114  0000009d  PSHA
00006118  ffa29c05  JSR   0xffffa29c (TO 0x3b8)
0000611c  00001001  ENT   0x10 (D 16)
00006120  0000380e  LL    0x38 (D 56)
00006124  0000009d  PSHA
00006128  ffe77c05  JSR   0xffffe77c (TO 0x48a8)
0000612c  00000801  ENT   0x8 (D 8)
os.c  2065:     case S_wait:    a = wait(); break; // XXX args?
00006130  ffe9d805  JSR   0xffffe9d8 (TO 0x4b0c)
00006134  00003840  SL    0x38 (D 56)
00006138  0060f803  JMP   <fwd>
os.c  2066:     case S_pipe:    a = pipe(a); break;
0000613c  0000380e  LL    0x38 (D 56)
00006140  0000009d  PSHA
00006144  ffdcb005  JSR   0xffffdcb0 (TO 0x3df8)
00006148  00000801  ENT   0x8 (D 8)
0000614c  00003840  SL    0x38 (D 56)
00006150  00613803  JMP   <fwd>
os.c  2067:     case S_write:   a = write(a, b, c); break;
00006154  0000280e  LL    0x28 (D 40)
00006158  0000009d  PSHA
0000615c  0000380e  LL    0x38 (D 56)
00006160  0000009d  PSHA
00006164  0000480e  LL    0x48 (D 72)
00006168  0000009d  PSHA
0000616c  ffcf9005  JSR   0xffffcf90 (TO 0x3100)
00006170  00001801  ENT   0x18 (D 24)
00006174  00003840  SL    0x38 (D 56)
00006178  00615003  JMP   <fwd>
os.c  2068:     case S_read:    a = read(a, b, c); break;
0000617c  0000280e  LL    0x28 (D 40)
00006180  0000009d  PSHA
00006184  0000380e  LL    0x38 (D 56)
00006188  0000009d  PSHA
0000618c  0000480e  LL    0x48 (D 72)
00006190  0000009d  PSHA
00006194  ffcd5005  JSR   0xffffcd50 (TO 0x2ee8)
00006198  00001801  ENT   0x18 (D 24)
0000619c  00003840  SL    0x38 (D 56)
000061a0  00617803  JMP   <fwd>
os.c  2069:     case S_close:   a = close(a); break;
000061a4  0000380e  LL    0x38 (D 56)
000061a8  0000009d  PSHA
000061ac  ffcb9005  JSR   0xffffcb90 (TO 0x2d40)
000061b0  00000801  ENT   0x8 (D 8)
000061b4  00003840  SL    0x38 (D 56)
000061b8  0061a003  JMP   <fwd>
os.c  2070:     case S_kill:    a = kill(a); break;
000061bc  0000380e  LL    0x38 (D 56)
000061c0  0000009d  PSHA
000061c4  ffe89405  JSR   0xffffe894 (TO 0x4a5c)
000061c8  00000801  ENT   0x8 (D 8)
000061cc  00003840  SL    0x38 (D 56)
000061d0  0061b803  JMP   <fwd>
os.c  2071:     case S_exec:    a = exec(a, b); break;
000061d4  0000300e  LL    0x30 (D 48)
000061d8  0000009d  PSHA
000061dc  0000400e  LL    0x40 (D 64)
000061e0  0000009d  PSHA
000061e4  ffde0c05  JSR   0xffffde0c (TO 0x3ff4)
000061e8  00001001  ENT   0x10 (D 16)
000061ec  00003840  SL    0x38 (D 56)
000061f0  0061d003  JMP   <fwd>
os.c  2072:     case S_open:    a = open(a, b); break;
000061f4  0000300e  LL    0x30 (D 48)
000061f8  0000009d  PSHA
000061fc  0000400e  LL    0x40 (D 64)
00006200  0000009d  PSHA
00006204  ffd71405  JSR   0xffffd714 (TO 0x391c)
00006208  00001001  ENT   0x10 (D 16)
0000620c  00003840  SL    0x38 (D 56)
00006210  0061f003  JMP   <fwd>
os.c  2073:     case S_mknod:   a = mknod(a, b, c); break;
00006214  0000280e  LL    0x28 (D 40)
00006218  0000009d  PSHA
0000621c  0000380e  LL    0x38 (D 56)
00006220  0000009d  PSHA
00006224  0000480e  LL    0x48 (D 72)
00006228  0000009d  PSHA
0000622c  ffdaac05  JSR   0xffffdaac (TO 0x3cdc)
00006230  00001801  ENT   0x18 (D 24)
00006234  00003840  SL    0x38 (D 56)
00006238  00621003  JMP   <fwd>
os.c  2074:     case S_unlink:  a = unlink(a); break;
0000623c  0000380e  LL    0x38 (D 56)
00006240  0000009d  PSHA
00006244  ffd42805  JSR   0xffffd428 (TO 0x3670)
00006248  00000801  ENT   0x8 (D 8)
0000624c  00003840  SL    0x38 (D 56)
00006250  00623803  JMP   <fwd>
os.c  2075:     case S_fstat:   a = fstat(a, b); break;
00006254  0000300e  LL    0x30 (D 48)
00006258  0000009d  PSHA
0000625c  0000400e  LL    0x40 (D 64)
00006260  0000009d  PSHA
00006264  ffcb4005  JSR   0xffffcb40 (TO 0x2da8)
00006268  00001001  ENT   0x10 (D 16)
0000626c  00003840  SL    0x38 (D 56)
00006270  00625003  JMP   <fwd>
os.c  2076:     case S_link:    a = link(a, b); break;
00006274  0000300e  LL    0x30 (D 48)
00006278  0000009d  PSHA
0000627c  0000400e  LL    0x40 (D 64)
00006280  0000009d  PSHA
00006284  ffd24005  JSR   0xffffd240 (TO 0x34c8)
00006288  00001001  ENT   0x10 (D 16)
0000628c  00003840  SL    0x38 (D 56)
00006290  00627003  JMP   <fwd>
os.c  2077:     case S_mkdir:   a = mkdir(a); break;
00006294  0000380e  LL    0x38 (D 56)
00006298  0000009d  PSHA
0000629c  ffd9e005  JSR   0xffffd9e0 (TO 0x3c80)
000062a0  00000801  ENT   0x8 (D 8)
000062a4  00003840  SL    0x38 (D 56)
000062a8  00629003  JMP   <fwd>
os.c  2078:     case S_chdir:   a = chdir(a); break;
000062ac  0000380e  LL    0x38 (D 56)
000062b0  0000009d  PSHA
000062b4  ffda8805  JSR   0xffffda88 (TO 0x3d40)
000062b8  00000801  ENT   0x8 (D 8)
000062bc  00003840  SL    0x38 (D 56)
000062c0  0062a803  JMP   <fwd>
os.c  2079:     case S_dup2:    a = dup2(a,b); break;
000062c4  0000300e  LL    0x30 (D 48)
000062c8  0000009d  PSHA
000062cc  0000400e  LL    0x40 (D 64)
000062d0  0000009d  PSHA
000062d4  ffd16c05  JSR   0xffffd16c (TO 0x3444)
000062d8  00001001  ENT   0x10 (D 16)
000062dc  00003840  SL    0x38 (D 56)
000062e0  0062c003  JMP   <fwd>
os.c  2080:     case S_getpid:  a = u->pid; break;
000062e4  00210015  LG    0x2100 (D 8448)
000062e8  0000181c  LX    0x18 (D 24)
000062ec  00003840  SL    0x38 (D 56)
000062f0  0062e003  JMP   <fwd>
os.c  2081:     case S_sbrk:    a = sbrk(a); break;
000062f4  0000380e  LL    0x38 (D 56)
000062f8  0000009d  PSHA
000062fc  ffe97c05  JSR   0xffffe97c (TO 0x4c7c)
00006300  00000801  ENT   0x8 (D 8)
00006304  00003840  SL    0x38 (D 56)
00006308  0062f003  JMP   <fwd>
os.c  2082:     case S_sleep:   a = ssleep(a); break;
0000630c  0000380e  LL    0x38 (D 56)
00006310  0000009d  PSHA
00006314  ffea8c05  JSR   0xffffea8c (TO 0x4da4)
00006318  00000801  ENT   0x8 (D 8)
0000631c  00003840  SL    0x38 (D 56)
00006320  00630803  JMP   <fwd>
os.c  2083:     case S_uptime:  a = ticks; break;
00006324  00216c15  LG    0x216c (D 8556)
00006328  00003840  SL    0x38 (D 56)
0000632c  00632003  JMP   <fwd>
os.c  2084:     case S_lseek:   a = lseek(a, b, c); break;
00006330  0000280e  LL    0x28 (D 40)
00006334  0000009d  PSHA
00006338  0000380e  LL    0x38 (D 56)
0000633c  0000009d  PSHA
00006340  0000480e  LL    0x48 (D 72)
00006344  0000009d  PSHA
00006348  ffcf8005  JSR   0xffffcf80 (TO 0x32cc)
0000634c  00001801  ENT   0x18 (D 24)
00006350  00003840  SL    0x38 (D 56)
00006354  00632c03  JMP   <fwd>
os.c  2085: //  case S_mount:   a = mount(a, b, c); break;
os.c  2086: //  case S_umount:  a = umount(a); break;
os.c  2087:     case S_socket:  a = socket(a, b, c); break;
00006358  0000280e  LL    0x28 (D 40)
0000635c  0000009d  PSHA
00006360  0000380e  LL    0x38 (D 56)
00006364  0000009d  PSHA
00006368  0000480e  LL    0x48 (D 72)
0000636c  0000009d  PSHA
00006370  ffeaa805  JSR   0xffffeaa8 (TO 0x4e1c)
00006374  00001801  ENT   0x18 (D 24)
00006378  00003840  SL    0x38 (D 56)
0000637c  00635403  JMP   <fwd>
os.c  2088:     case S_bind:    a = bind(a, b, c); break;
00006380  0000280e  LL    0x28 (D 40)
00006384  0000009d  PSHA
00006388  0000380e  LL    0x38 (D 56)
0000638c  0000009d  PSHA
00006390  0000480e  LL    0x48 (D 72)
00006394  0000009d  PSHA
00006398  ffee8c05  JSR   0xffffee8c (TO 0x5228)
0000639c  00001801  ENT   0x18 (D 24)
000063a0  00003840  SL    0x38 (D 56)
000063a4  00637c03  JMP   <fwd>
os.c  2089:     case S_listen:  a = listen(a, b); break;
000063a8  0000300e  LL    0x30 (D 48)
000063ac  0000009d  PSHA
000063b0  0000400e  LL    0x40 (D 64)
000063b4  0000009d  PSHA
000063b8  ffeefc05  JSR   0xffffeefc (TO 0x52b8)
000063bc  00001001  ENT   0x10 (D 16)
000063c0  00003840  SL    0x38 (D 56)
000063c4  0063a403  JMP   <fwd>
os.c  2090:     case S_poll:    a = poll(a, b, c); break;
000063c8  0000280e  LL    0x28 (D 40)
000063cc  0000009d  PSHA
000063d0  0000380e  LL    0x38 (D 56)
000063d4  0000009d  PSHA
000063d8  0000480e  LL    0x48 (D 72)
000063dc  0000009d  PSHA
000063e0  ffeb7805  JSR   0xffffeb78 (TO 0x4f5c)
000063e4  00001801  ENT   0x18 (D 24)
000063e8  00003840  SL    0x38 (D 56)
000063ec  0063c403  JMP   <fwd>
os.c  2091:     case S_accept:  a = accept(a, b, c); break;
000063f0  0000280e  LL    0x28 (D 40)
000063f4  0000009d  PSHA
000063f8  0000380e  LL    0x38 (D 56)
000063fc  0000009d  PSHA
00006400  0000480e  LL    0x48 (D 72)
00006404  0000009d  PSHA
00006408  ffef0805  JSR   0xffffef08 (TO 0x5314)
0000640c  00001801  ENT   0x18 (D 24)
00006410  00003840  SL    0x38 (D 56)
00006414  0063ec03  JMP   <fwd>
os.c  2092:     case S_connect: a = connect(a, b, c); break;
00006418  0000280e  LL    0x28 (D 40)
0000641c  0000009d  PSHA
00006420  0000380e  LL    0x38 (D 56)
00006424  0000009d  PSHA
00006428  0000480e  LL    0x48 (D 72)
0000642c  0000009d  PSHA
00006430  ffed6005  JSR   0xffffed60 (TO 0x5194)
00006434  00001801  ENT   0x18 (D 24)
00006438  00003840  SL    0x38 (D 56)
0000643c  00641403  JMP   <fwd>
os.c  2093:     default: printf("pid:%d name:%s unknown syscall %d\n", u->pid, u->name, a); a = -1; break;
00006440  0000380e  LL    0x38 (D 56)
00006444  0000009d  PSHA
00006448  00210015  LG    0x2100 (D 8448)
0000644c  00007454  ADDI  0x74 (D 116)
00006450  0000009d  PSHA
00006454  00210015  LG    0x2100 (D 8448)
00006458  0000181c  LX    0x18 (D 24)
0000645c  0000009d  PSHA
00006460  0003b208  LEAG  0x3b2 (D 946)
00006464  0000009d  PSHA
00006468  ff9f4c05  JSR   0xffff9f4c (TO 0x3b8)
0000646c  00002001  ENT   0x20 (D 32)
00006470  ffffff23  LI    0xffffffff (D -1)
00006474  00003840  SL    0x38 (D 56)
00006478  00643c03  JMP   <fwd>
os.c  2094:     }
os.c  2095:     if (u->killed) exit(-1);
0000647c  00647803  JMP   <fwd>
00006480  00001f3b  LBI   0x1f (D 31)
00006484  ffffb890  BGEU  0xffffffb8 (D -72)
00006488  0003d804  JMPI  0x3d8 (D 984)
0000648c  00210015  LG    0x2100 (D 8448)
00006490  00002c1c  LX    0x2c (D 44)
00006494  00000084  BZ    <fwd>
00006498  ffffff9e  PSHI  0xffffffff (D -1)
0000649c  ffe40805  JSR   0xffffe408 (TO 0x48a8)
000064a0  00000801  ENT   0x8 (D 8)
os.c  2096:     return;
000064a4  00000802  LEV   0x8 (D 8)
os.c  2097:     
os.c  2098:   case FMEM:          panic("FMEM from kernel");
000064a8  00045408  LEAG  0x454 (D 1108)
000064ac  0000009d  PSHA
000064b0  ffa08005  JSR   0xffffa080 (TO 0x534)
000064b4  00000801  ENT   0x8 (D 8)
os.c  2099:   case FMEM   + USER: printf("FMEM + USER\n"); exit(-1);  // XXX psignal(SIGBUS)
000064b8  00046508  LEAG  0x465 (D 1125)
000064bc  0000009d  PSHA
000064c0  ff9ef405  JSR   0xffff9ef4 (TO 0x3b8)
000064c4  00000801  ENT   0x8 (D 8)
000064c8  ffffff9e  PSHI  0xffffffff (D -1)
000064cc  ffe3d805  JSR   0xffffe3d8 (TO 0x48a8)
000064d0  00000801  ENT   0x8 (D 8)
os.c  2100:   case FPRIV:         panic("FPRIV from kernel");
000064d4  00047208  LEAG  0x472 (D 1138)
000064d8  0000009d  PSHA
000064dc  ffa05405  JSR   0xffffa054 (TO 0x534)
000064e0  00000801  ENT   0x8 (D 8)
os.c  2101:   case FPRIV  + USER: printf("FPRIV + USER\n"); exit(-1); // XXX psignal(SIGINS)
000064e4  00048408  LEAG  0x484 (D 1156)
000064e8  0000009d  PSHA
000064ec  ff9ec805  JSR   0xffff9ec8 (TO 0x3b8)
000064f0  00000801  ENT   0x8 (D 8)
000064f4  ffffff9e  PSHI  0xffffffff (D -1)
000064f8  ffe3ac05  JSR   0xffffe3ac (TO 0x48a8)
000064fc  00000801  ENT   0x8 (D 8)
os.c  2102:   case FINST:         panic("FINST from kernel");
00006500  00049208  LEAG  0x492 (D 1170)
00006504  0000009d  PSHA
00006508  ffa02805  JSR   0xffffa028 (TO 0x534)
0000650c  00000801  ENT   0x8 (D 8)
os.c  2103:   case FINST  + USER: printf("FINST + USER\n"); exit(-1); // psignal(SIGINS)
00006510  0004a408  LEAG  0x4a4 (D 1188)
00006514  0000009d  PSHA
00006518  ff9e9c05  JSR   0xffff9e9c (TO 0x3b8)
0000651c  00000801  ENT   0x8 (D 8)
00006520  ffffff9e  PSHI  0xffffffff (D -1)
00006524  ffe38005  JSR   0xffffe380 (TO 0x48a8)
00006528  00000801  ENT   0x8 (D 8)
os.c  2104:   case FARITH:        panic("FARITH from kernel");
0000652c  0004b208  LEAG  0x4b2 (D 1202)
00006530  0000009d  PSHA
00006534  ff9ffc05  JSR   0xffff9ffc (TO 0x534)
00006538  00000801  ENT   0x8 (D 8)
os.c  2105:   case FARITH + USER: printf("FARITH + USER\n"); exit(-1); // XXX psignal(SIGFPT)
0000653c  0004c508  LEAG  0x4c5 (D 1221)
00006540  0000009d  PSHA
00006544  ff9e7005  JSR   0xffff9e70 (TO 0x3b8)
00006548  00000801  ENT   0x8 (D 8)
0000654c  ffffff9e  PSHI  0xffffffff (D -1)
00006550  ffe35405  JSR   0xffffe354 (TO 0x48a8)
00006554  00000801  ENT   0x8 (D 8)
os.c  2106:   case FIPAGE:        printf("FIPAGE from kernel [0x%x]", lvadr()); panic("!\n");
00006558  ff9b1005  JSR   0xffff9b10 (TO 0x6c)
0000655c  0000009d  PSHA
00006560  0004d408  LEAG  0x4d4 (D 1236)
00006564  0000009d  PSHA
00006568  ff9e4c05  JSR   0xffff9e4c (TO 0x3b8)
0000656c  00001001  ENT   0x10 (D 16)
00006570  0004ee08  LEAG  0x4ee (D 1262)
00006574  0000009d  PSHA
00006578  ff9fb805  JSR   0xffff9fb8 (TO 0x534)
0000657c  00000801  ENT   0x8 (D 8)
os.c  2107:   case FIPAGE + USER: printf("FIPAGE + USER [0x%x]", lvadr()); exit(-1); // XXX psignal(SIGSEG) or page in
00006580  ff9ae805  JSR   0xffff9ae8 (TO 0x6c)
00006584  0000009d  PSHA
00006588  0004f108  LEAG  0x4f1 (D 1265)
0000658c  0000009d  PSHA
00006590  ff9e2405  JSR   0xffff9e24 (TO 0x3b8)
00006594  00001001  ENT   0x10 (D 16)
00006598  ffffff9e  PSHI  0xffffffff (D -1)
0000659c  ffe30805  JSR   0xffffe308 (TO 0x48a8)
000065a0  00000801  ENT   0x8 (D 8)
os.c  2108:   case FWPAGE:
os.c  2109:   case FWPAGE + USER:
os.c  2110:   case FRPAGE:        // XXX
os.c  2111:   case FRPAGE + USER: // XXX
os.c  2112:     if ((va = lvadr()) >= u->sz) exit(-1);
000065a4  00210015  LG    0x2100 (D 8448)
000065a8  0000081c  LX    0x8 (D 8)
000065ac  0000009d  PSHA
000065b0  ff9ab805  JSR   0xffff9ab8 (TO 0x6c)
000065b4  00000c40  SL    0xc (D 12)
000065b8  000000a1  POPB
000065bc  0000008d  BLTU  <fwd>
000065c0  ffffff9e  PSHI  0xffffffff (D -1)
000065c4  ffe2e005  JSR   0xffffe2e0 (TO 0x48a8)
000065c8  00000801  ENT   0x8 (D 8)
os.c  2113:     pc--; // printf("fault"); // restart instruction
000065cc  0000480e  LL    0x48 (D 72)
000065d0  00000457  SUBI  0x4 (D 4)
000065d4  00004840  SL    0x48 (D 72)
os.c  2114:     mappage(u->pdir, va & -PAGE, V2P+(memset(kalloc(), 0, PAGE)), PTE_P | PTE_W | PTE_U);
000065d8  0000079e  PSHI  0x7 (D 7)
000065dc  0010009e  PSHI  0x1000 (D 4096)
000065e0  0000009e  PSHI  0x0 (D 0)
000065e4  ff9c0405  JSR   0xffff9c04 (TO 0x1ec)
000065e8  0000009d  PSHA
000065ec  ff9a2805  JSR   0xffff9a28 (TO 0x18)
000065f0  00001801  ENT   0x18 (D 24)
000065f4  0000403b  LBI   0x40 (D 64)
000065f8  0000003c  LBHI  0x0 (D 0)
000065fc  00000053  ADD 
00006600  0000009d  PSHA
00006604  0000140e  LL    0x14 (D 20)
00006608  fff00069  ANDI  0xfffff000 (D -4096)
0000660c  0000009d  PSHA
00006610  00210015  LG    0x2100 (D 8448)
00006614  00000c1c  LX    0xc (D 12)
00006618  0000009d  PSHA
0000661c  fff37405  JSR   0xfffff374 (TO 0x5994)
00006620  00002001  ENT   0x20 (D 32)
os.c  2115:     return;
00006624  00000802  LEV   0x8 (D 8)
os.c  2116: 
os.c  2117:   case FTIMER: 
os.c  2118:   case FTIMER + USER: 
os.c  2119:     ticks++;
00006628  00216c15  LG    0x216c (D 8556)
0000662c  ffffff57  SUBI  0xffffffff (D -1)
00006630  00216c45  SG    0x216c (D 8556)
os.c  2120:     wakeup(&ticks);
00006634  00216c08  LEAG  0x216c (D 8556)
00006638  0000009d  PSHA
0000663c  ffee3805  JSR   0xffffee38 (TO 0x5478)
00006640  00000801  ENT   0x8 (D 8)
os.c  2121: 
os.c  2122:     // force process exit if it has been killed and is in user space
os.c  2123:     if (u->killed && (fc & USER)) exit(-1);
00006644  00210015  LG    0x2100 (D 8448)
00006648  00002c1c  LX    0x2c (D 44)
0000664c  00000084  BZ    <fwd>
00006650  0000400e  LL    0x40 (D 64)
00006654  00001069  ANDI  0x10 (D 16)
00006658  00664c84  BZ    <fwd>
0000665c  ffffff9e  PSHI  0xffffffff (D -1)
00006660  ffe24405  JSR   0xffffe244 (TO 0x48a8)
00006664  00000801  ENT   0x8 (D 8)
os.c  2124:  
os.c  2125:     // force process to give up CPU on clock tick
os.c  2126:     if (u->state != RUNNING) { printf("pid=%d state=%d\n", u->pid, u->state); panic("!\n"); }        
00006668  00210015  LG    0x2100 (D 8448)
0000666c  0000141c  LX    0x14 (D 20)
00006670  0000043b  LBI   0x4 (D 4)
00006674  00000088  BE    <fwd>
00006678  00210015  LG    0x2100 (D 8448)
0000667c  0000141c  LX    0x14 (D 20)
00006680  0000009d  PSHA
00006684  00210015  LG    0x2100 (D 8448)
00006688  0000181c  LX    0x18 (D 24)
0000668c  0000009d  PSHA
00006690  00050608  LEAG  0x506 (D 1286)
00006694  0000009d  PSHA
00006698  ff9d1c05  JSR   0xffff9d1c (TO 0x3b8)
0000669c  00001801  ENT   0x18 (D 24)
000066a0  00051708  LEAG  0x517 (D 1303)
000066a4  0000009d  PSHA
000066a8  ff9e8805  JSR   0xffff9e88 (TO 0x534)
000066ac  00000801  ENT   0x8 (D 8)
os.c  2127:     u->state = RUNNABLE;
000066b0  00210015  LG    0x2100 (D 8448)
000066b4  00001454  ADDI  0x14 (D 20)
000066b8  0000003e  LBA 
000066bc  00000323  LI    0x3 (D 3)
000066c0  0000004a  SX  
os.c  2128:     sched();
000066c4  fff90005  JSR   0xfffff900 (TO 0x5fc8)
os.c  2129: 
os.c  2130:     if (u->killed && (fc & USER)) exit(-1);
000066c8  00210015  LG    0x2100 (D 8448)
000066cc  00002c1c  LX    0x2c (D 44)
000066d0  00000084  BZ    <fwd>
000066d4  0000400e  LL    0x40 (D 64)
000066d8  00001069  ANDI  0x10 (D 16)
000066dc  0066d084  BZ    <fwd>
000066e0  ffffff9e  PSHI  0xffffffff (D -1)
000066e4  ffe1c005  JSR   0xffffe1c0 (TO 0x48a8)
000066e8  00000801  ENT   0x8 (D 8)
os.c  2131:     return;
000066ec  00000802  LEV   0x8 (D 8)
os.c  2132:     
os.c  2133:   case FKEYBD:
os.c  2134:   case FKEYBD + USER:
os.c  2135:     consoleintr();
000066f0  ff9efc05  JSR   0xffff9efc (TO 0x5f0)
os.c  2136:     return; //??XXX postkill?
000066f4  00000802  LEV   0x8 (D 8)
os.c  2137:   }
os.c  2138: }
000066f8  00000003  JMP   <fwd>
000066fc  00001a3b  LBI   0x1a (D 26)
00006700  0066f890  BGEU  <fwd>
00006704  00051c04  JMPI  0x51c (D 1308)
os.c  2139: 
os.c  2140: alltraps()
00006708  00000802  LEV   0x8 (D 8)
os.c  2141: {
os.c  2142:   asm(PSHA);
0000670c  0000009d  PSHA
os.c  2143:   asm(PSHB);
00006710  000000a0  PSHB
os.c  2144:   asm(PSHC);
00006714  000000ae  PSHC
os.c  2145:   asm(PSHF);
00006718  0000009f  PSHF
os.c  2146:   asm(PSHG);
0000671c  000000b1  PSHG
os.c  2147:   asm(LUSP); asm(PSHA);
00006720  000000aa  LUSP
00006724  0000009d  PSHA
os.c  2148:   trap();                // registers passed back out by magic reference :^O
00006728  fff96805  JSR   0xfffff968 (TO 0x6094)
os.c  2149:   asm(POPA); asm(SUSP);
0000672c  000000a3  POPA
00006730  000000ab  SUSP
os.c  2150:   asm(POPG);
00006734  000000b2  POPG
os.c  2151:   asm(POPF);
00006738  000000a2  POPF
os.c  2152:   asm(POPC);
0000673c  000000af  POPC
os.c  2153:   asm(POPB);
00006740  000000a1  POPB
os.c  2154:   asm(POPA);
00006744  000000a3  POPA
os.c  2155:   asm(RTI);
00006748  00000098  RTI 
os.c  2156: }
os.c  2157: 
os.c  2158: mainc()
0000674c  00000002  LEV   0x0 (D 0)
os.c  2159: {
os.c  2160:   kpdir[0] = 0;          // don't need low map anymore
00006750  00000023  LI    0x0 (D 0)
00006754  0021682d  LBG   0x2168 (D 8552)
00006758  0000004a  SX  
os.c  2161:   consoleinit();         // console device
0000675c  ffa0b405  JSR   0xffffa0b4 (TO 0x814)
os.c  2162:   ivec(alltraps);        // trap vector
00006760  ffffa808  LEAG  0xffffffa8 (D -88)
00006764  0000009d  PSHA
00006768  ff98f405  JSR   0xffff98f4 (TO 0x60)
0000676c  00000801  ENT   0x8 (D 8)
os.c  2163:   binit();               // buffer cache
00006770  ffa1d405  JSR   0xffffa1d4 (TO 0x948)
os.c  2164:   ideinit();             // disk
00006774  ffa0b005  JSR   0xffffa0b0 (TO 0x828)
os.c  2165:   stmr(128*1024);        // set timer
00006778  0200009e  PSHI  0x20000 (D 131072)
0000677c  ff98fc05  JSR   0xffff98fc (TO 0x7c)
00006780  00000801  ENT   0x8 (D 8)
os.c  2166:   userinit();            // first user process
00006784  ffef4805  JSR   0xffffef48 (TO 0x56d0)
os.c  2167:   printf("Welcome!\n");
00006788  00058408  LEAG  0x584 (D 1412)
0000678c  0000009d  PSHA
00006790  ff9c2405  JSR   0xffff9c24 (TO 0x3b8)
00006794  00000801  ENT   0x8 (D 8)
os.c  2168:   scheduler();           // start running processes
00006798  fff70c05  JSR   0xfffff70c (TO 0x5ea8)
os.c  2169: }
os.c  2170: 
os.c  2171: main()
0000679c  00000002  LEV   0x0 (D 0)
os.c  2172: {
os.c  2173:   int *ksp;              // temp kernel stack pointer
os.c  2174:   static char kstack[256]; // temp kernel stack
os.c  2175:   static int endbss;     // last variable in bss segment
os.c  2176:     
os.c  2177:   // initialize memory allocation
os.c  2178:   mem_top = kreserved = ((uint)&endbss + PAGE + 3) & -PAGE; 
000067a0  fffff801  ENT   0xfffffff8 (D -8)
000067a4  0348ef08  LEAG  0x348ef (D 215279)
000067a8  fff00069  ANDI  0xfffff000 (D -4096)
000067ac  00211445  SG    0x2114 (D 8468)
000067b0  00210c45  SG    0x210c (D 8460)
os.c  2179:   mem_sz = msiz();
000067b4  ff98bc05  JSR   0xffff98bc (TO 0x74)
000067b8  00211045  SG    0x2110 (D 8464)
os.c  2180:   
os.c  2181:   // initialize kernel page table
os.c  2182:   setupkvm();
000067bc  fff07805  JSR   0xfffff078 (TO 0x5838)
os.c  2183:   kpdir[0] = kpdir[(uint)USERTOP >> 22]; // need a 1:1 map of low physical memory for awhile
000067c0  00216815  LG    0x2168 (D 8552)
000067c4  000c001c  LX    0xc00 (D 3072)
000067c8  0021682d  LBG   0x2168 (D 8552)
000067cc  0000004a  SX  
os.c  2184: 
os.c  2185:   // initialize kernel stack pointer
os.c  2186:   ksp = ((uint)kstack + sizeof(kstack) - 8) & -8;
000067d0  0338e408  LEAG  0x338e4 (D 211172)
000067d4  fffff869  ANDI  0xfffffff8 (D -8)
000067d8  00000440  SL    0x4 (D 4)
os.c  2187:   asm(LL, 4);
000067dc  0000040e  LL    0x4 (D 4)
os.c  2188:   asm(SSP);
000067e0  0000009c  SSP 
os.c  2189: 
os.c  2190:   // turn on paging
os.c  2191:   pdir(kpdir);
000067e4  00216815  LG    0x2168 (D 8552)
000067e8  0000009d  PSHA
000067ec  ff989805  JSR   0xffff9898 (TO 0x88)
000067f0  00000801  ENT   0x8 (D 8)
os.c  2192:   spage(1);
000067f4  0000019e  PSHI  0x1 (D 1)
000067f8  ff989805  JSR   0xffff9898 (TO 0x94)
000067fc  00000801  ENT   0x8 (D 8)
os.c  2193:   kpdir = P2V+(uint)kpdir;
00006800  00216815  LG    0x2168 (D 8552)
00006804  ffffc03b  LBI   0xffffffc0 (D -64)
00006808  0000003c  LBHI  0x0 (D 0)
0000680c  00000053  ADD 
00006810  00216845  SG    0x2168 (D 8552)
os.c  2194:   mem_top = P2V+mem_top;
00006814  00210c15  LG    0x210c (D 8460)
00006818  ffffc03b  LBI   0xffffffc0 (D -64)
0000681c  0000003c  LBHI  0x0 (D 0)
00006820  00000053  ADD 
00006824  00210c45  SG    0x210c (D 8460)
os.c  2195: 
os.c  2196:   // jump (via return) to high memory
os.c  2197:   ksp = P2V+(((uint)kstack + sizeof(kstack) - 8) & -8);
00006828  0338e408  LEAG  0x338e4 (D 211172)
0000682c  fffff869  ANDI  0xfffffff8 (D -8)
00006830  ffffc03b  LBI   0xffffffc0 (D -64)
00006834  0000003c  LBHI  0x0 (D 0)
00006838  00000053  ADD 
0000683c  00000440  SL    0x4 (D 4)
os.c  2198:   *ksp = P2V+(uint)mainc;
00006840  ffff0c08  LEAG  0xffffff0c (D -244)
00006844  ffffc03b  LBI   0xffffffc0 (D -64)
00006848  0000003c  LBHI  0x0 (D 0)
0000684c  00000053  ADD 
00006850  00000426  LBL   0x4 (D 4)
00006854  0000004a  SX  
os.c  2199:   asm(LL, 4);
00006858  0000040e  LL    0x4 (D 4)
os.c  2200:   asm(SSP);
0000685c  0000009c  SSP 
os.c  2201:   asm(LEV);
00006860  00000002  LEV 
os.c  2202: }
os.c  2203: 
00006864  00000802  LEV   0x8 (D 8)
